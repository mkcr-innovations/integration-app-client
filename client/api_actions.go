/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ActionsAPI interface {

	/*
	ActionInstanceSetup Method for ActionInstanceSetup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiActionInstanceSetupRequest
	*/
	ActionInstanceSetup(ctx context.Context) ApiActionInstanceSetupRequest

	// ActionInstanceSetupExecute executes the request
	//  @return ActionInstanceDto
	ActionInstanceSetupExecute(r ApiActionInstanceSetupRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ApplyAction Method for ApplyAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiApplyActionRequest
	*/
	ApplyAction(ctx context.Context, id string) ApiApplyActionRequest

	// ApplyActionExecute executes the request
	//  @return []ActionDto
	ApplyActionExecute(r ApiApplyActionRequest) ([]ActionDto, *http.Response, error)

	/*
	ApplyActions Method for ApplyActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplyActionsRequest
	*/
	ApplyActions(ctx context.Context) ApiApplyActionsRequest

	// ApplyActionsExecute executes the request
	//  @return []ActionDto
	ApplyActionsExecute(r ApiApplyActionsRequest) ([]ActionDto, *http.Response, error)

	/*
	ArchiveAction Method for ArchiveAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the action to retrive
	@return ApiArchiveActionRequest
	*/
	ArchiveAction(ctx context.Context, id string) ApiArchiveActionRequest

	// ArchiveActionExecute executes the request
	ArchiveActionExecute(r ApiArchiveActionRequest) (*http.Response, error)

	/*
	ArchiveActions Method for ArchiveActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveActionsRequest
	*/
	ArchiveActions(ctx context.Context) ApiArchiveActionsRequest

	// ArchiveActionsExecute executes the request
	ArchiveActionsExecute(r ApiArchiveActionsRequest) (*http.Response, error)

	/*
	CreateAction Method for CreateAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateActionRequest
	*/
	CreateAction(ctx context.Context) ApiCreateActionRequest

	// CreateActionExecute executes the request
	//  @return ActionDto
	CreateActionExecute(r ApiCreateActionRequest) (*ActionDto, *http.Response, error)

	/*
	DeleteActionInstance Method for DeleteActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteActionInstanceRequest
	*/
	DeleteActionInstance(ctx context.Context) ApiDeleteActionInstanceRequest

	// DeleteActionInstanceExecute executes the request
	DeleteActionInstanceExecute(r ApiDeleteActionInstanceRequest) (*http.Response, error)

	/*
	GetAction Method for GetAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the action to retrive
	@return ApiGetActionRequest
	*/
	GetAction(ctx context.Context, id string) ApiGetActionRequest

	// GetActionExecute executes the request
	//  @return ActionDto
	GetActionExecute(r ApiGetActionRequest) (*ActionDto, *http.Response, error)

	/*
	GetActionInstance Method for GetActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetActionInstanceRequest
	*/
	GetActionInstance(ctx context.Context) ApiGetActionInstanceRequest

	// GetActionInstanceExecute executes the request
	//  @return ActionInstanceDto
	GetActionInstanceExecute(r ApiGetActionInstanceRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	GetActions Method for GetActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetActionsRequest
	*/
	GetActions(ctx context.Context) ApiGetActionsRequest

	// GetActionsExecute executes the request
	//  @return ActionDto
	GetActionsExecute(r ApiGetActionsRequest) (*ActionDto, *http.Response, error)

	/*
	ListActionInstances Method for ListActionInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListActionInstancesRequest
	*/
	ListActionInstances(ctx context.Context) ApiListActionInstancesRequest

	// ListActionInstancesExecute executes the request
	//  @return ListActionInstances200Response
	ListActionInstancesExecute(r ApiListActionInstancesRequest) (*ListActionInstances200Response, *http.Response, error)

	/*
	ListActions Method for ListActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListActionsRequest
	*/
	ListActions(ctx context.Context) ApiListActionsRequest

	// ListActionsExecute executes the request
	//  @return ListActions200Response
	ListActionsExecute(r ApiListActionsRequest) (*ListActions200Response, *http.Response, error)

	/*
	PatchAction Method for PatchAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the action to retrive
	@return ApiPatchActionRequest
	*/
	PatchAction(ctx context.Context, id string) ApiPatchActionRequest

	// PatchActionExecute executes the request
	//  @return ActionDto
	PatchActionExecute(r ApiPatchActionRequest) (*ActionDto, *http.Response, error)

	/*
	PatchActionInstance Method for PatchActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchActionInstanceRequest
	*/
	PatchActionInstance(ctx context.Context) ApiPatchActionInstanceRequest

	// PatchActionInstanceExecute executes the request
	//  @return ActionInstanceDto
	PatchActionInstanceExecute(r ApiPatchActionInstanceRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	PatchActions Method for PatchActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchActionsRequest
	*/
	PatchActions(ctx context.Context) ApiPatchActionsRequest

	// PatchActionsExecute executes the request
	//  @return ActionDto
	PatchActionsExecute(r ApiPatchActionsRequest) (*ActionDto, *http.Response, error)

	/*
	PostActionInstance Method for PostActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostActionInstanceRequest
	*/
	PostActionInstance(ctx context.Context) ApiPostActionInstanceRequest

	// PostActionInstanceExecute executes the request
	//  @return ActionInstanceDto
	PostActionInstanceExecute(r ApiPostActionInstanceRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	PutAction Method for PutAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the action to retrive
	@return ApiPutActionRequest
	*/
	PutAction(ctx context.Context, id string) ApiPutActionRequest

	// PutActionExecute executes the request
	//  @return ActionDto
	PutActionExecute(r ApiPutActionRequest) (*ActionDto, *http.Response, error)

	/*
	PutActionInstance Method for PutActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutActionInstanceRequest
	*/
	PutActionInstance(ctx context.Context) ApiPutActionInstanceRequest

	// PutActionInstanceExecute executes the request
	//  @return ActionInstanceDto
	PutActionInstanceExecute(r ApiPutActionInstanceRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	PutActions Method for PutActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutActionsRequest
	*/
	PutActions(ctx context.Context) ApiPutActionsRequest

	// PutActionsExecute executes the request
	//  @return ActionDto
	PutActionsExecute(r ApiPutActionsRequest) (*ActionDto, *http.Response, error)

	/*
	ResetAction Method for ResetAction

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiResetActionRequest
	*/
	ResetAction(ctx context.Context, id string) ApiResetActionRequest

	// ResetActionExecute executes the request
	//  @return ActionDto
	ResetActionExecute(r ApiResetActionRequest) (*ActionDto, *http.Response, error)

	/*
	ResetActionInstance Method for ResetActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetActionInstanceRequest
	*/
	ResetActionInstance(ctx context.Context) ApiResetActionInstanceRequest

	// ResetActionInstanceExecute executes the request
	//  @return ActionInstanceDto
	ResetActionInstanceExecute(r ApiResetActionInstanceRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ResetActions Method for ResetActions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetActionsRequest
	*/
	ResetActions(ctx context.Context) ApiResetActionsRequest

	// ResetActionsExecute executes the request
	//  @return ActionDto
	ResetActionsExecute(r ApiResetActionsRequest) (*ActionDto, *http.Response, error)

	/*
	RunActionInstance Method for RunActionInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRunActionInstanceRequest
	*/
	RunActionInstance(ctx context.Context) ApiRunActionInstanceRequest

	// RunActionInstanceExecute executes the request
	RunActionInstanceExecute(r ApiRunActionInstanceRequest) (*http.Response, error)
}

// ActionsAPIService ActionsAPI service
type ActionsAPIService service

type ApiActionInstanceSetupRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiActionInstanceSetupRequest) Id(id string) ApiActionInstanceSetupRequest {
	r.id = &id
	return r
}

func (r ApiActionInstanceSetupRequest) IntegrationKey(integrationKey string) ApiActionInstanceSetupRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiActionInstanceSetupRequest) IntegrationId(integrationId string) ApiActionInstanceSetupRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiActionInstanceSetupRequest) ConnectionId(connectionId string) ApiActionInstanceSetupRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiActionInstanceSetupRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ActionInstanceSetupExecute(r)
}

/*
ActionInstanceSetup Method for ActionInstanceSetup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActionInstanceSetupRequest
*/
func (a *ActionsAPIService) ActionInstanceSetup(ctx context.Context) ApiActionInstanceSetupRequest {
	return ApiActionInstanceSetupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ActionInstanceSetupExecute(r ApiActionInstanceSetupRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionInstanceSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance/setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	autoCreate *bool
}

func (r ApiApplyActionRequest) AutoCreate(autoCreate bool) ApiApplyActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiApplyActionRequest) Execute() ([]ActionDto, *http.Response, error) {
	return r.ApiService.ApplyActionExecute(r)
}

/*
ApplyAction Method for ApplyAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiApplyActionRequest
*/
func (a *ActionsAPIService) ApplyAction(ctx context.Context, id string) ApiApplyActionRequest {
	return ApiApplyActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ActionDto
func (a *ActionsAPIService) ApplyActionExecute(r ApiApplyActionRequest) ([]ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ApplyAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	autoCreate *bool
}

func (r ApiApplyActionsRequest) AutoCreate(autoCreate bool) ApiApplyActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiApplyActionsRequest) Execute() ([]ActionDto, *http.Response, error) {
	return r.ApiService.ApplyActionsExecute(r)
}

/*
ApplyActions Method for ApplyActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyActionsRequest
*/
func (a *ActionsAPIService) ApplyActions(ctx context.Context) ApiApplyActionsRequest {
	return ApiApplyActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ActionDto
func (a *ActionsAPIService) ApplyActionsExecute(r ApiApplyActionsRequest) ([]ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ApplyActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	autoCreate *bool
}

func (r ApiArchiveActionRequest) AutoCreate(autoCreate bool) ApiArchiveActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveActionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveActionExecute(r)
}

/*
ArchiveAction Method for ArchiveAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the action to retrive
 @return ApiArchiveActionRequest
*/
func (a *ActionsAPIService) ArchiveAction(ctx context.Context, id string) ApiArchiveActionRequest {
	return ApiArchiveActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ArchiveActionExecute(r ApiArchiveActionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ArchiveAction")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	autoCreate *bool
}

func (r ApiArchiveActionsRequest) AutoCreate(autoCreate bool) ApiArchiveActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveActionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveActionsExecute(r)
}

/*
ArchiveActions Method for ArchiveActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveActionsRequest
*/
func (a *ActionsAPIService) ArchiveActions(ctx context.Context) ApiArchiveActionsRequest {
	return ApiArchiveActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ArchiveActionsExecute(r ApiArchiveActionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ArchiveActions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	createActionDto *CreateActionDto
}

func (r ApiCreateActionRequest) CreateActionDto(createActionDto CreateActionDto) ApiCreateActionRequest {
	r.createActionDto = &createActionDto
	return r
}

func (r ApiCreateActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.CreateActionExecute(r)
}

/*
CreateAction Method for CreateAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateActionRequest
*/
func (a *ActionsAPIService) CreateAction(ctx context.Context) ApiCreateActionRequest {
	return ApiCreateActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) CreateActionExecute(r ApiCreateActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.CreateAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createActionDto == nil {
		return localVarReturnValue, nil, reportError("createActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDeleteActionInstanceRequest) IntegrationKey(integrationKey string) ApiDeleteActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDeleteActionInstanceRequest) IntegrationId(integrationId string) ApiDeleteActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDeleteActionInstanceRequest) ConnectionId(connectionId string) ApiDeleteActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDeleteActionInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteActionInstanceExecute(r)
}

/*
DeleteActionInstance Method for DeleteActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteActionInstanceRequest
*/
func (a *ActionsAPIService) DeleteActionInstance(ctx context.Context) ApiDeleteActionInstanceRequest {
	return ApiDeleteActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ActionsAPIService) DeleteActionInstanceExecute(r ApiDeleteActionInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.DeleteActionInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	autoCreate *bool
}

func (r ApiGetActionRequest) AutoCreate(autoCreate bool) ApiGetActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.GetActionExecute(r)
}

/*
GetAction Method for GetAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the action to retrive
 @return ApiGetActionRequest
*/
func (a *ActionsAPIService) GetAction(ctx context.Context, id string) ApiGetActionRequest {
	return ApiGetActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) GetActionExecute(r ApiGetActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.GetAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id *string
	integrationKey *string
	integrationId *string
	connectionId *string
	autoCreate *bool
	parentId *string
}

func (r ApiGetActionInstanceRequest) Id(id string) ApiGetActionInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetActionInstanceRequest) IntegrationKey(integrationKey string) ApiGetActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetActionInstanceRequest) IntegrationId(integrationId string) ApiGetActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetActionInstanceRequest) ConnectionId(connectionId string) ApiGetActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetActionInstanceRequest) AutoCreate(autoCreate bool) ApiGetActionInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetActionInstanceRequest) ParentId(parentId string) ApiGetActionInstanceRequest {
	r.parentId = &parentId
	return r
}

func (r ApiGetActionInstanceRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.GetActionInstanceExecute(r)
}

/*
GetActionInstance Method for GetActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionInstanceRequest
*/
func (a *ActionsAPIService) GetActionInstance(ctx context.Context) ApiGetActionInstanceRequest {
	return ApiGetActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) GetActionInstanceExecute(r ApiGetActionInstanceRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.GetActionInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	autoCreate *bool
}

func (r ApiGetActionsRequest) AutoCreate(autoCreate bool) ApiGetActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetActionsRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.GetActionsExecute(r)
}

/*
GetActions Method for GetActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionsRequest
*/
func (a *ActionsAPIService) GetActions(ctx context.Context) ApiGetActionsRequest {
	return ApiGetActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) GetActionsExecute(r ApiGetActionsRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.GetActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListActionInstancesRequest struct {
	ctx context.Context
	ApiService ActionsAPI
}

func (r ApiListActionInstancesRequest) Execute() (*ListActionInstances200Response, *http.Response, error) {
	return r.ApiService.ListActionInstancesExecute(r)
}

/*
ListActionInstances Method for ListActionInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListActionInstancesRequest
*/
func (a *ActionsAPIService) ListActionInstances(ctx context.Context) ApiListActionInstancesRequest {
	return ApiListActionInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListActionInstances200Response
func (a *ActionsAPIService) ListActionInstancesExecute(r ApiListActionInstancesRequest) (*ListActionInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListActionInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ListActionInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	integrationId *string
	integrationKey *string
	parentId *string
}

func (r ApiListActionsRequest) IntegrationId(integrationId string) ApiListActionsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListActionsRequest) IntegrationKey(integrationKey string) ApiListActionsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListActionsRequest) ParentId(parentId string) ApiListActionsRequest {
	r.parentId = &parentId
	return r
}

func (r ApiListActionsRequest) Execute() (*ListActions200Response, *http.Response, error) {
	return r.ApiService.ListActionsExecute(r)
}

/*
ListActions Method for ListActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListActionsRequest
*/
func (a *ActionsAPIService) ListActions(ctx context.Context) ApiListActionsRequest {
	return ApiListActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListActions200Response
func (a *ActionsAPIService) ListActionsExecute(r ApiListActionsRequest) (*ListActions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListActions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ListActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	updateActionDto *UpdateActionDto
	autoCreate *bool
}

func (r ApiPatchActionRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiPatchActionRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiPatchActionRequest) AutoCreate(autoCreate bool) ApiPatchActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.PatchActionExecute(r)
}

/*
PatchAction Method for PatchAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the action to retrive
 @return ApiPatchActionRequest
*/
func (a *ActionsAPIService) PatchAction(ctx context.Context, id string) ApiPatchActionRequest {
	return ApiPatchActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) PatchActionExecute(r ApiPatchActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PatchAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	updateActionInstanceDto *UpdateActionInstanceDto
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPatchActionInstanceRequest) UpdateActionInstanceDto(updateActionInstanceDto UpdateActionInstanceDto) ApiPatchActionInstanceRequest {
	r.updateActionInstanceDto = &updateActionInstanceDto
	return r
}

func (r ApiPatchActionInstanceRequest) IntegrationKey(integrationKey string) ApiPatchActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchActionInstanceRequest) IntegrationId(integrationId string) ApiPatchActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchActionInstanceRequest) ConnectionId(connectionId string) ApiPatchActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPatchActionInstanceRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.PatchActionInstanceExecute(r)
}

/*
PatchActionInstance Method for PatchActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchActionInstanceRequest
*/
func (a *ActionsAPIService) PatchActionInstance(ctx context.Context) ApiPatchActionInstanceRequest {
	return ApiPatchActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) PatchActionInstanceExecute(r ApiPatchActionInstanceRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PatchActionInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateActionInstanceDto is required and must be specified")
	}

	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	updateActionDto *UpdateActionDto
	autoCreate *bool
}

func (r ApiPatchActionsRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiPatchActionsRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiPatchActionsRequest) AutoCreate(autoCreate bool) ApiPatchActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchActionsRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.PatchActionsExecute(r)
}

/*
PatchActions Method for PatchActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchActionsRequest
*/
func (a *ActionsAPIService) PatchActions(ctx context.Context) ApiPatchActionsRequest {
	return ApiPatchActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) PatchActionsExecute(r ApiPatchActionsRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PatchActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	updateActionInstanceDto *UpdateActionInstanceDto
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPostActionInstanceRequest) UpdateActionInstanceDto(updateActionInstanceDto UpdateActionInstanceDto) ApiPostActionInstanceRequest {
	r.updateActionInstanceDto = &updateActionInstanceDto
	return r
}

func (r ApiPostActionInstanceRequest) IntegrationKey(integrationKey string) ApiPostActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPostActionInstanceRequest) IntegrationId(integrationId string) ApiPostActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPostActionInstanceRequest) ConnectionId(connectionId string) ApiPostActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPostActionInstanceRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.PostActionInstanceExecute(r)
}

/*
PostActionInstance Method for PostActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostActionInstanceRequest
*/
func (a *ActionsAPIService) PostActionInstance(ctx context.Context) ApiPostActionInstanceRequest {
	return ApiPostActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) PostActionInstanceExecute(r ApiPostActionInstanceRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PostActionInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateActionInstanceDto is required and must be specified")
	}

	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	updateActionDto *UpdateActionDto
	autoCreate *bool
}

func (r ApiPutActionRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiPutActionRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiPutActionRequest) AutoCreate(autoCreate bool) ApiPutActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.PutActionExecute(r)
}

/*
PutAction Method for PutAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the action to retrive
 @return ApiPutActionRequest
*/
func (a *ActionsAPIService) PutAction(ctx context.Context, id string) ApiPutActionRequest {
	return ApiPutActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) PutActionExecute(r ApiPutActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PutAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	updateActionInstanceDto *UpdateActionInstanceDto
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPutActionInstanceRequest) UpdateActionInstanceDto(updateActionInstanceDto UpdateActionInstanceDto) ApiPutActionInstanceRequest {
	r.updateActionInstanceDto = &updateActionInstanceDto
	return r
}

func (r ApiPutActionInstanceRequest) IntegrationKey(integrationKey string) ApiPutActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutActionInstanceRequest) IntegrationId(integrationId string) ApiPutActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutActionInstanceRequest) ConnectionId(connectionId string) ApiPutActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPutActionInstanceRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.PutActionInstanceExecute(r)
}

/*
PutActionInstance Method for PutActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutActionInstanceRequest
*/
func (a *ActionsAPIService) PutActionInstance(ctx context.Context) ApiPutActionInstanceRequest {
	return ApiPutActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) PutActionInstanceExecute(r ApiPutActionInstanceRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PutActionInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateActionInstanceDto is required and must be specified")
	}

	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	updateActionDto *UpdateActionDto
	autoCreate *bool
}

func (r ApiPutActionsRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiPutActionsRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiPutActionsRequest) AutoCreate(autoCreate bool) ApiPutActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutActionsRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.PutActionsExecute(r)
}

/*
PutActions Method for PutActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutActionsRequest
*/
func (a *ActionsAPIService) PutActions(ctx context.Context) ApiPutActionsRequest {
	return ApiPutActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) PutActionsExecute(r ApiPutActionsRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.PutActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	autoCreate *bool
}

func (r ApiResetActionRequest) AutoCreate(autoCreate bool) ApiResetActionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ResetActionExecute(r)
}

/*
ResetAction Method for ResetAction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiResetActionRequest
*/
func (a *ActionsAPIService) ResetAction(ctx context.Context, id string) ApiResetActionRequest {
	return ApiResetActionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ResetActionExecute(r ApiResetActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ResetAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiResetActionInstanceRequest) Id(id string) ApiResetActionInstanceRequest {
	r.id = &id
	return r
}

func (r ApiResetActionInstanceRequest) IntegrationKey(integrationKey string) ApiResetActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetActionInstanceRequest) IntegrationId(integrationId string) ApiResetActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetActionInstanceRequest) ConnectionId(connectionId string) ApiResetActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiResetActionInstanceRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ResetActionInstanceExecute(r)
}

/*
ResetActionInstance Method for ResetActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetActionInstanceRequest
*/
func (a *ActionsAPIService) ResetActionInstance(ctx context.Context) ApiResetActionInstanceRequest {
	return ApiResetActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ResetActionInstanceExecute(r ApiResetActionInstanceRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ResetActionInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	autoCreate *bool
}

func (r ApiResetActionsRequest) AutoCreate(autoCreate bool) ApiResetActionsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetActionsRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ResetActionsExecute(r)
}

/*
ResetActions Method for ResetActions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetActionsRequest
*/
func (a *ActionsAPIService) ResetActions(ctx context.Context) ApiResetActionsRequest {
	return ApiResetActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ResetActionsExecute(r ApiResetActionsRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ResetActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunActionInstanceRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	requestBody *map[string]interface{}
	id *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiRunActionInstanceRequest) RequestBody(requestBody map[string]interface{}) ApiRunActionInstanceRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiRunActionInstanceRequest) Id(id string) ApiRunActionInstanceRequest {
	r.id = &id
	return r
}

func (r ApiRunActionInstanceRequest) IntegrationKey(integrationKey string) ApiRunActionInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiRunActionInstanceRequest) IntegrationId(integrationId string) ApiRunActionInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiRunActionInstanceRequest) ConnectionId(connectionId string) ApiRunActionInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiRunActionInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunActionInstanceExecute(r)
}

/*
RunActionInstance Method for RunActionInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRunActionInstanceRequest
*/
func (a *ActionsAPIService) RunActionInstance(ctx context.Context) ApiRunActionInstanceRequest {
	return ApiRunActionInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ActionsAPIService) RunActionInstanceExecute(r ApiRunActionInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.RunActionInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instance/run"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
