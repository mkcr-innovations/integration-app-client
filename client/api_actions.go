/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ActionsAPI interface {

	/*
	ActionByIdControllerApply Apply action to integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerApplyRequest
	*/
	ActionByIdControllerApply(ctx context.Context, id string) ApiActionByIdControllerApplyRequest

	// ActionByIdControllerApplyExecute executes the request
	//  @return []ActionDto
	ActionByIdControllerApplyExecute(r ApiActionByIdControllerApplyRequest) ([]ActionDto, *http.Response, error)

	/*
	ActionByIdControllerArchive Delete action by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerArchiveRequest
	*/
	ActionByIdControllerArchive(ctx context.Context, id string) ApiActionByIdControllerArchiveRequest

	// ActionByIdControllerArchiveExecute executes the request
	ActionByIdControllerArchiveExecute(r ApiActionByIdControllerArchiveRequest) (*http.Response, error)

	/*
	ActionByIdControllerClone Method for ActionByIdControllerClone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerCloneRequest
	*/
	ActionByIdControllerClone(ctx context.Context, id string) ApiActionByIdControllerCloneRequest

	// ActionByIdControllerCloneExecute executes the request
	//  @return ActionDto
	ActionByIdControllerCloneExecute(r ApiActionByIdControllerCloneRequest) (*ActionDto, *http.Response, error)

	/*
	ActionByIdControllerExport Method for ActionByIdControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerExportRequest
	*/
	ActionByIdControllerExport(ctx context.Context, id string) ApiActionByIdControllerExportRequest

	// ActionByIdControllerExportExecute executes the request
	//  @return ActionExportDto
	ActionByIdControllerExportExecute(r ApiActionByIdControllerExportRequest) (*ActionExportDto, *http.Response, error)

	/*
	ActionByIdControllerGet Get action by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerGetRequest
	*/
	ActionByIdControllerGet(ctx context.Context, id string) ApiActionByIdControllerGetRequest

	// ActionByIdControllerGetExecute executes the request
	//  @return ActionDto
	ActionByIdControllerGetExecute(r ApiActionByIdControllerGetRequest) (*ActionDto, *http.Response, error)

	/*
	ActionByIdControllerPatch Patch action by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerPatchRequest
	*/
	ActionByIdControllerPatch(ctx context.Context, id string) ApiActionByIdControllerPatchRequest

	// ActionByIdControllerPatchExecute executes the request
	//  @return ActionDto
	ActionByIdControllerPatchExecute(r ApiActionByIdControllerPatchRequest) (*ActionDto, *http.Response, error)

	/*
	ActionByIdControllerPut Update action by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerPutRequest
	*/
	ActionByIdControllerPut(ctx context.Context, id string) ApiActionByIdControllerPutRequest

	// ActionByIdControllerPutExecute executes the request
	//  @return ActionDto
	ActionByIdControllerPutExecute(r ApiActionByIdControllerPutRequest) (*ActionDto, *http.Response, error)

	/*
	ActionByIdControllerReset Reset action by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiActionByIdControllerResetRequest
	*/
	ActionByIdControllerReset(ctx context.Context, id string) ApiActionByIdControllerResetRequest

	// ActionByIdControllerResetExecute executes the request
	//  @return ActionDto
	ActionByIdControllerResetExecute(r ApiActionByIdControllerResetRequest) (*ActionDto, *http.Response, error)

	/*
	ActionInstancesControllerListActionInstances List action instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiActionInstancesControllerListActionInstancesRequest
	*/
	ActionInstancesControllerListActionInstances(ctx context.Context) ApiActionInstancesControllerListActionInstancesRequest

	// ActionInstancesControllerListActionInstancesExecute executes the request
	//  @return ActionInstancesControllerListActionInstances200Response
	ActionInstancesControllerListActionInstancesExecute(r ApiActionInstancesControllerListActionInstancesRequest) (*ActionInstancesControllerListActionInstances200Response, *http.Response, error)

	/*
	ActionsControllerCreateAction Create action

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiActionsControllerCreateActionRequest
	*/
	ActionsControllerCreateAction(ctx context.Context) ApiActionsControllerCreateActionRequest

	// ActionsControllerCreateActionExecute executes the request
	//  @return ActionDto
	ActionsControllerCreateActionExecute(r ApiActionsControllerCreateActionRequest) (*ActionDto, *http.Response, error)

	/*
	ActionsControllerListActions List actions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiActionsControllerListActionsRequest
	*/
	ActionsControllerListActions(ctx context.Context) ApiActionsControllerListActionsRequest

	// ActionsControllerListActionsExecute executes the request
	//  @return ActionsControllerListActions200Response
	ActionsControllerListActionsExecute(r ApiActionsControllerListActionsRequest) (*ActionsControllerListActions200Response, *http.Response, error)

	/*
	ConnectionLevelActionControllerArchive Archive action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerArchiveRequest
	*/
	ConnectionLevelActionControllerArchive(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerArchiveRequest

	// ConnectionLevelActionControllerArchiveExecute executes the request
	ConnectionLevelActionControllerArchiveExecute(r ApiConnectionLevelActionControllerArchiveRequest) (*http.Response, error)

	/*
	ConnectionLevelActionControllerGet Get action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerGetRequest
	*/
	ConnectionLevelActionControllerGet(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerGetRequest

	// ConnectionLevelActionControllerGetExecute executes the request
	//  @return ActionInstanceDto
	ConnectionLevelActionControllerGetExecute(r ApiConnectionLevelActionControllerGetRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ConnectionLevelActionControllerPatch Patch update action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerPatchRequest
	*/
	ConnectionLevelActionControllerPatch(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerPatchRequest

	// ConnectionLevelActionControllerPatchExecute executes the request
	//  @return ActionInstanceDto
	ConnectionLevelActionControllerPatchExecute(r ApiConnectionLevelActionControllerPatchRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ConnectionLevelActionControllerPut Create or Replace action instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerPutRequest
	*/
	ConnectionLevelActionControllerPut(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerPutRequest

	// ConnectionLevelActionControllerPutExecute executes the request
	//  @return ActionInstanceDto
	ConnectionLevelActionControllerPutExecute(r ApiConnectionLevelActionControllerPutRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ConnectionLevelActionControllerReset Reset action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerResetRequest
	*/
	ConnectionLevelActionControllerReset(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerResetRequest

	// ConnectionLevelActionControllerResetExecute executes the request
	//  @return ActionInstanceDto
	ConnectionLevelActionControllerResetExecute(r ApiConnectionLevelActionControllerResetRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ConnectionLevelActionControllerRun Run action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerRunRequest
	*/
	ConnectionLevelActionControllerRun(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerRunRequest

	// ConnectionLevelActionControllerRunExecute executes the request
	ConnectionLevelActionControllerRunExecute(r ApiConnectionLevelActionControllerRunRequest) (*http.Response, error)

	/*
	ConnectionLevelActionControllerSetup Setup action instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionControllerSetupRequest
	*/
	ConnectionLevelActionControllerSetup(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerSetupRequest

	// ConnectionLevelActionControllerSetupExecute executes the request
	//  @return ActionInstanceDto
	ConnectionLevelActionControllerSetupExecute(r ApiConnectionLevelActionControllerSetupRequest) (*ActionInstanceDto, *http.Response, error)

	/*
	ConnectionLevelActionsControllerList List action instances for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelActionsControllerListRequest
	*/
	ConnectionLevelActionsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelActionsControllerListRequest

	// ConnectionLevelActionsControllerListExecute executes the request
	ConnectionLevelActionsControllerListExecute(r ApiConnectionLevelActionsControllerListRequest) (*http.Response, error)

	/*
	IntegrationLevelActionControllerArchive Archive action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionControllerArchiveRequest
	*/
	IntegrationLevelActionControllerArchive(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerArchiveRequest

	// IntegrationLevelActionControllerArchiveExecute executes the request
	IntegrationLevelActionControllerArchiveExecute(r ApiIntegrationLevelActionControllerArchiveRequest) (*http.Response, error)

	/*
	IntegrationLevelActionControllerExport Method for IntegrationLevelActionControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector
	@param integrationSelector
	@return ApiIntegrationLevelActionControllerExportRequest
	*/
	IntegrationLevelActionControllerExport(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerExportRequest

	// IntegrationLevelActionControllerExportExecute executes the request
	//  @return ActionExportDto
	IntegrationLevelActionControllerExportExecute(r ApiIntegrationLevelActionControllerExportRequest) (*ActionExportDto, *http.Response, error)

	/*
	IntegrationLevelActionControllerGet Get action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionControllerGetRequest
	*/
	IntegrationLevelActionControllerGet(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerGetRequest

	// IntegrationLevelActionControllerGetExecute executes the request
	//  @return ActionDto
	IntegrationLevelActionControllerGetExecute(r ApiIntegrationLevelActionControllerGetRequest) (*ActionDto, *http.Response, error)

	/*
	IntegrationLevelActionControllerPatch Patch update action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionControllerPatchRequest
	*/
	IntegrationLevelActionControllerPatch(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerPatchRequest

	// IntegrationLevelActionControllerPatchExecute executes the request
	//  @return ActionDto
	IntegrationLevelActionControllerPatchExecute(r ApiIntegrationLevelActionControllerPatchRequest) (*ActionDto, *http.Response, error)

	/*
	IntegrationLevelActionControllerPut Update action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionControllerPutRequest
	*/
	IntegrationLevelActionControllerPut(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerPutRequest

	// IntegrationLevelActionControllerPutExecute executes the request
	//  @return ActionDto
	IntegrationLevelActionControllerPutExecute(r ApiIntegrationLevelActionControllerPutRequest) (*ActionDto, *http.Response, error)

	/*
	IntegrationLevelActionControllerReset Reset action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionSelector Action Key or Id
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionControllerResetRequest
	*/
	IntegrationLevelActionControllerReset(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerResetRequest

	// IntegrationLevelActionControllerResetExecute executes the request
	//  @return ActionDto
	IntegrationLevelActionControllerResetExecute(r ApiIntegrationLevelActionControllerResetRequest) (*ActionDto, *http.Response, error)

	/*
	IntegrationLevelActionsControllerCreate Create action for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionsControllerCreateRequest
	*/
	IntegrationLevelActionsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelActionsControllerCreateRequest

	// IntegrationLevelActionsControllerCreateExecute executes the request
	//  @return ActionDto
	IntegrationLevelActionsControllerCreateExecute(r ApiIntegrationLevelActionsControllerCreateRequest) (*ActionDto, *http.Response, error)

	/*
	IntegrationLevelActionsControllerList List actions for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelActionsControllerListRequest
	*/
	IntegrationLevelActionsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelActionsControllerListRequest

	// IntegrationLevelActionsControllerListExecute executes the request
	//  @return ActionsControllerListActions200Response
	IntegrationLevelActionsControllerListExecute(r ApiIntegrationLevelActionsControllerListRequest) (*ActionsControllerListActions200Response, *http.Response, error)
}

// ActionsAPIService ActionsAPI service
type ActionsAPIService service

type ApiActionByIdControllerApplyRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	applyToIntegrationsDto *ApplyToIntegrationsDto
}

func (r ApiActionByIdControllerApplyRequest) ApplyToIntegrationsDto(applyToIntegrationsDto ApplyToIntegrationsDto) ApiActionByIdControllerApplyRequest {
	r.applyToIntegrationsDto = &applyToIntegrationsDto
	return r
}

func (r ApiActionByIdControllerApplyRequest) Execute() ([]ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerApplyExecute(r)
}

/*
ActionByIdControllerApply Apply action to integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerApplyRequest
*/
func (a *ActionsAPIService) ActionByIdControllerApply(ctx context.Context, id string) ApiActionByIdControllerApplyRequest {
	return ApiActionByIdControllerApplyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ActionDto
func (a *ActionsAPIService) ActionByIdControllerApplyExecute(r ApiActionByIdControllerApplyRequest) ([]ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerApply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyToIntegrationsDto == nil {
		return localVarReturnValue, nil, reportError("applyToIntegrationsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyToIntegrationsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerArchiveRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
}

func (r ApiActionByIdControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActionByIdControllerArchiveExecute(r)
}

/*
ActionByIdControllerArchive Delete action by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerArchiveRequest
*/
func (a *ActionsAPIService) ActionByIdControllerArchive(ctx context.Context, id string) ApiActionByIdControllerArchiveRequest {
	return ApiActionByIdControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ActionByIdControllerArchiveExecute(r ApiActionByIdControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiActionByIdControllerCloneRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
}

func (r ApiActionByIdControllerCloneRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerCloneExecute(r)
}

/*
ActionByIdControllerClone Method for ActionByIdControllerClone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerCloneRequest
*/
func (a *ActionsAPIService) ActionByIdControllerClone(ctx context.Context, id string) ApiActionByIdControllerCloneRequest {
	return ApiActionByIdControllerCloneRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionByIdControllerCloneExecute(r ApiActionByIdControllerCloneRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerExportRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
}

func (r ApiActionByIdControllerExportRequest) Execute() (*ActionExportDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerExportExecute(r)
}

/*
ActionByIdControllerExport Method for ActionByIdControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerExportRequest
*/
func (a *ActionsAPIService) ActionByIdControllerExport(ctx context.Context, id string) ApiActionByIdControllerExportRequest {
	return ApiActionByIdControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionExportDto
func (a *ActionsAPIService) ActionByIdControllerExportExecute(r ApiActionByIdControllerExportRequest) (*ActionExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerGetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
}

func (r ApiActionByIdControllerGetRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerGetExecute(r)
}

/*
ActionByIdControllerGet Get action by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerGetRequest
*/
func (a *ActionsAPIService) ActionByIdControllerGet(ctx context.Context, id string) ApiActionByIdControllerGetRequest {
	return ApiActionByIdControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionByIdControllerGetExecute(r ApiActionByIdControllerGetRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerPatchRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	updateActionDto *UpdateActionDto
}

func (r ApiActionByIdControllerPatchRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiActionByIdControllerPatchRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiActionByIdControllerPatchRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerPatchExecute(r)
}

/*
ActionByIdControllerPatch Patch action by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerPatchRequest
*/
func (a *ActionsAPIService) ActionByIdControllerPatch(ctx context.Context, id string) ApiActionByIdControllerPatchRequest {
	return ApiActionByIdControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionByIdControllerPatchExecute(r ApiActionByIdControllerPatchRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerPutRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
	updateActionDto *UpdateActionDto
}

func (r ApiActionByIdControllerPutRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiActionByIdControllerPutRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiActionByIdControllerPutRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerPutExecute(r)
}

/*
ActionByIdControllerPut Update action by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerPutRequest
*/
func (a *ActionsAPIService) ActionByIdControllerPut(ctx context.Context, id string) ApiActionByIdControllerPutRequest {
	return ApiActionByIdControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionByIdControllerPutExecute(r ApiActionByIdControllerPutRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionByIdControllerResetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	id string
}

func (r ApiActionByIdControllerResetRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionByIdControllerResetExecute(r)
}

/*
ActionByIdControllerReset Reset action by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiActionByIdControllerResetRequest
*/
func (a *ActionsAPIService) ActionByIdControllerReset(ctx context.Context, id string) ApiActionByIdControllerResetRequest {
	return ApiActionByIdControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionByIdControllerResetExecute(r ApiActionByIdControllerResetRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionByIdControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionInstancesControllerListActionInstancesRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
}

func (r ApiActionInstancesControllerListActionInstancesRequest) Limit(limit float32) ApiActionInstancesControllerListActionInstancesRequest {
	r.limit = &limit
	return r
}

func (r ApiActionInstancesControllerListActionInstancesRequest) Cursor(cursor string) ApiActionInstancesControllerListActionInstancesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiActionInstancesControllerListActionInstancesRequest) Search(search string) ApiActionInstancesControllerListActionInstancesRequest {
	r.search = &search
	return r
}

func (r ApiActionInstancesControllerListActionInstancesRequest) ConnectorId(connectorId string) ApiActionInstancesControllerListActionInstancesRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiActionInstancesControllerListActionInstancesRequest) IncludeArchived(includeArchived bool) ApiActionInstancesControllerListActionInstancesRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiActionInstancesControllerListActionInstancesRequest) Execute() (*ActionInstancesControllerListActionInstances200Response, *http.Response, error) {
	return r.ApiService.ActionInstancesControllerListActionInstancesExecute(r)
}

/*
ActionInstancesControllerListActionInstances List action instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActionInstancesControllerListActionInstancesRequest
*/
func (a *ActionsAPIService) ActionInstancesControllerListActionInstances(ctx context.Context) ApiActionInstancesControllerListActionInstancesRequest {
	return ApiActionInstancesControllerListActionInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionInstancesControllerListActionInstances200Response
func (a *ActionsAPIService) ActionInstancesControllerListActionInstancesExecute(r ApiActionInstancesControllerListActionInstancesRequest) (*ActionInstancesControllerListActionInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstancesControllerListActionInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionInstancesControllerListActionInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/action-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsControllerCreateActionRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	createActionDto *CreateActionDto
}

func (r ApiActionsControllerCreateActionRequest) CreateActionDto(createActionDto CreateActionDto) ApiActionsControllerCreateActionRequest {
	r.createActionDto = &createActionDto
	return r
}

func (r ApiActionsControllerCreateActionRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.ActionsControllerCreateActionExecute(r)
}

/*
ActionsControllerCreateAction Create action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActionsControllerCreateActionRequest
*/
func (a *ActionsAPIService) ActionsControllerCreateAction(ctx context.Context) ApiActionsControllerCreateActionRequest {
	return ApiActionsControllerCreateActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) ActionsControllerCreateActionExecute(r ApiActionsControllerCreateActionRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionsControllerCreateAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createActionDto == nil {
		return localVarReturnValue, nil, reportError("createActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActionsControllerListActionsRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	integrationId *string
	integrationKey *string
	parentId *string
}

func (r ApiActionsControllerListActionsRequest) Limit(limit float32) ApiActionsControllerListActionsRequest {
	r.limit = &limit
	return r
}

func (r ApiActionsControllerListActionsRequest) Cursor(cursor string) ApiActionsControllerListActionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiActionsControllerListActionsRequest) Search(search string) ApiActionsControllerListActionsRequest {
	r.search = &search
	return r
}

func (r ApiActionsControllerListActionsRequest) ConnectorId(connectorId string) ApiActionsControllerListActionsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiActionsControllerListActionsRequest) IncludeArchived(includeArchived bool) ApiActionsControllerListActionsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiActionsControllerListActionsRequest) IntegrationId(integrationId string) ApiActionsControllerListActionsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiActionsControllerListActionsRequest) IntegrationKey(integrationKey string) ApiActionsControllerListActionsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiActionsControllerListActionsRequest) ParentId(parentId string) ApiActionsControllerListActionsRequest {
	r.parentId = &parentId
	return r
}

func (r ApiActionsControllerListActionsRequest) Execute() (*ActionsControllerListActions200Response, *http.Response, error) {
	return r.ApiService.ActionsControllerListActionsExecute(r)
}

/*
ActionsControllerListActions List actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActionsControllerListActionsRequest
*/
func (a *ActionsAPIService) ActionsControllerListActions(ctx context.Context) ApiActionsControllerListActionsRequest {
	return ApiActionsControllerListActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionsControllerListActions200Response
func (a *ActionsAPIService) ActionsControllerListActionsExecute(r ApiActionsControllerListActionsRequest) (*ActionsControllerListActions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsControllerListActions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ActionsControllerListActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerArchiveRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerArchiveRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerArchiveRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerArchiveRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerArchiveRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerArchiveExecute(r)
}

/*
ConnectionLevelActionControllerArchive Archive action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerArchiveRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerArchive(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerArchiveRequest {
	return ApiConnectionLevelActionControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ConnectionLevelActionControllerArchiveExecute(r ApiConnectionLevelActionControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerGetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerGetRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerGetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerGetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerGetRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerGetExecute(r)
}

/*
ConnectionLevelActionControllerGet Get action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerGetRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerGet(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerGetRequest {
	return ApiConnectionLevelActionControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ConnectionLevelActionControllerGetExecute(r ApiConnectionLevelActionControllerGetRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerPatchRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	updateActionInstanceDto *UpdateActionInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerPatchRequest) UpdateActionInstanceDto(updateActionInstanceDto UpdateActionInstanceDto) ApiConnectionLevelActionControllerPatchRequest {
	r.updateActionInstanceDto = &updateActionInstanceDto
	return r
}

func (r ApiConnectionLevelActionControllerPatchRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerPatchRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerPatchRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerPatchRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerPatchRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerPatchExecute(r)
}

/*
ConnectionLevelActionControllerPatch Patch update action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerPatchRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerPatch(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerPatchRequest {
	return ApiConnectionLevelActionControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ConnectionLevelActionControllerPatchExecute(r ApiConnectionLevelActionControllerPatchRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateActionInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerPutRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	updateActionInstanceDto *UpdateActionInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerPutRequest) UpdateActionInstanceDto(updateActionInstanceDto UpdateActionInstanceDto) ApiConnectionLevelActionControllerPutRequest {
	r.updateActionInstanceDto = &updateActionInstanceDto
	return r
}

func (r ApiConnectionLevelActionControllerPutRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerPutRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerPutRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerPutRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerPutRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerPutExecute(r)
}

/*
ConnectionLevelActionControllerPut Create or Replace action instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerPutRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerPut(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerPutRequest {
	return ApiConnectionLevelActionControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ConnectionLevelActionControllerPutExecute(r ApiConnectionLevelActionControllerPutRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateActionInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerResetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerResetRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerResetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerResetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerResetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerResetRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerResetExecute(r)
}

/*
ConnectionLevelActionControllerReset Reset action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerResetRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerReset(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerResetRequest {
	return ApiConnectionLevelActionControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ConnectionLevelActionControllerResetExecute(r ApiConnectionLevelActionControllerResetRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerRunRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerRunRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerRunRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerRunRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerRunRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerRunExecute(r)
}

/*
ConnectionLevelActionControllerRun Run action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerRunRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerRun(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerRunRequest {
	return ApiConnectionLevelActionControllerRunRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ConnectionLevelActionControllerRunExecute(r ApiConnectionLevelActionControllerRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionLevelActionControllerSetupRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelActionControllerSetupRequest) InstanceKey(instanceKey string) ApiConnectionLevelActionControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelActionControllerSetupRequest) AutoCreate(autoCreate bool) ApiConnectionLevelActionControllerSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelActionControllerSetupRequest) Execute() (*ActionInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelActionControllerSetupExecute(r)
}

/*
ConnectionLevelActionControllerSetup Setup action instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionControllerSetupRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionControllerSetup(ctx context.Context, actionSelector string, connectionSelector string) ApiConnectionLevelActionControllerSetupRequest {
	return ApiConnectionLevelActionControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return ActionInstanceDto
func (a *ActionsAPIService) ConnectionLevelActionControllerSetupExecute(r ApiConnectionLevelActionControllerSetupRequest) (*ActionInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions/{actionSelector}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelActionsControllerListRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	connectionSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	parentId *string
	universalParentId *string
}

func (r ApiConnectionLevelActionsControllerListRequest) Limit(limit float32) ApiConnectionLevelActionsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) Cursor(cursor string) ApiConnectionLevelActionsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) Search(search string) ApiConnectionLevelActionsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) ConnectorId(connectorId string) ApiConnectionLevelActionsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) IncludeArchived(includeArchived bool) ApiConnectionLevelActionsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) ParentId(parentId string) ApiConnectionLevelActionsControllerListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) UniversalParentId(universalParentId string) ApiConnectionLevelActionsControllerListRequest {
	r.universalParentId = &universalParentId
	return r
}

func (r ApiConnectionLevelActionsControllerListRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelActionsControllerListExecute(r)
}

/*
ConnectionLevelActionsControllerList List action instances for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelActionsControllerListRequest
*/
func (a *ActionsAPIService) ConnectionLevelActionsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelActionsControllerListRequest {
	return ApiConnectionLevelActionsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *ActionsAPIService) ConnectionLevelActionsControllerListExecute(r ApiConnectionLevelActionsControllerListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.ConnectionLevelActionsControllerList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.universalParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalParentId", r.universalParentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerArchiveRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelActionControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerArchiveExecute(r)
}

/*
IntegrationLevelActionControllerArchive Archive action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionControllerArchiveRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerArchive(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerArchiveRequest {
	return ApiIntegrationLevelActionControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
func (a *ActionsAPIService) IntegrationLevelActionControllerArchiveExecute(r ApiIntegrationLevelActionControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerExportRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelActionControllerExportRequest) Execute() (*ActionExportDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerExportExecute(r)
}

/*
IntegrationLevelActionControllerExport Method for IntegrationLevelActionControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector
 @param integrationSelector
 @return ApiIntegrationLevelActionControllerExportRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerExport(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerExportRequest {
	return ApiIntegrationLevelActionControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionExportDto
func (a *ActionsAPIService) IntegrationLevelActionControllerExportExecute(r ApiIntegrationLevelActionControllerExportRequest) (*ActionExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerGetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelActionControllerGetRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerGetExecute(r)
}

/*
IntegrationLevelActionControllerGet Get action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionControllerGetRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerGet(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerGetRequest {
	return ApiIntegrationLevelActionControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) IntegrationLevelActionControllerGetExecute(r ApiIntegrationLevelActionControllerGetRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerPatchRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
	updateActionDto *UpdateActionDto
}

func (r ApiIntegrationLevelActionControllerPatchRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiIntegrationLevelActionControllerPatchRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiIntegrationLevelActionControllerPatchRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerPatchExecute(r)
}

/*
IntegrationLevelActionControllerPatch Patch update action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionControllerPatchRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerPatch(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerPatchRequest {
	return ApiIntegrationLevelActionControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) IntegrationLevelActionControllerPatchExecute(r ApiIntegrationLevelActionControllerPatchRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerPutRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
	updateActionDto *UpdateActionDto
}

func (r ApiIntegrationLevelActionControllerPutRequest) UpdateActionDto(updateActionDto UpdateActionDto) ApiIntegrationLevelActionControllerPutRequest {
	r.updateActionDto = &updateActionDto
	return r
}

func (r ApiIntegrationLevelActionControllerPutRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerPutExecute(r)
}

/*
IntegrationLevelActionControllerPut Update action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionControllerPutRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerPut(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerPutRequest {
	return ApiIntegrationLevelActionControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) IntegrationLevelActionControllerPutExecute(r ApiIntegrationLevelActionControllerPutRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateActionDto == nil {
		return localVarReturnValue, nil, reportError("updateActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionControllerResetRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	actionSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelActionControllerResetRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionControllerResetExecute(r)
}

/*
IntegrationLevelActionControllerReset Reset action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actionSelector Action Key or Id
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionControllerResetRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionControllerReset(ctx context.Context, actionSelector string, integrationSelector string) ApiIntegrationLevelActionControllerResetRequest {
	return ApiIntegrationLevelActionControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		actionSelector: actionSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) IntegrationLevelActionControllerResetExecute(r ApiIntegrationLevelActionControllerResetRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions/{actionSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"actionSelector"+"}", url.PathEscape(parameterValueToString(r.actionSelector, "actionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionsControllerCreateRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	integrationSelector string
	createIntegrationLevelActionDto *CreateIntegrationLevelActionDto
}

func (r ApiIntegrationLevelActionsControllerCreateRequest) CreateIntegrationLevelActionDto(createIntegrationLevelActionDto CreateIntegrationLevelActionDto) ApiIntegrationLevelActionsControllerCreateRequest {
	r.createIntegrationLevelActionDto = &createIntegrationLevelActionDto
	return r
}

func (r ApiIntegrationLevelActionsControllerCreateRequest) Execute() (*ActionDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionsControllerCreateExecute(r)
}

/*
IntegrationLevelActionsControllerCreate Create action for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionsControllerCreateRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelActionsControllerCreateRequest {
	return ApiIntegrationLevelActionsControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionDto
func (a *ActionsAPIService) IntegrationLevelActionsControllerCreateExecute(r ApiIntegrationLevelActionsControllerCreateRequest) (*ActionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionsControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationLevelActionDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationLevelActionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationLevelActionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelActionsControllerListRequest struct {
	ctx context.Context
	ApiService ActionsAPI
	integrationSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	parentId *string
}

func (r ApiIntegrationLevelActionsControllerListRequest) Limit(limit float32) ApiIntegrationLevelActionsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) Cursor(cursor string) ApiIntegrationLevelActionsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) Search(search string) ApiIntegrationLevelActionsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) ConnectorId(connectorId string) ApiIntegrationLevelActionsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) IncludeArchived(includeArchived bool) ApiIntegrationLevelActionsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) ParentId(parentId string) ApiIntegrationLevelActionsControllerListRequest {
	r.parentId = &parentId
	return r
}

func (r ApiIntegrationLevelActionsControllerListRequest) Execute() (*ActionsControllerListActions200Response, *http.Response, error) {
	return r.ApiService.IntegrationLevelActionsControllerListExecute(r)
}

/*
IntegrationLevelActionsControllerList List actions for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelActionsControllerListRequest
*/
func (a *ActionsAPIService) IntegrationLevelActionsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelActionsControllerListRequest {
	return ApiIntegrationLevelActionsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return ActionsControllerListActions200Response
func (a *ActionsAPIService) IntegrationLevelActionsControllerListExecute(r ApiIntegrationLevelActionsControllerListRequest) (*ActionsControllerListActions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionsControllerListActions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActionsAPIService.IntegrationLevelActionsControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
