/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type DataSourcesAPI interface {

	/*
	ConnectionLevelDataSourceControllerArchive Archive data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerArchiveRequest
	*/
	ConnectionLevelDataSourceControllerArchive(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerArchiveRequest

	// ConnectionLevelDataSourceControllerArchiveExecute executes the request
	ConnectionLevelDataSourceControllerArchiveExecute(r ApiConnectionLevelDataSourceControllerArchiveRequest) (*http.Response, error)

	/*
	ConnectionLevelDataSourceControllerCreate Create data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@param dataSourceSelector Data Source ID or Key
	@return ApiConnectionLevelDataSourceControllerCreateRequest
	*/
	ConnectionLevelDataSourceControllerCreate(ctx context.Context, connectionSelector string, dataSourceSelector string) ApiConnectionLevelDataSourceControllerCreateRequest

	// ConnectionLevelDataSourceControllerCreateExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerCreateExecute(r ApiConnectionLevelDataSourceControllerCreateRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourceControllerGet Get data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerGetRequest
	*/
	ConnectionLevelDataSourceControllerGet(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerGetRequest

	// ConnectionLevelDataSourceControllerGetExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerGetExecute(r ApiConnectionLevelDataSourceControllerGetRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourceControllerPatch Patch update data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerPatchRequest
	*/
	ConnectionLevelDataSourceControllerPatch(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerPatchRequest

	// ConnectionLevelDataSourceControllerPatchExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerPatchExecute(r ApiConnectionLevelDataSourceControllerPatchRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourceControllerPut Update data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerPutRequest
	*/
	ConnectionLevelDataSourceControllerPut(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerPutRequest

	// ConnectionLevelDataSourceControllerPutExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerPutExecute(r ApiConnectionLevelDataSourceControllerPutRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourceControllerReset Reset data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerResetRequest
	*/
	ConnectionLevelDataSourceControllerReset(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerResetRequest

	// ConnectionLevelDataSourceControllerResetExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerResetExecute(r ApiConnectionLevelDataSourceControllerResetRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourceControllerSetup Setup data source instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourceControllerSetupRequest
	*/
	ConnectionLevelDataSourceControllerSetup(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerSetupRequest

	// ConnectionLevelDataSourceControllerSetupExecute executes the request
	//  @return DataSourceInstanceDto
	ConnectionLevelDataSourceControllerSetupExecute(r ApiConnectionLevelDataSourceControllerSetupRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ConnectionLevelDataSourcesControllerGet List data source instances for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelDataSourcesControllerGetRequest
	*/
	ConnectionLevelDataSourcesControllerGet(ctx context.Context, connectionSelector string) ApiConnectionLevelDataSourcesControllerGetRequest

	// ConnectionLevelDataSourcesControllerGetExecute executes the request
	ConnectionLevelDataSourcesControllerGetExecute(r ApiConnectionLevelDataSourcesControllerGetRequest) (*http.Response, error)

	/*
	DataSourceByIdControllerApply Apply data source to integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerApplyRequest
	*/
	DataSourceByIdControllerApply(ctx context.Context, id string) ApiDataSourceByIdControllerApplyRequest

	// DataSourceByIdControllerApplyExecute executes the request
	//  @return []DataSourceDto
	DataSourceByIdControllerApplyExecute(r ApiDataSourceByIdControllerApplyRequest) ([]DataSourceDto, *http.Response, error)

	/*
	DataSourceByIdControllerArchive Archive data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerArchiveRequest
	*/
	DataSourceByIdControllerArchive(ctx context.Context, id string) ApiDataSourceByIdControllerArchiveRequest

	// DataSourceByIdControllerArchiveExecute executes the request
	DataSourceByIdControllerArchiveExecute(r ApiDataSourceByIdControllerArchiveRequest) (*http.Response, error)

	/*
	DataSourceByIdControllerClone Method for DataSourceByIdControllerClone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerCloneRequest
	*/
	DataSourceByIdControllerClone(ctx context.Context, id string) ApiDataSourceByIdControllerCloneRequest

	// DataSourceByIdControllerCloneExecute executes the request
	//  @return DataSourceDto
	DataSourceByIdControllerCloneExecute(r ApiDataSourceByIdControllerCloneRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourceByIdControllerExport Method for DataSourceByIdControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerExportRequest
	*/
	DataSourceByIdControllerExport(ctx context.Context, id string) ApiDataSourceByIdControllerExportRequest

	// DataSourceByIdControllerExportExecute executes the request
	//  @return DataSourceExportDto
	DataSourceByIdControllerExportExecute(r ApiDataSourceByIdControllerExportRequest) (*DataSourceExportDto, *http.Response, error)

	/*
	DataSourceByIdControllerGet Get data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerGetRequest
	*/
	DataSourceByIdControllerGet(ctx context.Context, id string) ApiDataSourceByIdControllerGetRequest

	// DataSourceByIdControllerGetExecute executes the request
	//  @return DataSourceDto
	DataSourceByIdControllerGetExecute(r ApiDataSourceByIdControllerGetRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourceByIdControllerPatch Patch data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerPatchRequest
	*/
	DataSourceByIdControllerPatch(ctx context.Context, id string) ApiDataSourceByIdControllerPatchRequest

	// DataSourceByIdControllerPatchExecute executes the request
	//  @return DataSourceDto
	DataSourceByIdControllerPatchExecute(r ApiDataSourceByIdControllerPatchRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourceByIdControllerPut Update data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerPutRequest
	*/
	DataSourceByIdControllerPut(ctx context.Context, id string) ApiDataSourceByIdControllerPutRequest

	// DataSourceByIdControllerPutExecute executes the request
	//  @return DataSourceDto
	DataSourceByIdControllerPutExecute(r ApiDataSourceByIdControllerPutRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourceByIdControllerReset Reset data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceByIdControllerResetRequest
	*/
	DataSourceByIdControllerReset(ctx context.Context, id string) ApiDataSourceByIdControllerResetRequest

	// DataSourceByIdControllerResetExecute executes the request
	//  @return DataSourceDto
	DataSourceByIdControllerResetExecute(r ApiDataSourceByIdControllerResetRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerArchive Archive data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerArchiveRequest
	*/
	DataSourceInstanceByIdControllerArchive(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerArchiveRequest

	// DataSourceInstanceByIdControllerArchiveExecute executes the request
	DataSourceInstanceByIdControllerArchiveExecute(r ApiDataSourceInstanceByIdControllerArchiveRequest) (*http.Response, error)

	/*
	DataSourceInstanceByIdControllerCreate Create data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerCreateRequest
	*/
	DataSourceInstanceByIdControllerCreate(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerCreateRequest

	// DataSourceInstanceByIdControllerCreateExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerCreateExecute(r ApiDataSourceInstanceByIdControllerCreateRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerGet Get data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerGetRequest
	*/
	DataSourceInstanceByIdControllerGet(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerGetRequest

	// DataSourceInstanceByIdControllerGetExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerGetExecute(r ApiDataSourceInstanceByIdControllerGetRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerPatch Patch data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerPatchRequest
	*/
	DataSourceInstanceByIdControllerPatch(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerPatchRequest

	// DataSourceInstanceByIdControllerPatchExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerPatchExecute(r ApiDataSourceInstanceByIdControllerPatchRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerPut Update data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerPutRequest
	*/
	DataSourceInstanceByIdControllerPut(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerPutRequest

	// DataSourceInstanceByIdControllerPutExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerPutExecute(r ApiDataSourceInstanceByIdControllerPutRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerReset Reset data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerResetRequest
	*/
	DataSourceInstanceByIdControllerReset(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerResetRequest

	// DataSourceInstanceByIdControllerResetExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerResetExecute(r ApiDataSourceInstanceByIdControllerResetRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstanceByIdControllerSetup Setup data source instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiDataSourceInstanceByIdControllerSetupRequest
	*/
	DataSourceInstanceByIdControllerSetup(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerSetupRequest

	// DataSourceInstanceByIdControllerSetupExecute executes the request
	//  @return DataSourceInstanceDto
	DataSourceInstanceByIdControllerSetupExecute(r ApiDataSourceInstanceByIdControllerSetupRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	DataSourceInstancesControllerList List data source instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSourceInstancesControllerListRequest
	*/
	DataSourceInstancesControllerList(ctx context.Context) ApiDataSourceInstancesControllerListRequest

	// DataSourceInstancesControllerListExecute executes the request
	//  @return DataSourceInstancesControllerList200Response
	DataSourceInstancesControllerListExecute(r ApiDataSourceInstancesControllerListRequest) (*DataSourceInstancesControllerList200Response, *http.Response, error)

	/*
	DataSourcesControllerCreate Create data source

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSourcesControllerCreateRequest
	*/
	DataSourcesControllerCreate(ctx context.Context) ApiDataSourcesControllerCreateRequest

	// DataSourcesControllerCreateExecute executes the request
	//  @return DataSourceDto
	DataSourcesControllerCreateExecute(r ApiDataSourcesControllerCreateRequest) (*DataSourceDto, *http.Response, error)

	/*
	DataSourcesControllerList List data sources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDataSourcesControllerListRequest
	*/
	DataSourcesControllerList(ctx context.Context) ApiDataSourcesControllerListRequest

	// DataSourcesControllerListExecute executes the request
	//  @return DataSourcesControllerList200Response
	DataSourcesControllerListExecute(r ApiDataSourcesControllerListRequest) (*DataSourcesControllerList200Response, *http.Response, error)

	/*
	IntegrationLevelDataSourceControllerArchive Archive data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourceControllerArchiveRequest
	*/
	IntegrationLevelDataSourceControllerArchive(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerArchiveRequest

	// IntegrationLevelDataSourceControllerArchiveExecute executes the request
	IntegrationLevelDataSourceControllerArchiveExecute(r ApiIntegrationLevelDataSourceControllerArchiveRequest) (*http.Response, error)

	/*
	IntegrationLevelDataSourceControllerGet Get data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourceControllerGetRequest
	*/
	IntegrationLevelDataSourceControllerGet(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerGetRequest

	// IntegrationLevelDataSourceControllerGetExecute executes the request
	//  @return DataSourceDto
	IntegrationLevelDataSourceControllerGetExecute(r ApiIntegrationLevelDataSourceControllerGetRequest) (*DataSourceDto, *http.Response, error)

	/*
	IntegrationLevelDataSourceControllerPatch Patch update data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourceControllerPatchRequest
	*/
	IntegrationLevelDataSourceControllerPatch(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerPatchRequest

	// IntegrationLevelDataSourceControllerPatchExecute executes the request
	//  @return DataSourceDto
	IntegrationLevelDataSourceControllerPatchExecute(r ApiIntegrationLevelDataSourceControllerPatchRequest) (*DataSourceDto, *http.Response, error)

	/*
	IntegrationLevelDataSourceControllerPut Update data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourceControllerPutRequest
	*/
	IntegrationLevelDataSourceControllerPut(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerPutRequest

	// IntegrationLevelDataSourceControllerPutExecute executes the request
	//  @return DataSourceDto
	IntegrationLevelDataSourceControllerPutExecute(r ApiIntegrationLevelDataSourceControllerPutRequest) (*DataSourceDto, *http.Response, error)

	/*
	IntegrationLevelDataSourceControllerReset Reset data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataSourceSelector Data Source ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourceControllerResetRequest
	*/
	IntegrationLevelDataSourceControllerReset(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerResetRequest

	// IntegrationLevelDataSourceControllerResetExecute executes the request
	//  @return DataSourceDto
	IntegrationLevelDataSourceControllerResetExecute(r ApiIntegrationLevelDataSourceControllerResetRequest) (*DataSourceDto, *http.Response, error)

	/*
	IntegrationLevelDataSourcesControllerCreate Create data source for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourcesControllerCreateRequest
	*/
	IntegrationLevelDataSourcesControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelDataSourcesControllerCreateRequest

	// IntegrationLevelDataSourcesControllerCreateExecute executes the request
	//  @return DataSourceDto
	IntegrationLevelDataSourcesControllerCreateExecute(r ApiIntegrationLevelDataSourcesControllerCreateRequest) (*DataSourceDto, *http.Response, error)

	/*
	IntegrationLevelDataSourcesControllerList List data sources for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelDataSourcesControllerListRequest
	*/
	IntegrationLevelDataSourcesControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelDataSourcesControllerListRequest

	// IntegrationLevelDataSourcesControllerListExecute executes the request
	//  @return DataSourcesControllerList200Response
	IntegrationLevelDataSourcesControllerListExecute(r ApiIntegrationLevelDataSourcesControllerListRequest) (*DataSourcesControllerList200Response, *http.Response, error)
}

// DataSourcesAPIService DataSourcesAPI service
type DataSourcesAPIService service

type ApiConnectionLevelDataSourceControllerArchiveRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerArchiveRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerArchiveRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerArchiveRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerArchiveRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerArchiveExecute(r)
}

/*
ConnectionLevelDataSourceControllerArchive Archive data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerArchiveRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerArchive(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerArchiveRequest {
	return ApiConnectionLevelDataSourceControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerArchiveExecute(r ApiConnectionLevelDataSourceControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerCreateRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	connectionSelector string
	dataSourceSelector string
	instanceKey *string
}

func (r ApiConnectionLevelDataSourceControllerCreateRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerCreateRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerCreateRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerCreateExecute(r)
}

/*
ConnectionLevelDataSourceControllerCreate Create data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @param dataSourceSelector Data Source ID or Key
 @return ApiConnectionLevelDataSourceControllerCreateRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerCreate(ctx context.Context, connectionSelector string, dataSourceSelector string) ApiConnectionLevelDataSourceControllerCreateRequest {
	return ApiConnectionLevelDataSourceControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
		dataSourceSelector: dataSourceSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerCreateExecute(r ApiConnectionLevelDataSourceControllerCreateRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerGetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerGetRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerGetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerGetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerGetRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerGetExecute(r)
}

/*
ConnectionLevelDataSourceControllerGet Get data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerGetRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerGet(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerGetRequest {
	return ApiConnectionLevelDataSourceControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerGetExecute(r ApiConnectionLevelDataSourceControllerGetRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerPatchRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerPatchRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiConnectionLevelDataSourceControllerPatchRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiConnectionLevelDataSourceControllerPatchRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerPatchRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerPatchRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerPatchRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerPatchRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerPatchExecute(r)
}

/*
ConnectionLevelDataSourceControllerPatch Patch update data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerPatchRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerPatch(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerPatchRequest {
	return ApiConnectionLevelDataSourceControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerPatchExecute(r ApiConnectionLevelDataSourceControllerPatchRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerPutRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerPutRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiConnectionLevelDataSourceControllerPutRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiConnectionLevelDataSourceControllerPutRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerPutRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerPutRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerPutRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerPutRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerPutExecute(r)
}

/*
ConnectionLevelDataSourceControllerPut Update data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerPutRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerPut(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerPutRequest {
	return ApiConnectionLevelDataSourceControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerPutExecute(r ApiConnectionLevelDataSourceControllerPutRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerResetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerResetRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerResetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerResetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerResetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerResetRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerResetExecute(r)
}

/*
ConnectionLevelDataSourceControllerReset Reset data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerResetRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerReset(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerResetRequest {
	return ApiConnectionLevelDataSourceControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerResetExecute(r ApiConnectionLevelDataSourceControllerResetRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourceControllerSetupRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelDataSourceControllerSetupRequest) InstanceKey(instanceKey string) ApiConnectionLevelDataSourceControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelDataSourceControllerSetupRequest) AutoCreate(autoCreate bool) ApiConnectionLevelDataSourceControllerSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelDataSourceControllerSetupRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourceControllerSetupExecute(r)
}

/*
ConnectionLevelDataSourceControllerSetup Setup data source instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourceControllerSetupRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerSetup(ctx context.Context, dataSourceSelector string, connectionSelector string) ApiConnectionLevelDataSourceControllerSetupRequest {
	return ApiConnectionLevelDataSourceControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ConnectionLevelDataSourceControllerSetupExecute(r ApiConnectionLevelDataSourceControllerSetupRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourceControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources/{dataSourceSelector}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelDataSourcesControllerGetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	connectionSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	dataSourceId *string
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) Limit(limit float32) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.limit = &limit
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) Cursor(cursor string) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) Search(search string) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.search = &search
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) ConnectorId(connectorId string) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) IncludeArchived(includeArchived bool) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) DataSourceId(dataSourceId string) ApiConnectionLevelDataSourcesControllerGetRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiConnectionLevelDataSourcesControllerGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelDataSourcesControllerGetExecute(r)
}

/*
ConnectionLevelDataSourcesControllerGet List data source instances for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelDataSourcesControllerGetRequest
*/
func (a *DataSourcesAPIService) ConnectionLevelDataSourcesControllerGet(ctx context.Context, connectionSelector string) ApiConnectionLevelDataSourcesControllerGetRequest {
	return ApiConnectionLevelDataSourcesControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) ConnectionLevelDataSourcesControllerGetExecute(r ApiConnectionLevelDataSourcesControllerGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ConnectionLevelDataSourcesControllerGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/data-sources"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerApplyRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerApplyRequest) Key(key string) ApiDataSourceByIdControllerApplyRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerApplyRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerApplyRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerApplyRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerApplyRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerApplyRequest) Execute() ([]DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerApplyExecute(r)
}

/*
DataSourceByIdControllerApply Apply data source to integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerApplyRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerApply(ctx context.Context, id string) ApiDataSourceByIdControllerApplyRequest {
	return ApiDataSourceByIdControllerApplyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerApplyExecute(r ApiDataSourceByIdControllerApplyRequest) ([]DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerApply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerArchiveRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerArchiveRequest) Key(key string) ApiDataSourceByIdControllerArchiveRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerArchiveRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerArchiveRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerArchiveRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerArchiveRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataSourceByIdControllerArchiveExecute(r)
}

/*
DataSourceByIdControllerArchive Archive data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerArchiveRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerArchive(ctx context.Context, id string) ApiDataSourceByIdControllerArchiveRequest {
	return ApiDataSourceByIdControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) DataSourceByIdControllerArchiveExecute(r ApiDataSourceByIdControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerCloneRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerCloneRequest) Key(key string) ApiDataSourceByIdControllerCloneRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerCloneRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerCloneRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerCloneRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerCloneRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerCloneRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerCloneExecute(r)
}

/*
DataSourceByIdControllerClone Method for DataSourceByIdControllerClone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerCloneRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerClone(ctx context.Context, id string) ApiDataSourceByIdControllerCloneRequest {
	return ApiDataSourceByIdControllerCloneRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerCloneExecute(r ApiDataSourceByIdControllerCloneRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerExportRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerExportRequest) Key(key string) ApiDataSourceByIdControllerExportRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerExportRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerExportRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerExportRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerExportRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerExportRequest) Execute() (*DataSourceExportDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerExportExecute(r)
}

/*
DataSourceByIdControllerExport Method for DataSourceByIdControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerExportRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerExport(ctx context.Context, id string) ApiDataSourceByIdControllerExportRequest {
	return ApiDataSourceByIdControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceExportDto
func (a *DataSourcesAPIService) DataSourceByIdControllerExportExecute(r ApiDataSourceByIdControllerExportRequest) (*DataSourceExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerGetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerGetRequest) Key(key string) ApiDataSourceByIdControllerGetRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerGetRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerGetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerGetRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerGetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerGetRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerGetExecute(r)
}

/*
DataSourceByIdControllerGet Get data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerGetRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerGet(ctx context.Context, id string) ApiDataSourceByIdControllerGetRequest {
	return ApiDataSourceByIdControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerGetExecute(r ApiDataSourceByIdControllerGetRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerPatchRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceDto *UpdateDataSourceDto
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerPatchRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiDataSourceByIdControllerPatchRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiDataSourceByIdControllerPatchRequest) Key(key string) ApiDataSourceByIdControllerPatchRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerPatchRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerPatchRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerPatchRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerPatchRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerPatchRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerPatchExecute(r)
}

/*
DataSourceByIdControllerPatch Patch data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerPatchRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerPatch(ctx context.Context, id string) ApiDataSourceByIdControllerPatchRequest {
	return ApiDataSourceByIdControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerPatchExecute(r ApiDataSourceByIdControllerPatchRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerPutRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceDto *UpdateDataSourceDto
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerPutRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiDataSourceByIdControllerPutRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiDataSourceByIdControllerPutRequest) Key(key string) ApiDataSourceByIdControllerPutRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerPutRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerPutRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerPutRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerPutRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerPutRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerPutExecute(r)
}

/*
DataSourceByIdControllerPut Update data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerPutRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerPut(ctx context.Context, id string) ApiDataSourceByIdControllerPutRequest {
	return ApiDataSourceByIdControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerPutExecute(r ApiDataSourceByIdControllerPutRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceByIdControllerResetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiDataSourceByIdControllerResetRequest) Key(key string) ApiDataSourceByIdControllerResetRequest {
	r.key = &key
	return r
}

func (r ApiDataSourceByIdControllerResetRequest) IntegrationId(integrationId string) ApiDataSourceByIdControllerResetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceByIdControllerResetRequest) IntegrationKey(integrationKey string) ApiDataSourceByIdControllerResetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceByIdControllerResetRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourceByIdControllerResetExecute(r)
}

/*
DataSourceByIdControllerReset Reset data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceByIdControllerResetRequest
*/
func (a *DataSourcesAPIService) DataSourceByIdControllerReset(ctx context.Context, id string) ApiDataSourceByIdControllerResetRequest {
	return ApiDataSourceByIdControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourceByIdControllerResetExecute(r ApiDataSourceByIdControllerResetRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceByIdControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerArchiveRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerArchiveRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerArchiveExecute(r)
}

/*
DataSourceInstanceByIdControllerArchive Archive data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerArchiveRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerArchive(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerArchiveRequest {
	return ApiDataSourceInstanceByIdControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerArchiveExecute(r ApiDataSourceInstanceByIdControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerCreateRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerCreateRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerCreateRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerCreateRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerCreateExecute(r)
}

/*
DataSourceInstanceByIdControllerCreate Create data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerCreateRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerCreate(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerCreateRequest {
	return ApiDataSourceInstanceByIdControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerCreateExecute(r ApiDataSourceInstanceByIdControllerCreateRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerGetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerGetRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerGetRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerGetRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerGetExecute(r)
}

/*
DataSourceInstanceByIdControllerGet Get data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerGetRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerGet(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerGetRequest {
	return ApiDataSourceInstanceByIdControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerGetExecute(r ApiDataSourceInstanceByIdControllerGetRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerPatchRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerPatchRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerPatchRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPatchRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerPatchExecute(r)
}

/*
DataSourceInstanceByIdControllerPatch Patch data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerPatchRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerPatch(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerPatchRequest {
	return ApiDataSourceInstanceByIdControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerPatchExecute(r ApiDataSourceInstanceByIdControllerPatchRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerPutRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiDataSourceInstanceByIdControllerPutRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerPutRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerPutRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerPutRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerPutRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerPutExecute(r)
}

/*
DataSourceInstanceByIdControllerPut Update data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerPutRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerPut(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerPutRequest {
	return ApiDataSourceInstanceByIdControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerPutExecute(r ApiDataSourceInstanceByIdControllerPutRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerResetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerResetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerResetRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerResetRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerResetRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerResetExecute(r)
}

/*
DataSourceInstanceByIdControllerReset Reset data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerResetRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerReset(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerResetRequest {
	return ApiDataSourceInstanceByIdControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerResetExecute(r ApiDataSourceInstanceByIdControllerResetRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstanceByIdControllerSetupRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) DataSourceKey(dataSourceKey string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) DataSourceId(dataSourceId string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) InstanceKey(instanceKey string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) AutoCreate(autoCreate bool) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) FlowKey(flowKey string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) FlowId(flowId string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) NodeKey(nodeKey string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiDataSourceInstanceByIdControllerSetupRequest) Udm(udm string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) IntegrationKey(integrationKey string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) IntegrationId(integrationId string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) ConnectionId(connectionId string) ApiDataSourceInstanceByIdControllerSetupRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstanceByIdControllerSetupRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.DataSourceInstanceByIdControllerSetupExecute(r)
}

/*
DataSourceInstanceByIdControllerSetup Setup data source instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiDataSourceInstanceByIdControllerSetupRequest
*/
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerSetup(ctx context.Context, id string) ApiDataSourceInstanceByIdControllerSetupRequest {
	return ApiDataSourceInstanceByIdControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) DataSourceInstanceByIdControllerSetupExecute(r ApiDataSourceInstanceByIdControllerSetupRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstanceByIdControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances/{id}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourceInstancesControllerListRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	userId *string
	connectionId *string
	integrationKey *string
	integrationId *string
	dataSourceId *string
	universalDataSourceId *string
	udm *string
	instanceKey *string
}

func (r ApiDataSourceInstancesControllerListRequest) Limit(limit float32) ApiDataSourceInstancesControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) Cursor(cursor string) ApiDataSourceInstancesControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) Search(search string) ApiDataSourceInstancesControllerListRequest {
	r.search = &search
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) ConnectorId(connectorId string) ApiDataSourceInstancesControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) IncludeArchived(includeArchived bool) ApiDataSourceInstancesControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) Id(id string) ApiDataSourceInstancesControllerListRequest {
	r.id = &id
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) UserId(userId string) ApiDataSourceInstancesControllerListRequest {
	r.userId = &userId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) ConnectionId(connectionId string) ApiDataSourceInstancesControllerListRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) IntegrationKey(integrationKey string) ApiDataSourceInstancesControllerListRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) IntegrationId(integrationId string) ApiDataSourceInstancesControllerListRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) DataSourceId(dataSourceId string) ApiDataSourceInstancesControllerListRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) UniversalDataSourceId(universalDataSourceId string) ApiDataSourceInstancesControllerListRequest {
	r.universalDataSourceId = &universalDataSourceId
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) Udm(udm string) ApiDataSourceInstancesControllerListRequest {
	r.udm = &udm
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) InstanceKey(instanceKey string) ApiDataSourceInstancesControllerListRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDataSourceInstancesControllerListRequest) Execute() (*DataSourceInstancesControllerList200Response, *http.Response, error) {
	return r.ApiService.DataSourceInstancesControllerListExecute(r)
}

/*
DataSourceInstancesControllerList List data source instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDataSourceInstancesControllerListRequest
*/
func (a *DataSourcesAPIService) DataSourceInstancesControllerList(ctx context.Context) ApiDataSourceInstancesControllerListRequest {
	return ApiDataSourceInstancesControllerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstancesControllerList200Response
func (a *DataSourcesAPIService) DataSourceInstancesControllerListExecute(r ApiDataSourceInstancesControllerListRequest) (*DataSourceInstancesControllerList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstancesControllerList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourceInstancesControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.universalDataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalDataSourceId", r.universalDataSourceId, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourcesControllerCreateRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	createDataSourceDto *CreateDataSourceDto
}

func (r ApiDataSourcesControllerCreateRequest) CreateDataSourceDto(createDataSourceDto CreateDataSourceDto) ApiDataSourcesControllerCreateRequest {
	r.createDataSourceDto = &createDataSourceDto
	return r
}

func (r ApiDataSourcesControllerCreateRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.DataSourcesControllerCreateExecute(r)
}

/*
DataSourcesControllerCreate Create data source

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDataSourcesControllerCreateRequest
*/
func (a *DataSourcesAPIService) DataSourcesControllerCreate(ctx context.Context) ApiDataSourcesControllerCreateRequest {
	return ApiDataSourcesControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) DataSourcesControllerCreateExecute(r ApiDataSourcesControllerCreateRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourcesControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("createDataSourceDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataSourcesControllerListRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalDataSourceId *string
	integrationId *string
}

func (r ApiDataSourcesControllerListRequest) Limit(limit float32) ApiDataSourcesControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiDataSourcesControllerListRequest) Cursor(cursor string) ApiDataSourcesControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiDataSourcesControllerListRequest) Search(search string) ApiDataSourcesControllerListRequest {
	r.search = &search
	return r
}

func (r ApiDataSourcesControllerListRequest) ConnectorId(connectorId string) ApiDataSourcesControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiDataSourcesControllerListRequest) IncludeArchived(includeArchived bool) ApiDataSourcesControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiDataSourcesControllerListRequest) UniversalDataSourceId(universalDataSourceId string) ApiDataSourcesControllerListRequest {
	r.universalDataSourceId = &universalDataSourceId
	return r
}

func (r ApiDataSourcesControllerListRequest) IntegrationId(integrationId string) ApiDataSourcesControllerListRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDataSourcesControllerListRequest) Execute() (*DataSourcesControllerList200Response, *http.Response, error) {
	return r.ApiService.DataSourcesControllerListExecute(r)
}

/*
DataSourcesControllerList List data sources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDataSourcesControllerListRequest
*/
func (a *DataSourcesAPIService) DataSourcesControllerList(ctx context.Context) ApiDataSourcesControllerListRequest {
	return ApiDataSourcesControllerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourcesControllerList200Response
func (a *DataSourcesAPIService) DataSourcesControllerListExecute(r ApiDataSourcesControllerListRequest) (*DataSourcesControllerList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourcesControllerList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.DataSourcesControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalDataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalDataSourceId", r.universalDataSourceId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourceControllerArchiveRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelDataSourceControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourceControllerArchiveExecute(r)
}

/*
IntegrationLevelDataSourceControllerArchive Archive data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourceControllerArchiveRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerArchive(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerArchiveRequest {
	return ApiIntegrationLevelDataSourceControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerArchiveExecute(r ApiIntegrationLevelDataSourceControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourceControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourceControllerGetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelDataSourceControllerGetRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourceControllerGetExecute(r)
}

/*
IntegrationLevelDataSourceControllerGet Get data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourceControllerGetRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerGet(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerGetRequest {
	return ApiIntegrationLevelDataSourceControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerGetExecute(r ApiIntegrationLevelDataSourceControllerGetRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourceControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourceControllerPatchRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	integrationSelector string
	updateDataSourceDto *UpdateDataSourceDto
}

func (r ApiIntegrationLevelDataSourceControllerPatchRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiIntegrationLevelDataSourceControllerPatchRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiIntegrationLevelDataSourceControllerPatchRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourceControllerPatchExecute(r)
}

/*
IntegrationLevelDataSourceControllerPatch Patch update data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourceControllerPatchRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerPatch(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerPatchRequest {
	return ApiIntegrationLevelDataSourceControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerPatchExecute(r ApiIntegrationLevelDataSourceControllerPatchRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourceControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourceControllerPutRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	integrationSelector string
	updateDataSourceDto *UpdateDataSourceDto
}

func (r ApiIntegrationLevelDataSourceControllerPutRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiIntegrationLevelDataSourceControllerPutRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiIntegrationLevelDataSourceControllerPutRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourceControllerPutExecute(r)
}

/*
IntegrationLevelDataSourceControllerPut Update data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourceControllerPutRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerPut(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerPutRequest {
	return ApiIntegrationLevelDataSourceControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerPutExecute(r ApiIntegrationLevelDataSourceControllerPutRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourceControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources/{dataSourceSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourceControllerResetRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelDataSourceControllerResetRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourceControllerResetExecute(r)
}

/*
IntegrationLevelDataSourceControllerReset Reset data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataSourceSelector Data Source ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourceControllerResetRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerReset(ctx context.Context, dataSourceSelector string, integrationSelector string) ApiIntegrationLevelDataSourceControllerResetRequest {
	return ApiIntegrationLevelDataSourceControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		dataSourceSelector: dataSourceSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) IntegrationLevelDataSourceControllerResetExecute(r ApiIntegrationLevelDataSourceControllerResetRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourceControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources/{dataSourceSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"dataSourceSelector"+"}", url.PathEscape(parameterValueToString(r.dataSourceSelector, "dataSourceSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourcesControllerCreateRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	integrationSelector string
	createIntegrationLevelDataSourceDto *CreateIntegrationLevelDataSourceDto
}

func (r ApiIntegrationLevelDataSourcesControllerCreateRequest) CreateIntegrationLevelDataSourceDto(createIntegrationLevelDataSourceDto CreateIntegrationLevelDataSourceDto) ApiIntegrationLevelDataSourcesControllerCreateRequest {
	r.createIntegrationLevelDataSourceDto = &createIntegrationLevelDataSourceDto
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerCreateRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourcesControllerCreateExecute(r)
}

/*
IntegrationLevelDataSourcesControllerCreate Create data source for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourcesControllerCreateRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourcesControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelDataSourcesControllerCreateRequest {
	return ApiIntegrationLevelDataSourcesControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) IntegrationLevelDataSourcesControllerCreateExecute(r ApiIntegrationLevelDataSourcesControllerCreateRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourcesControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationLevelDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationLevelDataSourceDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationLevelDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelDataSourcesControllerListRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	integrationSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalDataSourceId *string
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) Limit(limit float32) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) Cursor(cursor string) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) Search(search string) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.search = &search
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) ConnectorId(connectorId string) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) IncludeArchived(includeArchived bool) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) UniversalDataSourceId(universalDataSourceId string) ApiIntegrationLevelDataSourcesControllerListRequest {
	r.universalDataSourceId = &universalDataSourceId
	return r
}

func (r ApiIntegrationLevelDataSourcesControllerListRequest) Execute() (*DataSourcesControllerList200Response, *http.Response, error) {
	return r.ApiService.IntegrationLevelDataSourcesControllerListExecute(r)
}

/*
IntegrationLevelDataSourcesControllerList List data sources for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelDataSourcesControllerListRequest
*/
func (a *DataSourcesAPIService) IntegrationLevelDataSourcesControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelDataSourcesControllerListRequest {
	return ApiIntegrationLevelDataSourcesControllerListRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return DataSourcesControllerList200Response
func (a *DataSourcesAPIService) IntegrationLevelDataSourcesControllerListExecute(r ApiIntegrationLevelDataSourcesControllerListRequest) (*DataSourcesControllerList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourcesControllerList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.IntegrationLevelDataSourcesControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/data-sources"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalDataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalDataSourceId", r.universalDataSourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
