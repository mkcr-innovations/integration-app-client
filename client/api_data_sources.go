/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type DataSourcesAPI interface {

	/*
	ApplyDataSource Method for ApplyDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to apply
	@return ApiApplyDataSourceRequest
	*/
	ApplyDataSource(ctx context.Context, id string) ApiApplyDataSourceRequest

	// ApplyDataSourceExecute executes the request
	//  @return []DataSourceDto
	ApplyDataSourceExecute(r ApiApplyDataSourceRequest) ([]DataSourceDto, *http.Response, error)

	/*
	ApplyDataSources Method for ApplyDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplyDataSourcesRequest
	*/
	ApplyDataSources(ctx context.Context) ApiApplyDataSourcesRequest

	// ApplyDataSourcesExecute executes the request
	//  @return []DataSourceDto
	ApplyDataSourcesExecute(r ApiApplyDataSourcesRequest) ([]DataSourceDto, *http.Response, error)

	/*
	ArchiveDataSource Method for ArchiveDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to retrive
	@return ApiArchiveDataSourceRequest
	*/
	ArchiveDataSource(ctx context.Context, id string) ApiArchiveDataSourceRequest

	// ArchiveDataSourceExecute executes the request
	ArchiveDataSourceExecute(r ApiArchiveDataSourceRequest) (*http.Response, error)

	/*
	ArchiveDataSourceInstance Method for ArchiveDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveDataSourceInstanceRequest
	*/
	ArchiveDataSourceInstance(ctx context.Context) ApiArchiveDataSourceInstanceRequest

	// ArchiveDataSourceInstanceExecute executes the request
	ArchiveDataSourceInstanceExecute(r ApiArchiveDataSourceInstanceRequest) (*http.Response, error)

	/*
	ArchiveDataSources Method for ArchiveDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveDataSourcesRequest
	*/
	ArchiveDataSources(ctx context.Context) ApiArchiveDataSourcesRequest

	// ArchiveDataSourcesExecute executes the request
	ArchiveDataSourcesExecute(r ApiArchiveDataSourcesRequest) (*http.Response, error)

	/*
	CreateDataSource Method for CreateDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDataSourceRequest
	*/
	CreateDataSource(ctx context.Context) ApiCreateDataSourceRequest

	// CreateDataSourceExecute executes the request
	//  @return DataSourceDto
	CreateDataSourceExecute(r ApiCreateDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	CreateDataSourceInstance Method for CreateDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDataSourceInstanceRequest
	*/
	CreateDataSourceInstance(ctx context.Context) ApiCreateDataSourceInstanceRequest

	// CreateDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	CreateDataSourceInstanceExecute(r ApiCreateDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	GetDataSource Method for GetDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to retrive
	@return ApiGetDataSourceRequest
	*/
	GetDataSource(ctx context.Context, id string) ApiGetDataSourceRequest

	// GetDataSourceExecute executes the request
	//  @return DataSourceDto
	GetDataSourceExecute(r ApiGetDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	GetDataSourceEvent Method for GetDataSourceEvent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetDataSourceEventRequest
	*/
	GetDataSourceEvent(ctx context.Context, id string) ApiGetDataSourceEventRequest

	// GetDataSourceEventExecute executes the request
	//  @return DataSourceEventDto
	GetDataSourceEventExecute(r ApiGetDataSourceEventRequest) (*DataSourceEventDto, *http.Response, error)

	/*
	GetDataSourceInstance Method for GetDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataSourceInstanceRequest
	*/
	GetDataSourceInstance(ctx context.Context) ApiGetDataSourceInstanceRequest

	// GetDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	GetDataSourceInstanceExecute(r ApiGetDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	GetDataSourceSync Method for GetDataSourceSync

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetDataSourceSyncRequest
	*/
	GetDataSourceSync(ctx context.Context, id string) ApiGetDataSourceSyncRequest

	// GetDataSourceSyncExecute executes the request
	//  @return DataSourceSyncDto
	GetDataSourceSyncExecute(r ApiGetDataSourceSyncRequest) (*DataSourceSyncDto, *http.Response, error)

	/*
	GetDataSourceSyncLogs Method for GetDataSourceSyncLogs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetDataSourceSyncLogsRequest
	*/
	GetDataSourceSyncLogs(ctx context.Context, id string) ApiGetDataSourceSyncLogsRequest

	// GetDataSourceSyncLogsExecute executes the request
	//  @return map[string]interface{}
	GetDataSourceSyncLogsExecute(r ApiGetDataSourceSyncLogsRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListDataSource Method for ListDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataSourceRequest
	*/
	ListDataSource(ctx context.Context) ApiListDataSourceRequest

	// ListDataSourceExecute executes the request
	//  @return DataSourceDto
	ListDataSourceExecute(r ApiListDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	ListDataSourceEvents Method for ListDataSourceEvents

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataSourceEventsRequest
	*/
	ListDataSourceEvents(ctx context.Context) ApiListDataSourceEventsRequest

	// ListDataSourceEventsExecute executes the request
	//  @return ListDataSourceEvents200Response
	ListDataSourceEventsExecute(r ApiListDataSourceEventsRequest) (*ListDataSourceEvents200Response, *http.Response, error)

	/*
	ListDataSourceInstances Method for ListDataSourceInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataSourceInstancesRequest
	*/
	ListDataSourceInstances(ctx context.Context) ApiListDataSourceInstancesRequest

	// ListDataSourceInstancesExecute executes the request
	//  @return ListDataSourceInstances200Response
	ListDataSourceInstancesExecute(r ApiListDataSourceInstancesRequest) (*ListDataSourceInstances200Response, *http.Response, error)

	/*
	ListDataSourceSyncs Method for ListDataSourceSyncs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataSourceSyncsRequest
	*/
	ListDataSourceSyncs(ctx context.Context) ApiListDataSourceSyncsRequest

	// ListDataSourceSyncsExecute executes the request
	//  @return ListDataSourceSyncs200Response
	ListDataSourceSyncsExecute(r ApiListDataSourceSyncsRequest) (*ListDataSourceSyncs200Response, *http.Response, error)

	/*
	ListDataSources Method for ListDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataSourcesRequest
	*/
	ListDataSources(ctx context.Context) ApiListDataSourcesRequest

	// ListDataSourcesExecute executes the request
	//  @return ListDataSources200Response
	ListDataSourcesExecute(r ApiListDataSourcesRequest) (*ListDataSources200Response, *http.Response, error)

	/*
	PatchDataSource Method for PatchDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to retrive
	@return ApiPatchDataSourceRequest
	*/
	PatchDataSource(ctx context.Context, id string) ApiPatchDataSourceRequest

	// PatchDataSourceExecute executes the request
	//  @return DataSourceDto
	PatchDataSourceExecute(r ApiPatchDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	PatchDataSourceInstance Method for PatchDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchDataSourceInstanceRequest
	*/
	PatchDataSourceInstance(ctx context.Context) ApiPatchDataSourceInstanceRequest

	// PatchDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	PatchDataSourceInstanceExecute(r ApiPatchDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	PatchDataSources Method for PatchDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchDataSourcesRequest
	*/
	PatchDataSources(ctx context.Context) ApiPatchDataSourcesRequest

	// PatchDataSourcesExecute executes the request
	//  @return DataSourceDto
	PatchDataSourcesExecute(r ApiPatchDataSourcesRequest) (*DataSourceDto, *http.Response, error)

	/*
	PutDataSource Method for PutDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to retrive
	@return ApiPutDataSourceRequest
	*/
	PutDataSource(ctx context.Context, id string) ApiPutDataSourceRequest

	// PutDataSourceExecute executes the request
	//  @return DataSourceDto
	PutDataSourceExecute(r ApiPutDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	PutDataSourceInstance Method for PutDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutDataSourceInstanceRequest
	*/
	PutDataSourceInstance(ctx context.Context) ApiPutDataSourceInstanceRequest

	// PutDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	PutDataSourceInstanceExecute(r ApiPutDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	PutDataSources Method for PutDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutDataSourcesRequest
	*/
	PutDataSources(ctx context.Context) ApiPutDataSourcesRequest

	// PutDataSourcesExecute executes the request
	//  @return DataSourceDto
	PutDataSourcesExecute(r ApiPutDataSourcesRequest) (*DataSourceDto, *http.Response, error)

	/*
	ResetDataSource Method for ResetDataSource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the data-source to reset
	@return ApiResetDataSourceRequest
	*/
	ResetDataSource(ctx context.Context, id string) ApiResetDataSourceRequest

	// ResetDataSourceExecute executes the request
	//  @return DataSourceDto
	ResetDataSourceExecute(r ApiResetDataSourceRequest) (*DataSourceDto, *http.Response, error)

	/*
	ResetDataSourceInstance Method for ResetDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetDataSourceInstanceRequest
	*/
	ResetDataSourceInstance(ctx context.Context) ApiResetDataSourceInstanceRequest

	// ResetDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	ResetDataSourceInstanceExecute(r ApiResetDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)

	/*
	ResetDataSources Method for ResetDataSources

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetDataSourcesRequest
	*/
	ResetDataSources(ctx context.Context) ApiResetDataSourcesRequest

	// ResetDataSourcesExecute executes the request
	//  @return DataSourceDto
	ResetDataSourcesExecute(r ApiResetDataSourcesRequest) (*DataSourceDto, *http.Response, error)

	/*
	SetupDataSourceInstance Method for SetupDataSourceInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetupDataSourceInstanceRequest
	*/
	SetupDataSourceInstance(ctx context.Context) ApiSetupDataSourceInstanceRequest

	// SetupDataSourceInstanceExecute executes the request
	//  @return DataSourceInstanceDto
	SetupDataSourceInstanceExecute(r ApiSetupDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error)
}

// DataSourcesAPIService DataSourcesAPI service
type DataSourcesAPIService service

type ApiApplyDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiApplyDataSourceRequest) Id2(id2 string) ApiApplyDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiApplyDataSourceRequest) Key(key string) ApiApplyDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiApplyDataSourceRequest) IntegrationId(integrationId string) ApiApplyDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyDataSourceRequest) IntegrationKey(integrationKey string) ApiApplyDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyDataSourceRequest) Execute() ([]DataSourceDto, *http.Response, error) {
	return r.ApiService.ApplyDataSourceExecute(r)
}

/*
ApplyDataSource Method for ApplyDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to apply
 @return ApiApplyDataSourceRequest
*/
func (a *DataSourcesAPIService) ApplyDataSource(ctx context.Context, id string) ApiApplyDataSourceRequest {
	return ApiApplyDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []DataSourceDto
func (a *DataSourcesAPIService) ApplyDataSourceExecute(r ApiApplyDataSourceRequest) ([]DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ApplyDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiApplyDataSourcesRequest) Id(id string) ApiApplyDataSourcesRequest {
	r.id = &id
	return r
}

func (r ApiApplyDataSourcesRequest) Key(key string) ApiApplyDataSourcesRequest {
	r.key = &key
	return r
}

func (r ApiApplyDataSourcesRequest) IntegrationId(integrationId string) ApiApplyDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyDataSourcesRequest) IntegrationKey(integrationKey string) ApiApplyDataSourcesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyDataSourcesRequest) Execute() ([]DataSourceDto, *http.Response, error) {
	return r.ApiService.ApplyDataSourcesExecute(r)
}

/*
ApplyDataSources Method for ApplyDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyDataSourcesRequest
*/
func (a *DataSourcesAPIService) ApplyDataSources(ctx context.Context) ApiApplyDataSourcesRequest {
	return ApiApplyDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DataSourceDto
func (a *DataSourcesAPIService) ApplyDataSourcesExecute(r ApiApplyDataSourcesRequest) ([]DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ApplyDataSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiArchiveDataSourceRequest) Id2(id2 string) ApiArchiveDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiArchiveDataSourceRequest) Key(key string) ApiArchiveDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiArchiveDataSourceRequest) IntegrationId(integrationId string) ApiArchiveDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveDataSourceRequest) IntegrationKey(integrationKey string) ApiArchiveDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveDataSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveDataSourceExecute(r)
}

/*
ArchiveDataSource Method for ArchiveDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to retrive
 @return ApiArchiveDataSourceRequest
*/
func (a *DataSourcesAPIService) ArchiveDataSource(ctx context.Context, id string) ApiArchiveDataSourceRequest {
	return ApiArchiveDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) ArchiveDataSourceExecute(r ApiArchiveDataSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ArchiveDataSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiArchiveDataSourceInstanceRequest) Id(id string) ApiArchiveDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiArchiveDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiArchiveDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiArchiveDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiArchiveDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) FlowKey(flowKey string) ApiArchiveDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) FlowId(flowId string) ApiArchiveDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) NodeKey(nodeKey string) ApiArchiveDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiArchiveDataSourceInstanceRequest) Udm(udm string) ApiArchiveDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiArchiveDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) IntegrationId(integrationId string) ApiArchiveDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) ConnectionId(connectionId string) ApiArchiveDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiArchiveDataSourceInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveDataSourceInstanceExecute(r)
}

/*
ArchiveDataSourceInstance Method for ArchiveDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) ArchiveDataSourceInstance(ctx context.Context) ApiArchiveDataSourceInstanceRequest {
	return ApiArchiveDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) ArchiveDataSourceInstanceExecute(r ApiArchiveDataSourceInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ArchiveDataSourceInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiArchiveDataSourcesRequest) Id(id string) ApiArchiveDataSourcesRequest {
	r.id = &id
	return r
}

func (r ApiArchiveDataSourcesRequest) Key(key string) ApiArchiveDataSourcesRequest {
	r.key = &key
	return r
}

func (r ApiArchiveDataSourcesRequest) IntegrationId(integrationId string) ApiArchiveDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveDataSourcesRequest) IntegrationKey(integrationKey string) ApiArchiveDataSourcesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveDataSourcesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveDataSourcesExecute(r)
}

/*
ArchiveDataSources Method for ArchiveDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveDataSourcesRequest
*/
func (a *DataSourcesAPIService) ArchiveDataSources(ctx context.Context) ApiArchiveDataSourcesRequest {
	return ApiArchiveDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataSourcesAPIService) ArchiveDataSourcesExecute(r ApiArchiveDataSourcesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ArchiveDataSources")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	createDataSourceDto *CreateDataSourceDto
}

func (r ApiCreateDataSourceRequest) CreateDataSourceDto(createDataSourceDto CreateDataSourceDto) ApiCreateDataSourceRequest {
	r.createDataSourceDto = &createDataSourceDto
	return r
}

func (r ApiCreateDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.CreateDataSourceExecute(r)
}

/*
CreateDataSource Method for CreateDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataSourceRequest
*/
func (a *DataSourcesAPIService) CreateDataSource(ctx context.Context) ApiCreateDataSourceRequest {
	return ApiCreateDataSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) CreateDataSourceExecute(r ApiCreateDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.CreateDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("createDataSourceDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiCreateDataSourceInstanceRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiCreateDataSourceInstanceRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiCreateDataSourceInstanceRequest) Id(id string) ApiCreateDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiCreateDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiCreateDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiCreateDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiCreateDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiCreateDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiCreateDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiCreateDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiCreateDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiCreateDataSourceInstanceRequest) FlowKey(flowKey string) ApiCreateDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiCreateDataSourceInstanceRequest) FlowId(flowId string) ApiCreateDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiCreateDataSourceInstanceRequest) NodeKey(nodeKey string) ApiCreateDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiCreateDataSourceInstanceRequest) Udm(udm string) ApiCreateDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiCreateDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiCreateDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiCreateDataSourceInstanceRequest) IntegrationId(integrationId string) ApiCreateDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiCreateDataSourceInstanceRequest) ConnectionId(connectionId string) ApiCreateDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiCreateDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.CreateDataSourceInstanceExecute(r)
}

/*
CreateDataSourceInstance Method for CreateDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) CreateDataSourceInstance(ctx context.Context) ApiCreateDataSourceInstanceRequest {
	return ApiCreateDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) CreateDataSourceInstanceExecute(r ApiCreateDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.CreateDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiGetDataSourceRequest) Id2(id2 string) ApiGetDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiGetDataSourceRequest) Key(key string) ApiGetDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiGetDataSourceRequest) IntegrationId(integrationId string) ApiGetDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetDataSourceRequest) IntegrationKey(integrationKey string) ApiGetDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.GetDataSourceExecute(r)
}

/*
GetDataSource Method for GetDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to retrive
 @return ApiGetDataSourceRequest
*/
func (a *DataSourcesAPIService) GetDataSource(ctx context.Context, id string) ApiGetDataSourceRequest {
	return ApiGetDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) GetDataSourceExecute(r ApiGetDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.GetDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataSourceEventRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
}

func (r ApiGetDataSourceEventRequest) Execute() (*DataSourceEventDto, *http.Response, error) {
	return r.ApiService.GetDataSourceEventExecute(r)
}

/*
GetDataSourceEvent Method for GetDataSourceEvent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetDataSourceEventRequest
*/
func (a *DataSourcesAPIService) GetDataSourceEvent(ctx context.Context, id string) ApiGetDataSourceEventRequest {
	return ApiGetDataSourceEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceEventDto
func (a *DataSourcesAPIService) GetDataSourceEventExecute(r ApiGetDataSourceEventRequest) (*DataSourceEventDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceEventDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.GetDataSourceEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-events/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiGetDataSourceInstanceRequest) Id(id string) ApiGetDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiGetDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiGetDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiGetDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiGetDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiGetDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiGetDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetDataSourceInstanceRequest) FlowKey(flowKey string) ApiGetDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiGetDataSourceInstanceRequest) FlowId(flowId string) ApiGetDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiGetDataSourceInstanceRequest) NodeKey(nodeKey string) ApiGetDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiGetDataSourceInstanceRequest) Udm(udm string) ApiGetDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiGetDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiGetDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetDataSourceInstanceRequest) IntegrationId(integrationId string) ApiGetDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetDataSourceInstanceRequest) ConnectionId(connectionId string) ApiGetDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.GetDataSourceInstanceExecute(r)
}

/*
GetDataSourceInstance Method for GetDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) GetDataSourceInstance(ctx context.Context) ApiGetDataSourceInstanceRequest {
	return ApiGetDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) GetDataSourceInstanceExecute(r ApiGetDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.GetDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataSourceSyncRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
}

func (r ApiGetDataSourceSyncRequest) Execute() (*DataSourceSyncDto, *http.Response, error) {
	return r.ApiService.GetDataSourceSyncExecute(r)
}

/*
GetDataSourceSync Method for GetDataSourceSync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetDataSourceSyncRequest
*/
func (a *DataSourcesAPIService) GetDataSourceSync(ctx context.Context, id string) ApiGetDataSourceSyncRequest {
	return ApiGetDataSourceSyncRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceSyncDto
func (a *DataSourcesAPIService) GetDataSourceSyncExecute(r ApiGetDataSourceSyncRequest) (*DataSourceSyncDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceSyncDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.GetDataSourceSync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-syncs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataSourceSyncLogsRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
}

func (r ApiGetDataSourceSyncLogsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDataSourceSyncLogsExecute(r)
}

/*
GetDataSourceSyncLogs Method for GetDataSourceSyncLogs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetDataSourceSyncLogsRequest
*/
func (a *DataSourcesAPIService) GetDataSourceSyncLogs(ctx context.Context, id string) ApiGetDataSourceSyncLogsRequest {
	return ApiGetDataSourceSyncLogsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DataSourcesAPIService) GetDataSourceSyncLogsExecute(r ApiGetDataSourceSyncLogsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.GetDataSourceSyncLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-syncs/{id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiListDataSourceRequest) Id(id string) ApiListDataSourceRequest {
	r.id = &id
	return r
}

func (r ApiListDataSourceRequest) Key(key string) ApiListDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiListDataSourceRequest) IntegrationId(integrationId string) ApiListDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataSourceRequest) IntegrationKey(integrationKey string) ApiListDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.ListDataSourceExecute(r)
}

/*
ListDataSource Method for ListDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataSourceRequest
*/
func (a *DataSourcesAPIService) ListDataSource(ctx context.Context) ApiListDataSourceRequest {
	return ApiListDataSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) ListDataSourceExecute(r ApiListDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ListDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataSourceEventsRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	userId *string
	dataSourceId *string
	connectionId *string
	integrationId *string
	dataSourceInstanceId *string
	startedAfter *string
}

func (r ApiListDataSourceEventsRequest) Id(id string) ApiListDataSourceEventsRequest {
	r.id = &id
	return r
}

func (r ApiListDataSourceEventsRequest) UserId(userId string) ApiListDataSourceEventsRequest {
	r.userId = &userId
	return r
}

func (r ApiListDataSourceEventsRequest) DataSourceId(dataSourceId string) ApiListDataSourceEventsRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiListDataSourceEventsRequest) ConnectionId(connectionId string) ApiListDataSourceEventsRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListDataSourceEventsRequest) IntegrationId(integrationId string) ApiListDataSourceEventsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataSourceEventsRequest) DataSourceInstanceId(dataSourceInstanceId string) ApiListDataSourceEventsRequest {
	r.dataSourceInstanceId = &dataSourceInstanceId
	return r
}

func (r ApiListDataSourceEventsRequest) StartedAfter(startedAfter string) ApiListDataSourceEventsRequest {
	r.startedAfter = &startedAfter
	return r
}

func (r ApiListDataSourceEventsRequest) Execute() (*ListDataSourceEvents200Response, *http.Response, error) {
	return r.ApiService.ListDataSourceEventsExecute(r)
}

/*
ListDataSourceEvents Method for ListDataSourceEvents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataSourceEventsRequest
*/
func (a *DataSourcesAPIService) ListDataSourceEvents(ctx context.Context) ApiListDataSourceEventsRequest {
	return ApiListDataSourceEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataSourceEvents200Response
func (a *DataSourcesAPIService) ListDataSourceEventsExecute(r ApiListDataSourceEventsRequest) (*ListDataSourceEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataSourceEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ListDataSourceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.dataSourceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceInstanceId", r.dataSourceInstanceId, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataSourceInstancesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	userId *string
	connectionId *string
	integrationKey *string
	integrationId *string
	dataSourceId *string
	universalDataSourceId *string
	udm *string
	instanceKey *string
}

func (r ApiListDataSourceInstancesRequest) Id(id string) ApiListDataSourceInstancesRequest {
	r.id = &id
	return r
}

func (r ApiListDataSourceInstancesRequest) UserId(userId string) ApiListDataSourceInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiListDataSourceInstancesRequest) ConnectionId(connectionId string) ApiListDataSourceInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListDataSourceInstancesRequest) IntegrationKey(integrationKey string) ApiListDataSourceInstancesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListDataSourceInstancesRequest) IntegrationId(integrationId string) ApiListDataSourceInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataSourceInstancesRequest) DataSourceId(dataSourceId string) ApiListDataSourceInstancesRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiListDataSourceInstancesRequest) UniversalDataSourceId(universalDataSourceId string) ApiListDataSourceInstancesRequest {
	r.universalDataSourceId = &universalDataSourceId
	return r
}

func (r ApiListDataSourceInstancesRequest) Udm(udm string) ApiListDataSourceInstancesRequest {
	r.udm = &udm
	return r
}

func (r ApiListDataSourceInstancesRequest) InstanceKey(instanceKey string) ApiListDataSourceInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListDataSourceInstancesRequest) Execute() (*ListDataSourceInstances200Response, *http.Response, error) {
	return r.ApiService.ListDataSourceInstancesExecute(r)
}

/*
ListDataSourceInstances Method for ListDataSourceInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataSourceInstancesRequest
*/
func (a *DataSourcesAPIService) ListDataSourceInstances(ctx context.Context) ApiListDataSourceInstancesRequest {
	return ApiListDataSourceInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataSourceInstances200Response
func (a *DataSourcesAPIService) ListDataSourceInstancesExecute(r ApiListDataSourceInstancesRequest) (*ListDataSourceInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataSourceInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ListDataSourceInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.universalDataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalDataSourceId", r.universalDataSourceId, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataSourceSyncsRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	dataSourceId *string
	dataSourceInstanceId *string
	integrationId *string
	connectionId *string
	userId *string
	status *string
	startedAfter *string
}

func (r ApiListDataSourceSyncsRequest) DataSourceId(dataSourceId string) ApiListDataSourceSyncsRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiListDataSourceSyncsRequest) DataSourceInstanceId(dataSourceInstanceId string) ApiListDataSourceSyncsRequest {
	r.dataSourceInstanceId = &dataSourceInstanceId
	return r
}

func (r ApiListDataSourceSyncsRequest) IntegrationId(integrationId string) ApiListDataSourceSyncsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataSourceSyncsRequest) ConnectionId(connectionId string) ApiListDataSourceSyncsRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListDataSourceSyncsRequest) UserId(userId string) ApiListDataSourceSyncsRequest {
	r.userId = &userId
	return r
}

func (r ApiListDataSourceSyncsRequest) Status(status string) ApiListDataSourceSyncsRequest {
	r.status = &status
	return r
}

func (r ApiListDataSourceSyncsRequest) StartedAfter(startedAfter string) ApiListDataSourceSyncsRequest {
	r.startedAfter = &startedAfter
	return r
}

func (r ApiListDataSourceSyncsRequest) Execute() (*ListDataSourceSyncs200Response, *http.Response, error) {
	return r.ApiService.ListDataSourceSyncsExecute(r)
}

/*
ListDataSourceSyncs Method for ListDataSourceSyncs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataSourceSyncsRequest
*/
func (a *DataSourcesAPIService) ListDataSourceSyncs(ctx context.Context) ApiListDataSourceSyncsRequest {
	return ApiListDataSourceSyncsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataSourceSyncs200Response
func (a *DataSourcesAPIService) ListDataSourceSyncsExecute(r ApiListDataSourceSyncsRequest) (*ListDataSourceSyncs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataSourceSyncs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ListDataSourceSyncs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-syncs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.dataSourceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceInstanceId", r.dataSourceInstanceId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	integrationId *string
	universalDataSourceId *string
}

func (r ApiListDataSourcesRequest) IntegrationId(integrationId string) ApiListDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataSourcesRequest) UniversalDataSourceId(universalDataSourceId string) ApiListDataSourcesRequest {
	r.universalDataSourceId = &universalDataSourceId
	return r
}

func (r ApiListDataSourcesRequest) Execute() (*ListDataSources200Response, *http.Response, error) {
	return r.ApiService.ListDataSourcesExecute(r)
}

/*
ListDataSources Method for ListDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataSourcesRequest
*/
func (a *DataSourcesAPIService) ListDataSources(ctx context.Context) ApiListDataSourcesRequest {
	return ApiListDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataSources200Response
func (a *DataSourcesAPIService) ListDataSourcesExecute(r ApiListDataSourcesRequest) (*ListDataSources200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataSources200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ListDataSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.universalDataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalDataSourceId", r.universalDataSourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceDto *UpdateDataSourceDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPatchDataSourceRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiPatchDataSourceRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiPatchDataSourceRequest) Id2(id2 string) ApiPatchDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiPatchDataSourceRequest) Key(key string) ApiPatchDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiPatchDataSourceRequest) IntegrationId(integrationId string) ApiPatchDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchDataSourceRequest) IntegrationKey(integrationKey string) ApiPatchDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.PatchDataSourceExecute(r)
}

/*
PatchDataSource Method for PatchDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to retrive
 @return ApiPatchDataSourceRequest
*/
func (a *DataSourcesAPIService) PatchDataSource(ctx context.Context, id string) ApiPatchDataSourceRequest {
	return ApiPatchDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) PatchDataSourceExecute(r ApiPatchDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PatchDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPatchDataSourceInstanceRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiPatchDataSourceInstanceRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiPatchDataSourceInstanceRequest) Id(id string) ApiPatchDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPatchDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiPatchDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiPatchDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiPatchDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiPatchDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiPatchDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiPatchDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchDataSourceInstanceRequest) FlowKey(flowKey string) ApiPatchDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPatchDataSourceInstanceRequest) FlowId(flowId string) ApiPatchDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPatchDataSourceInstanceRequest) NodeKey(nodeKey string) ApiPatchDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiPatchDataSourceInstanceRequest) Udm(udm string) ApiPatchDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiPatchDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiPatchDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchDataSourceInstanceRequest) IntegrationId(integrationId string) ApiPatchDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchDataSourceInstanceRequest) ConnectionId(connectionId string) ApiPatchDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPatchDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.PatchDataSourceInstanceExecute(r)
}

/*
PatchDataSourceInstance Method for PatchDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) PatchDataSourceInstance(ctx context.Context) ApiPatchDataSourceInstanceRequest {
	return ApiPatchDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) PatchDataSourceInstanceExecute(r ApiPatchDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PatchDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	updateDataSourceDto *UpdateDataSourceDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPatchDataSourcesRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiPatchDataSourcesRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiPatchDataSourcesRequest) Id(id string) ApiPatchDataSourcesRequest {
	r.id = &id
	return r
}

func (r ApiPatchDataSourcesRequest) Key(key string) ApiPatchDataSourcesRequest {
	r.key = &key
	return r
}

func (r ApiPatchDataSourcesRequest) IntegrationId(integrationId string) ApiPatchDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchDataSourcesRequest) IntegrationKey(integrationKey string) ApiPatchDataSourcesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchDataSourcesRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.PatchDataSourcesExecute(r)
}

/*
PatchDataSources Method for PatchDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchDataSourcesRequest
*/
func (a *DataSourcesAPIService) PatchDataSources(ctx context.Context) ApiPatchDataSourcesRequest {
	return ApiPatchDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) PatchDataSourcesExecute(r ApiPatchDataSourcesRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PatchDataSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	updateDataSourceDto *UpdateDataSourceDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPutDataSourceRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiPutDataSourceRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiPutDataSourceRequest) Id2(id2 string) ApiPutDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiPutDataSourceRequest) Key(key string) ApiPutDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiPutDataSourceRequest) IntegrationId(integrationId string) ApiPutDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutDataSourceRequest) IntegrationKey(integrationKey string) ApiPutDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.PutDataSourceExecute(r)
}

/*
PutDataSource Method for PutDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to retrive
 @return ApiPutDataSourceRequest
*/
func (a *DataSourcesAPIService) PutDataSource(ctx context.Context, id string) ApiPutDataSourceRequest {
	return ApiPutDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) PutDataSourceExecute(r ApiPutDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PutDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	updateDataSourceInstanceDto *UpdateDataSourceInstanceDto
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPutDataSourceInstanceRequest) UpdateDataSourceInstanceDto(updateDataSourceInstanceDto UpdateDataSourceInstanceDto) ApiPutDataSourceInstanceRequest {
	r.updateDataSourceInstanceDto = &updateDataSourceInstanceDto
	return r
}

func (r ApiPutDataSourceInstanceRequest) Id(id string) ApiPutDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPutDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiPutDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiPutDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiPutDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiPutDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiPutDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPutDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiPutDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutDataSourceInstanceRequest) FlowKey(flowKey string) ApiPutDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPutDataSourceInstanceRequest) FlowId(flowId string) ApiPutDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPutDataSourceInstanceRequest) NodeKey(nodeKey string) ApiPutDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiPutDataSourceInstanceRequest) Udm(udm string) ApiPutDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiPutDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiPutDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutDataSourceInstanceRequest) IntegrationId(integrationId string) ApiPutDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutDataSourceInstanceRequest) ConnectionId(connectionId string) ApiPutDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPutDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.PutDataSourceInstanceExecute(r)
}

/*
PutDataSourceInstance Method for PutDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) PutDataSourceInstance(ctx context.Context) ApiPutDataSourceInstanceRequest {
	return ApiPutDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) PutDataSourceInstanceExecute(r ApiPutDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PutDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	updateDataSourceDto *UpdateDataSourceDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPutDataSourcesRequest) UpdateDataSourceDto(updateDataSourceDto UpdateDataSourceDto) ApiPutDataSourcesRequest {
	r.updateDataSourceDto = &updateDataSourceDto
	return r
}

func (r ApiPutDataSourcesRequest) Id(id string) ApiPutDataSourcesRequest {
	r.id = &id
	return r
}

func (r ApiPutDataSourcesRequest) Key(key string) ApiPutDataSourcesRequest {
	r.key = &key
	return r
}

func (r ApiPutDataSourcesRequest) IntegrationId(integrationId string) ApiPutDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutDataSourcesRequest) IntegrationKey(integrationKey string) ApiPutDataSourcesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutDataSourcesRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.PutDataSourcesExecute(r)
}

/*
PutDataSources Method for PutDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDataSourcesRequest
*/
func (a *DataSourcesAPIService) PutDataSources(ctx context.Context) ApiPutDataSourcesRequest {
	return ApiPutDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) PutDataSourcesExecute(r ApiPutDataSourcesRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.PutDataSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataSourceDto == nil {
		return localVarReturnValue, nil, reportError("updateDataSourceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataSourceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetDataSourceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiResetDataSourceRequest) Id2(id2 string) ApiResetDataSourceRequest {
	r.id2 = &id2
	return r
}

func (r ApiResetDataSourceRequest) Key(key string) ApiResetDataSourceRequest {
	r.key = &key
	return r
}

func (r ApiResetDataSourceRequest) IntegrationId(integrationId string) ApiResetDataSourceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetDataSourceRequest) IntegrationKey(integrationKey string) ApiResetDataSourceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetDataSourceRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.ResetDataSourceExecute(r)
}

/*
ResetDataSource Method for ResetDataSource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the data-source to reset
 @return ApiResetDataSourceRequest
*/
func (a *DataSourcesAPIService) ResetDataSource(ctx context.Context, id string) ApiResetDataSourceRequest {
	return ApiResetDataSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) ResetDataSourceExecute(r ApiResetDataSourceRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ResetDataSource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-sources/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiResetDataSourceInstanceRequest) Id(id string) ApiResetDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiResetDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiResetDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiResetDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiResetDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiResetDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiResetDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiResetDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiResetDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetDataSourceInstanceRequest) FlowKey(flowKey string) ApiResetDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiResetDataSourceInstanceRequest) FlowId(flowId string) ApiResetDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiResetDataSourceInstanceRequest) NodeKey(nodeKey string) ApiResetDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiResetDataSourceInstanceRequest) Udm(udm string) ApiResetDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiResetDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiResetDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetDataSourceInstanceRequest) IntegrationId(integrationId string) ApiResetDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetDataSourceInstanceRequest) ConnectionId(connectionId string) ApiResetDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiResetDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.ResetDataSourceInstanceExecute(r)
}

/*
ResetDataSourceInstance Method for ResetDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) ResetDataSourceInstance(ctx context.Context) ApiResetDataSourceInstanceRequest {
	return ApiResetDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) ResetDataSourceInstanceExecute(r ApiResetDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ResetDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetDataSourcesRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiResetDataSourcesRequest) Id(id string) ApiResetDataSourcesRequest {
	r.id = &id
	return r
}

func (r ApiResetDataSourcesRequest) Key(key string) ApiResetDataSourcesRequest {
	r.key = &key
	return r
}

func (r ApiResetDataSourcesRequest) IntegrationId(integrationId string) ApiResetDataSourcesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetDataSourcesRequest) IntegrationKey(integrationKey string) ApiResetDataSourcesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetDataSourcesRequest) Execute() (*DataSourceDto, *http.Response, error) {
	return r.ApiService.ResetDataSourcesExecute(r)
}

/*
ResetDataSources Method for ResetDataSources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetDataSourcesRequest
*/
func (a *DataSourcesAPIService) ResetDataSources(ctx context.Context) ApiResetDataSourcesRequest {
	return ApiResetDataSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceDto
func (a *DataSourcesAPIService) ResetDataSourcesExecute(r ApiResetDataSourcesRequest) (*DataSourceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.ResetDataSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetupDataSourceInstanceRequest struct {
	ctx context.Context
	ApiService DataSourcesAPI
	id *string
	dataSourceKey *string
	dataSourceId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	udm *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiSetupDataSourceInstanceRequest) Id(id string) ApiSetupDataSourceInstanceRequest {
	r.id = &id
	return r
}

func (r ApiSetupDataSourceInstanceRequest) DataSourceKey(dataSourceKey string) ApiSetupDataSourceInstanceRequest {
	r.dataSourceKey = &dataSourceKey
	return r
}

func (r ApiSetupDataSourceInstanceRequest) DataSourceId(dataSourceId string) ApiSetupDataSourceInstanceRequest {
	r.dataSourceId = &dataSourceId
	return r
}

func (r ApiSetupDataSourceInstanceRequest) InstanceKey(instanceKey string) ApiSetupDataSourceInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiSetupDataSourceInstanceRequest) AutoCreate(autoCreate bool) ApiSetupDataSourceInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiSetupDataSourceInstanceRequest) FlowKey(flowKey string) ApiSetupDataSourceInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiSetupDataSourceInstanceRequest) FlowId(flowId string) ApiSetupDataSourceInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiSetupDataSourceInstanceRequest) NodeKey(nodeKey string) ApiSetupDataSourceInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

// Deprecated
func (r ApiSetupDataSourceInstanceRequest) Udm(udm string) ApiSetupDataSourceInstanceRequest {
	r.udm = &udm
	return r
}

func (r ApiSetupDataSourceInstanceRequest) IntegrationKey(integrationKey string) ApiSetupDataSourceInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiSetupDataSourceInstanceRequest) IntegrationId(integrationId string) ApiSetupDataSourceInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiSetupDataSourceInstanceRequest) ConnectionId(connectionId string) ApiSetupDataSourceInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiSetupDataSourceInstanceRequest) Execute() (*DataSourceInstanceDto, *http.Response, error) {
	return r.ApiService.SetupDataSourceInstanceExecute(r)
}

/*
SetupDataSourceInstance Method for SetupDataSourceInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetupDataSourceInstanceRequest
*/
func (a *DataSourcesAPIService) SetupDataSourceInstance(ctx context.Context) ApiSetupDataSourceInstanceRequest {
	return ApiSetupDataSourceInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataSourceInstanceDto
func (a *DataSourcesAPIService) SetupDataSourceInstanceExecute(r ApiSetupDataSourceInstanceRequest) (*DataSourceInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataSourceInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataSourcesAPIService.SetupDataSourceInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-source-instance/setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.dataSourceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceKey", r.dataSourceKey, "")
	}
	if r.dataSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceId", r.dataSourceId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.udm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "udm", r.udm, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
