/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type DataLinksAPI interface {

	/*
	ArchiveDataLinkTableInstance Method for ArchiveDataLinkTableInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveDataLinkTableInstanceRequest
	*/
	ArchiveDataLinkTableInstance(ctx context.Context) ApiArchiveDataLinkTableInstanceRequest

	// ArchiveDataLinkTableInstanceExecute executes the request
	ArchiveDataLinkTableInstanceExecute(r ApiArchiveDataLinkTableInstanceRequest) (*http.Response, error)

	/*
	CreateDataLinkTable Method for CreateDataLinkTable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDataLinkTableRequest
	*/
	CreateDataLinkTable(ctx context.Context) ApiCreateDataLinkTableRequest

	// CreateDataLinkTableExecute executes the request
	//  @return DataLinkTableDto
	CreateDataLinkTableExecute(r ApiCreateDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error)

	/*
	CreateDataLinkTableInstanceLinks Method for CreateDataLinkTableInstanceLinks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDataLinkTableInstanceLinksRequest
	*/
	CreateDataLinkTableInstanceLinks(ctx context.Context) ApiCreateDataLinkTableInstanceLinksRequest

	// CreateDataLinkTableInstanceLinksExecute executes the request
	CreateDataLinkTableInstanceLinksExecute(r ApiCreateDataLinkTableInstanceLinksRequest) (*http.Response, error)

	/*
	DeleteDataLinkDto Method for DeleteDataLinkDto

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param dataLinkId
	@return ApiDeleteDataLinkDtoRequest
	*/
	DeleteDataLinkDto(ctx context.Context, dataLinkId string) ApiDeleteDataLinkDtoRequest

	// DeleteDataLinkDtoExecute executes the request
	DeleteDataLinkDtoExecute(r ApiDeleteDataLinkDtoRequest) (*http.Response, error)

	/*
	DeleteDataLinkTable Method for DeleteDataLinkTable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiDeleteDataLinkTableRequest
	*/
	DeleteDataLinkTable(ctx context.Context, idOrKey string) ApiDeleteDataLinkTableRequest

	// DeleteDataLinkTableExecute executes the request
	DeleteDataLinkTableExecute(r ApiDeleteDataLinkTableRequest) (*http.Response, error)

	/*
	DeleteDataLinkTableInstanceLinks Method for DeleteDataLinkTableInstanceLinks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteDataLinkTableInstanceLinksRequest
	*/
	DeleteDataLinkTableInstanceLinks(ctx context.Context) ApiDeleteDataLinkTableInstanceLinksRequest

	// DeleteDataLinkTableInstanceLinksExecute executes the request
	DeleteDataLinkTableInstanceLinksExecute(r ApiDeleteDataLinkTableInstanceLinksRequest) (*http.Response, error)

	/*
	GetDataLinkTable Method for GetDataLinkTable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetDataLinkTableRequest
	*/
	GetDataLinkTable(ctx context.Context, idOrKey string) ApiGetDataLinkTableRequest

	// GetDataLinkTableExecute executes the request
	//  @return DataLinkTableDto
	GetDataLinkTableExecute(r ApiGetDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error)

	/*
	GetDataLinkTableInstance Method for GetDataLinkTableInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataLinkTableInstanceRequest
	*/
	GetDataLinkTableInstance(ctx context.Context) ApiGetDataLinkTableInstanceRequest

	// GetDataLinkTableInstanceExecute executes the request
	//  @return DataLinkTableInstanceDto
	GetDataLinkTableInstanceExecute(r ApiGetDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error)

	/*
	GetDataLinkTableInstanceLinks Method for GetDataLinkTableInstanceLinks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDataLinkTableInstanceLinksRequest
	*/
	GetDataLinkTableInstanceLinks(ctx context.Context) ApiGetDataLinkTableInstanceLinksRequest

	// GetDataLinkTableInstanceLinksExecute executes the request
	GetDataLinkTableInstanceLinksExecute(r ApiGetDataLinkTableInstanceLinksRequest) (*http.Response, error)

	/*
	ListDataLinkTableInstances Method for ListDataLinkTableInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataLinkTableInstancesRequest
	*/
	ListDataLinkTableInstances(ctx context.Context) ApiListDataLinkTableInstancesRequest

	// ListDataLinkTableInstancesExecute executes the request
	//  @return ListDataLinkTableInstances200Response
	ListDataLinkTableInstancesExecute(r ApiListDataLinkTableInstancesRequest) (*ListDataLinkTableInstances200Response, *http.Response, error)

	/*
	ListDataLinkTables Method for ListDataLinkTables

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataLinkTablesRequest
	*/
	ListDataLinkTables(ctx context.Context) ApiListDataLinkTablesRequest

	// ListDataLinkTablesExecute executes the request
	//  @return ListDataLinkTables200Response
	ListDataLinkTablesExecute(r ApiListDataLinkTablesRequest) (*ListDataLinkTables200Response, *http.Response, error)

	/*
	ListDataLinks Method for ListDataLinks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDataLinksRequest
	*/
	ListDataLinks(ctx context.Context) ApiListDataLinksRequest

	// ListDataLinksExecute executes the request
	//  @return ListDataLinks200Response
	ListDataLinksExecute(r ApiListDataLinksRequest) (*ListDataLinks200Response, *http.Response, error)

	/*
	PatchDataLinkTable Method for PatchDataLinkTable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiPatchDataLinkTableRequest
	*/
	PatchDataLinkTable(ctx context.Context, idOrKey string) ApiPatchDataLinkTableRequest

	// PatchDataLinkTableExecute executes the request
	//  @return DataLinkTableDto
	PatchDataLinkTableExecute(r ApiPatchDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error)

	/*
	PatchDataLinkTableInstance Method for PatchDataLinkTableInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchDataLinkTableInstanceRequest
	*/
	PatchDataLinkTableInstance(ctx context.Context) ApiPatchDataLinkTableInstanceRequest

	// PatchDataLinkTableInstanceExecute executes the request
	//  @return DataLinkTableInstanceDto
	PatchDataLinkTableInstanceExecute(r ApiPatchDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error)

	/*
	PostDataLinkTableInstance Method for PostDataLinkTableInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostDataLinkTableInstanceRequest
	*/
	PostDataLinkTableInstance(ctx context.Context) ApiPostDataLinkTableInstanceRequest

	// PostDataLinkTableInstanceExecute executes the request
	//  @return DataLinkTableInstanceDto
	PostDataLinkTableInstanceExecute(r ApiPostDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error)

	/*
	PutDataLinkTable Method for PutDataLinkTable

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiPutDataLinkTableRequest
	*/
	PutDataLinkTable(ctx context.Context, idOrKey string) ApiPutDataLinkTableRequest

	// PutDataLinkTableExecute executes the request
	//  @return DataLinkTableDto
	PutDataLinkTableExecute(r ApiPutDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error)

	/*
	PutDataLinkTableInstance Method for PutDataLinkTableInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutDataLinkTableInstanceRequest
	*/
	PutDataLinkTableInstance(ctx context.Context) ApiPutDataLinkTableInstanceRequest

	// PutDataLinkTableInstanceExecute executes the request
	//  @return DataLinkTableInstanceDto
	PutDataLinkTableInstanceExecute(r ApiPutDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error)
}

// DataLinksAPIService DataLinksAPI service
type DataLinksAPIService service

type ApiArchiveDataLinkTableInstanceRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiArchiveDataLinkTableInstanceRequest) Id(id string) ApiArchiveDataLinkTableInstanceRequest {
	r.id = &id
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) InstanceKey(instanceKey string) ApiArchiveDataLinkTableInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) DataLinkTableId(dataLinkTableId string) ApiArchiveDataLinkTableInstanceRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) DataLinkTableKey(dataLinkTableKey string) ApiArchiveDataLinkTableInstanceRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) AutoCreate(autoCreate bool) ApiArchiveDataLinkTableInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) IntegrationKey(integrationKey string) ApiArchiveDataLinkTableInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) IntegrationId(integrationId string) ApiArchiveDataLinkTableInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) ConnectionId(connectionId string) ApiArchiveDataLinkTableInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiArchiveDataLinkTableInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveDataLinkTableInstanceExecute(r)
}

/*
ArchiveDataLinkTableInstance Method for ArchiveDataLinkTableInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveDataLinkTableInstanceRequest
*/
func (a *DataLinksAPIService) ArchiveDataLinkTableInstance(ctx context.Context) ApiArchiveDataLinkTableInstanceRequest {
	return ApiArchiveDataLinkTableInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) ArchiveDataLinkTableInstanceExecute(r ApiArchiveDataLinkTableInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.ArchiveDataLinkTableInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDataLinkTableRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	createDataLinkTableDto *CreateDataLinkTableDto
}

func (r ApiCreateDataLinkTableRequest) CreateDataLinkTableDto(createDataLinkTableDto CreateDataLinkTableDto) ApiCreateDataLinkTableRequest {
	r.createDataLinkTableDto = &createDataLinkTableDto
	return r
}

func (r ApiCreateDataLinkTableRequest) Execute() (*DataLinkTableDto, *http.Response, error) {
	return r.ApiService.CreateDataLinkTableExecute(r)
}

/*
CreateDataLinkTable Method for CreateDataLinkTable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataLinkTableRequest
*/
func (a *DataLinksAPIService) CreateDataLinkTable(ctx context.Context) ApiCreateDataLinkTableRequest {
	return ApiCreateDataLinkTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataLinkTableDto
func (a *DataLinksAPIService) CreateDataLinkTableExecute(r ApiCreateDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.CreateDataLinkTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataLinkTableDto == nil {
		return localVarReturnValue, nil, reportError("createDataLinkTableDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataLinkTableDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDataLinkTableInstanceLinksRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	createDataLinkDto *CreateDataLinkDto
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) CreateDataLinkDto(createDataLinkDto CreateDataLinkDto) ApiCreateDataLinkTableInstanceLinksRequest {
	r.createDataLinkDto = &createDataLinkDto
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) Id(id string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.id = &id
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) InstanceKey(instanceKey string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) DataLinkTableId(dataLinkTableId string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) DataLinkTableKey(dataLinkTableKey string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) AutoCreate(autoCreate bool) ApiCreateDataLinkTableInstanceLinksRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) IntegrationKey(integrationKey string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) IntegrationId(integrationId string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) ConnectionId(connectionId string) ApiCreateDataLinkTableInstanceLinksRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiCreateDataLinkTableInstanceLinksRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateDataLinkTableInstanceLinksExecute(r)
}

/*
CreateDataLinkTableInstanceLinks Method for CreateDataLinkTableInstanceLinks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataLinkTableInstanceLinksRequest
*/
func (a *DataLinksAPIService) CreateDataLinkTableInstanceLinks(ctx context.Context) ApiCreateDataLinkTableInstanceLinksRequest {
	return ApiCreateDataLinkTableInstanceLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) CreateDataLinkTableInstanceLinksExecute(r ApiCreateDataLinkTableInstanceLinksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.CreateDataLinkTableInstanceLinks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataLinkDto == nil {
		return nil, reportError("createDataLinkDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataLinkDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDataLinkDtoRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	dataLinkId string
}

func (r ApiDeleteDataLinkDtoRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataLinkDtoExecute(r)
}

/*
DeleteDataLinkDto Method for DeleteDataLinkDto

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dataLinkId
 @return ApiDeleteDataLinkDtoRequest
*/
func (a *DataLinksAPIService) DeleteDataLinkDto(ctx context.Context, dataLinkId string) ApiDeleteDataLinkDtoRequest {
	return ApiDeleteDataLinkDtoRequest{
		ApiService: a,
		ctx: ctx,
		dataLinkId: dataLinkId,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) DeleteDataLinkDtoExecute(r ApiDeleteDataLinkDtoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.DeleteDataLinkDto")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-links/{dataLinkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"dataLinkId"+"}", url.PathEscape(parameterValueToString(r.dataLinkId, "dataLinkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDataLinkTableRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	idOrKey string
}

func (r ApiDeleteDataLinkTableRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataLinkTableExecute(r)
}

/*
DeleteDataLinkTable Method for DeleteDataLinkTable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiDeleteDataLinkTableRequest
*/
func (a *DataLinksAPIService) DeleteDataLinkTable(ctx context.Context, idOrKey string) ApiDeleteDataLinkTableRequest {
	return ApiDeleteDataLinkTableRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) DeleteDataLinkTableExecute(r ApiDeleteDataLinkTableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.DeleteDataLinkTable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDataLinkTableInstanceLinksRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	deleteDataLinkDto *DeleteDataLinkDto
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) DeleteDataLinkDto(deleteDataLinkDto DeleteDataLinkDto) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.deleteDataLinkDto = &deleteDataLinkDto
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) Id(id string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.id = &id
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) InstanceKey(instanceKey string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) DataLinkTableId(dataLinkTableId string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) DataLinkTableKey(dataLinkTableKey string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) AutoCreate(autoCreate bool) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) IntegrationKey(integrationKey string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) IntegrationId(integrationId string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) ConnectionId(connectionId string) ApiDeleteDataLinkTableInstanceLinksRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDeleteDataLinkTableInstanceLinksRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataLinkTableInstanceLinksExecute(r)
}

/*
DeleteDataLinkTableInstanceLinks Method for DeleteDataLinkTableInstanceLinks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteDataLinkTableInstanceLinksRequest
*/
func (a *DataLinksAPIService) DeleteDataLinkTableInstanceLinks(ctx context.Context) ApiDeleteDataLinkTableInstanceLinksRequest {
	return ApiDeleteDataLinkTableInstanceLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) DeleteDataLinkTableInstanceLinksExecute(r ApiDeleteDataLinkTableInstanceLinksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.DeleteDataLinkTableInstanceLinks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteDataLinkDto == nil {
		return nil, reportError("deleteDataLinkDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteDataLinkDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDataLinkTableRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	idOrKey string
}

func (r ApiGetDataLinkTableRequest) Execute() (*DataLinkTableDto, *http.Response, error) {
	return r.ApiService.GetDataLinkTableExecute(r)
}

/*
GetDataLinkTable Method for GetDataLinkTable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetDataLinkTableRequest
*/
func (a *DataLinksAPIService) GetDataLinkTable(ctx context.Context, idOrKey string) ApiGetDataLinkTableRequest {
	return ApiGetDataLinkTableRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return DataLinkTableDto
func (a *DataLinksAPIService) GetDataLinkTableExecute(r ApiGetDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.GetDataLinkTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataLinkTableInstanceRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiGetDataLinkTableInstanceRequest) Id(id string) ApiGetDataLinkTableInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) InstanceKey(instanceKey string) ApiGetDataLinkTableInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) DataLinkTableId(dataLinkTableId string) ApiGetDataLinkTableInstanceRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) DataLinkTableKey(dataLinkTableKey string) ApiGetDataLinkTableInstanceRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) AutoCreate(autoCreate bool) ApiGetDataLinkTableInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) IntegrationKey(integrationKey string) ApiGetDataLinkTableInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) IntegrationId(integrationId string) ApiGetDataLinkTableInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) ConnectionId(connectionId string) ApiGetDataLinkTableInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetDataLinkTableInstanceRequest) Execute() (*DataLinkTableInstanceDto, *http.Response, error) {
	return r.ApiService.GetDataLinkTableInstanceExecute(r)
}

/*
GetDataLinkTableInstance Method for GetDataLinkTableInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDataLinkTableInstanceRequest
*/
func (a *DataLinksAPIService) GetDataLinkTableInstance(ctx context.Context) ApiGetDataLinkTableInstanceRequest {
	return ApiGetDataLinkTableInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataLinkTableInstanceDto
func (a *DataLinksAPIService) GetDataLinkTableInstanceExecute(r ApiGetDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.GetDataLinkTableInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataLinkTableInstanceLinksRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
	direction *string
	appRecordId *string
	externalRecordId *string
	limit *float32
	cursor *string
}

func (r ApiGetDataLinkTableInstanceLinksRequest) Id(id string) ApiGetDataLinkTableInstanceLinksRequest {
	r.id = &id
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) InstanceKey(instanceKey string) ApiGetDataLinkTableInstanceLinksRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) DataLinkTableId(dataLinkTableId string) ApiGetDataLinkTableInstanceLinksRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) DataLinkTableKey(dataLinkTableKey string) ApiGetDataLinkTableInstanceLinksRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) AutoCreate(autoCreate bool) ApiGetDataLinkTableInstanceLinksRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) IntegrationKey(integrationKey string) ApiGetDataLinkTableInstanceLinksRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) IntegrationId(integrationId string) ApiGetDataLinkTableInstanceLinksRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) ConnectionId(connectionId string) ApiGetDataLinkTableInstanceLinksRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) Direction(direction string) ApiGetDataLinkTableInstanceLinksRequest {
	r.direction = &direction
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) AppRecordId(appRecordId string) ApiGetDataLinkTableInstanceLinksRequest {
	r.appRecordId = &appRecordId
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) ExternalRecordId(externalRecordId string) ApiGetDataLinkTableInstanceLinksRequest {
	r.externalRecordId = &externalRecordId
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) Limit(limit float32) ApiGetDataLinkTableInstanceLinksRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) Cursor(cursor string) ApiGetDataLinkTableInstanceLinksRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetDataLinkTableInstanceLinksRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDataLinkTableInstanceLinksExecute(r)
}

/*
GetDataLinkTableInstanceLinks Method for GetDataLinkTableInstanceLinks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDataLinkTableInstanceLinksRequest
*/
func (a *DataLinksAPIService) GetDataLinkTableInstanceLinks(ctx context.Context) ApiGetDataLinkTableInstanceLinksRequest {
	return ApiGetDataLinkTableInstanceLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DataLinksAPIService) GetDataLinkTableInstanceLinksExecute(r ApiGetDataLinkTableInstanceLinksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.GetDataLinkTableInstanceLinks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance/links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	if r.appRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appRecordId", r.appRecordId, "")
	}
	if r.externalRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRecordId", r.externalRecordId, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListDataLinkTableInstancesRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	id *string
	userId *string
	dataLinkTableId *string
	connectionId *string
	integrationId *string
}

func (r ApiListDataLinkTableInstancesRequest) Id(id string) ApiListDataLinkTableInstancesRequest {
	r.id = &id
	return r
}

func (r ApiListDataLinkTableInstancesRequest) UserId(userId string) ApiListDataLinkTableInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiListDataLinkTableInstancesRequest) DataLinkTableId(dataLinkTableId string) ApiListDataLinkTableInstancesRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiListDataLinkTableInstancesRequest) ConnectionId(connectionId string) ApiListDataLinkTableInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListDataLinkTableInstancesRequest) IntegrationId(integrationId string) ApiListDataLinkTableInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListDataLinkTableInstancesRequest) Execute() (*ListDataLinkTableInstances200Response, *http.Response, error) {
	return r.ApiService.ListDataLinkTableInstancesExecute(r)
}

/*
ListDataLinkTableInstances Method for ListDataLinkTableInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataLinkTableInstancesRequest
*/
func (a *DataLinksAPIService) ListDataLinkTableInstances(ctx context.Context) ApiListDataLinkTableInstancesRequest {
	return ApiListDataLinkTableInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataLinkTableInstances200Response
func (a *DataLinksAPIService) ListDataLinkTableInstancesExecute(r ApiListDataLinkTableInstancesRequest) (*ListDataLinkTableInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataLinkTableInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.ListDataLinkTableInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataLinkTablesRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
}

func (r ApiListDataLinkTablesRequest) Execute() (*ListDataLinkTables200Response, *http.Response, error) {
	return r.ApiService.ListDataLinkTablesExecute(r)
}

/*
ListDataLinkTables Method for ListDataLinkTables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataLinkTablesRequest
*/
func (a *DataLinksAPIService) ListDataLinkTables(ctx context.Context) ApiListDataLinkTablesRequest {
	return ApiListDataLinkTablesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataLinkTables200Response
func (a *DataLinksAPIService) ListDataLinkTablesExecute(r ApiListDataLinkTablesRequest) (*ListDataLinkTables200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataLinkTables200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.ListDataLinkTables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataLinksRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	dataLinkTableInstanceId *string
	externalRecordId *string
	appRecordId *string
	direction *string
}

func (r ApiListDataLinksRequest) DataLinkTableInstanceId(dataLinkTableInstanceId string) ApiListDataLinksRequest {
	r.dataLinkTableInstanceId = &dataLinkTableInstanceId
	return r
}

func (r ApiListDataLinksRequest) ExternalRecordId(externalRecordId string) ApiListDataLinksRequest {
	r.externalRecordId = &externalRecordId
	return r
}

func (r ApiListDataLinksRequest) AppRecordId(appRecordId string) ApiListDataLinksRequest {
	r.appRecordId = &appRecordId
	return r
}

func (r ApiListDataLinksRequest) Direction(direction string) ApiListDataLinksRequest {
	r.direction = &direction
	return r
}

func (r ApiListDataLinksRequest) Execute() (*ListDataLinks200Response, *http.Response, error) {
	return r.ApiService.ListDataLinksExecute(r)
}

/*
ListDataLinks Method for ListDataLinks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDataLinksRequest
*/
func (a *DataLinksAPIService) ListDataLinks(ctx context.Context) ApiListDataLinksRequest {
	return ApiListDataLinksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDataLinks200Response
func (a *DataLinksAPIService) ListDataLinksExecute(r ApiListDataLinksRequest) (*ListDataLinks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDataLinks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.ListDataLinks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-links"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataLinkTableInstanceId == nil {
		return localVarReturnValue, nil, reportError("dataLinkTableInstanceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableInstanceId", r.dataLinkTableInstanceId, "")
	if r.externalRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalRecordId", r.externalRecordId, "")
	}
	if r.appRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appRecordId", r.appRecordId, "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDataLinkTableRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	idOrKey string
	updateDataLinkTableDto *UpdateDataLinkTableDto
}

func (r ApiPatchDataLinkTableRequest) UpdateDataLinkTableDto(updateDataLinkTableDto UpdateDataLinkTableDto) ApiPatchDataLinkTableRequest {
	r.updateDataLinkTableDto = &updateDataLinkTableDto
	return r
}

func (r ApiPatchDataLinkTableRequest) Execute() (*DataLinkTableDto, *http.Response, error) {
	return r.ApiService.PatchDataLinkTableExecute(r)
}

/*
PatchDataLinkTable Method for PatchDataLinkTable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiPatchDataLinkTableRequest
*/
func (a *DataLinksAPIService) PatchDataLinkTable(ctx context.Context, idOrKey string) ApiPatchDataLinkTableRequest {
	return ApiPatchDataLinkTableRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return DataLinkTableDto
func (a *DataLinksAPIService) PatchDataLinkTableExecute(r ApiPatchDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.PatchDataLinkTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDataLinkTableDto == nil {
		return localVarReturnValue, nil, reportError("updateDataLinkTableDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDataLinkTableDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDataLinkTableInstanceRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPatchDataLinkTableInstanceRequest) Body(body map[string]interface{}) ApiPatchDataLinkTableInstanceRequest {
	r.body = &body
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) Id(id string) ApiPatchDataLinkTableInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) InstanceKey(instanceKey string) ApiPatchDataLinkTableInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) DataLinkTableId(dataLinkTableId string) ApiPatchDataLinkTableInstanceRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) DataLinkTableKey(dataLinkTableKey string) ApiPatchDataLinkTableInstanceRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) AutoCreate(autoCreate bool) ApiPatchDataLinkTableInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) IntegrationKey(integrationKey string) ApiPatchDataLinkTableInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) IntegrationId(integrationId string) ApiPatchDataLinkTableInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) ConnectionId(connectionId string) ApiPatchDataLinkTableInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPatchDataLinkTableInstanceRequest) Execute() (*DataLinkTableInstanceDto, *http.Response, error) {
	return r.ApiService.PatchDataLinkTableInstanceExecute(r)
}

/*
PatchDataLinkTableInstance Method for PatchDataLinkTableInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchDataLinkTableInstanceRequest
*/
func (a *DataLinksAPIService) PatchDataLinkTableInstance(ctx context.Context) ApiPatchDataLinkTableInstanceRequest {
	return ApiPatchDataLinkTableInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataLinkTableInstanceDto
func (a *DataLinksAPIService) PatchDataLinkTableInstanceExecute(r ApiPatchDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.PatchDataLinkTableInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDataLinkTableInstanceRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPostDataLinkTableInstanceRequest) Body(body map[string]interface{}) ApiPostDataLinkTableInstanceRequest {
	r.body = &body
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) Id(id string) ApiPostDataLinkTableInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) InstanceKey(instanceKey string) ApiPostDataLinkTableInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) DataLinkTableId(dataLinkTableId string) ApiPostDataLinkTableInstanceRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) DataLinkTableKey(dataLinkTableKey string) ApiPostDataLinkTableInstanceRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) AutoCreate(autoCreate bool) ApiPostDataLinkTableInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) IntegrationKey(integrationKey string) ApiPostDataLinkTableInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) IntegrationId(integrationId string) ApiPostDataLinkTableInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) ConnectionId(connectionId string) ApiPostDataLinkTableInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPostDataLinkTableInstanceRequest) Execute() (*DataLinkTableInstanceDto, *http.Response, error) {
	return r.ApiService.PostDataLinkTableInstanceExecute(r)
}

/*
PostDataLinkTableInstance Method for PostDataLinkTableInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostDataLinkTableInstanceRequest
*/
func (a *DataLinksAPIService) PostDataLinkTableInstance(ctx context.Context) ApiPostDataLinkTableInstanceRequest {
	return ApiPostDataLinkTableInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataLinkTableInstanceDto
func (a *DataLinksAPIService) PostDataLinkTableInstanceExecute(r ApiPostDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.PostDataLinkTableInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDataLinkTableRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	idOrKey string
	createDataLinkTableDto *CreateDataLinkTableDto
}

func (r ApiPutDataLinkTableRequest) CreateDataLinkTableDto(createDataLinkTableDto CreateDataLinkTableDto) ApiPutDataLinkTableRequest {
	r.createDataLinkTableDto = &createDataLinkTableDto
	return r
}

func (r ApiPutDataLinkTableRequest) Execute() (*DataLinkTableDto, *http.Response, error) {
	return r.ApiService.PutDataLinkTableExecute(r)
}

/*
PutDataLinkTable Method for PutDataLinkTable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiPutDataLinkTableRequest
*/
func (a *DataLinksAPIService) PutDataLinkTable(ctx context.Context, idOrKey string) ApiPutDataLinkTableRequest {
	return ApiPutDataLinkTableRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return DataLinkTableDto
func (a *DataLinksAPIService) PutDataLinkTableExecute(r ApiPutDataLinkTableRequest) (*DataLinkTableDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.PutDataLinkTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-tables/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDataLinkTableDto == nil {
		return localVarReturnValue, nil, reportError("createDataLinkTableDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDataLinkTableDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDataLinkTableInstanceRequest struct {
	ctx context.Context
	ApiService DataLinksAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	dataLinkTableId *string
	dataLinkTableKey *string
	autoCreate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPutDataLinkTableInstanceRequest) Body(body map[string]interface{}) ApiPutDataLinkTableInstanceRequest {
	r.body = &body
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) Id(id string) ApiPutDataLinkTableInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) InstanceKey(instanceKey string) ApiPutDataLinkTableInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) DataLinkTableId(dataLinkTableId string) ApiPutDataLinkTableInstanceRequest {
	r.dataLinkTableId = &dataLinkTableId
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) DataLinkTableKey(dataLinkTableKey string) ApiPutDataLinkTableInstanceRequest {
	r.dataLinkTableKey = &dataLinkTableKey
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) AutoCreate(autoCreate bool) ApiPutDataLinkTableInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) IntegrationKey(integrationKey string) ApiPutDataLinkTableInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) IntegrationId(integrationId string) ApiPutDataLinkTableInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) ConnectionId(connectionId string) ApiPutDataLinkTableInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPutDataLinkTableInstanceRequest) Execute() (*DataLinkTableInstanceDto, *http.Response, error) {
	return r.ApiService.PutDataLinkTableInstanceExecute(r)
}

/*
PutDataLinkTableInstance Method for PutDataLinkTableInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutDataLinkTableInstanceRequest
*/
func (a *DataLinksAPIService) PutDataLinkTableInstance(ctx context.Context) ApiPutDataLinkTableInstanceRequest {
	return ApiPutDataLinkTableInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DataLinkTableInstanceDto
func (a *DataLinksAPIService) PutDataLinkTableInstanceExecute(r ApiPutDataLinkTableInstanceRequest) (*DataLinkTableInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataLinkTableInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataLinksAPIService.PutDataLinkTableInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-link-table-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataLinkTableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableId", r.dataLinkTableId, "")
	}
	if r.dataLinkTableKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataLinkTableKey", r.dataLinkTableKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
