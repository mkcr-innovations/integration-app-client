/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ScenariosAPI interface {

	/*
	ArchiveScenario Method for ArchiveScenario

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiArchiveScenarioRequest
	*/
	ArchiveScenario(ctx context.Context, id string) ApiArchiveScenarioRequest

	// ArchiveScenarioExecute executes the request
	ArchiveScenarioExecute(r ApiArchiveScenarioRequest) (*http.Response, error)

	/*
	ArchiveScenarios Method for ArchiveScenarios

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveScenariosRequest
	*/
	ArchiveScenarios(ctx context.Context) ApiArchiveScenariosRequest

	// ArchiveScenariosExecute executes the request
	ArchiveScenariosExecute(r ApiArchiveScenariosRequest) (*http.Response, error)

	/*
	CreateScenario Method for CreateScenario

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateScenarioRequest
	*/
	CreateScenario(ctx context.Context) ApiCreateScenarioRequest

	// CreateScenarioExecute executes the request
	//  @return ScenarioDto
	CreateScenarioExecute(r ApiCreateScenarioRequest) (*ScenarioDto, *http.Response, error)

	/*
	GetScenario Method for GetScenario

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetScenarioRequest
	*/
	GetScenario(ctx context.Context, id string) ApiGetScenarioRequest

	// GetScenarioExecute executes the request
	//  @return ScenarioDto
	GetScenarioExecute(r ApiGetScenarioRequest) (*ScenarioDto, *http.Response, error)

	/*
	GetScenarios Method for GetScenarios

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetScenariosRequest
	*/
	GetScenarios(ctx context.Context) ApiGetScenariosRequest

	// GetScenariosExecute executes the request
	//  @return ScenarioDto
	GetScenariosExecute(r ApiGetScenariosRequest) (*ScenarioDto, *http.Response, error)

	/*
	ListScenarios Method for ListScenarios

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListScenariosRequest
	*/
	ListScenarios(ctx context.Context) ApiListScenariosRequest

	// ListScenariosExecute executes the request
	ListScenariosExecute(r ApiListScenariosRequest) (*http.Response, error)

	/*
	PatchScenario Method for PatchScenario

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPatchScenarioRequest
	*/
	PatchScenario(ctx context.Context, id string) ApiPatchScenarioRequest

	// PatchScenarioExecute executes the request
	//  @return ScenarioDto
	PatchScenarioExecute(r ApiPatchScenarioRequest) (*ScenarioDto, *http.Response, error)

	/*
	PatchScenarios Method for PatchScenarios

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchScenariosRequest
	*/
	PatchScenarios(ctx context.Context) ApiPatchScenariosRequest

	// PatchScenariosExecute executes the request
	//  @return ScenarioDto
	PatchScenariosExecute(r ApiPatchScenariosRequest) (*ScenarioDto, *http.Response, error)

	/*
	PutScenario Method for PutScenario

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPutScenarioRequest
	*/
	PutScenario(ctx context.Context, id string) ApiPutScenarioRequest

	// PutScenarioExecute executes the request
	//  @return ScenarioDto
	PutScenarioExecute(r ApiPutScenarioRequest) (*ScenarioDto, *http.Response, error)

	/*
	PutScenarios Method for PutScenarios

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutScenariosRequest
	*/
	PutScenarios(ctx context.Context) ApiPutScenariosRequest

	// PutScenariosExecute executes the request
	//  @return ScenarioDto
	PutScenariosExecute(r ApiPutScenariosRequest) (*ScenarioDto, *http.Response, error)
}

// ScenariosAPIService ScenariosAPI service
type ScenariosAPIService service

type ApiArchiveScenarioRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id string
	id2 *string
	key *string
	scenarioTemplateId *string
}

func (r ApiArchiveScenarioRequest) Id2(id2 string) ApiArchiveScenarioRequest {
	r.id2 = &id2
	return r
}

func (r ApiArchiveScenarioRequest) Key(key string) ApiArchiveScenarioRequest {
	r.key = &key
	return r
}

func (r ApiArchiveScenarioRequest) ScenarioTemplateId(scenarioTemplateId string) ApiArchiveScenarioRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiArchiveScenarioRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveScenarioExecute(r)
}

/*
ArchiveScenario Method for ArchiveScenario

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiArchiveScenarioRequest
*/
func (a *ScenariosAPIService) ArchiveScenario(ctx context.Context, id string) ApiArchiveScenarioRequest {
	return ApiArchiveScenarioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ScenariosAPIService) ArchiveScenarioExecute(r ApiArchiveScenarioRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.ArchiveScenario")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveScenariosRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id *string
	key *string
	scenarioTemplateId *string
}

func (r ApiArchiveScenariosRequest) Id(id string) ApiArchiveScenariosRequest {
	r.id = &id
	return r
}

func (r ApiArchiveScenariosRequest) Key(key string) ApiArchiveScenariosRequest {
	r.key = &key
	return r
}

func (r ApiArchiveScenariosRequest) ScenarioTemplateId(scenarioTemplateId string) ApiArchiveScenariosRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiArchiveScenariosRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveScenariosExecute(r)
}

/*
ArchiveScenarios Method for ArchiveScenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveScenariosRequest
*/
func (a *ScenariosAPIService) ArchiveScenarios(ctx context.Context) ApiArchiveScenariosRequest {
	return ApiArchiveScenariosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ScenariosAPIService) ArchiveScenariosExecute(r ApiArchiveScenariosRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.ArchiveScenarios")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenario"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateScenarioRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	createScenarioDto *CreateScenarioDto
}

func (r ApiCreateScenarioRequest) CreateScenarioDto(createScenarioDto CreateScenarioDto) ApiCreateScenarioRequest {
	r.createScenarioDto = &createScenarioDto
	return r
}

func (r ApiCreateScenarioRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.CreateScenarioExecute(r)
}

/*
CreateScenario Method for CreateScenario

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateScenarioRequest
*/
func (a *ScenariosAPIService) CreateScenario(ctx context.Context) ApiCreateScenarioRequest {
	return ApiCreateScenarioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) CreateScenarioExecute(r ApiCreateScenarioRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.CreateScenario")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createScenarioDto == nil {
		return localVarReturnValue, nil, reportError("createScenarioDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createScenarioDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScenarioRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id string
	id2 *string
	key *string
	scenarioTemplateId *string
}

func (r ApiGetScenarioRequest) Id2(id2 string) ApiGetScenarioRequest {
	r.id2 = &id2
	return r
}

func (r ApiGetScenarioRequest) Key(key string) ApiGetScenarioRequest {
	r.key = &key
	return r
}

func (r ApiGetScenarioRequest) ScenarioTemplateId(scenarioTemplateId string) ApiGetScenarioRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiGetScenarioRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.GetScenarioExecute(r)
}

/*
GetScenario Method for GetScenario

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetScenarioRequest
*/
func (a *ScenariosAPIService) GetScenario(ctx context.Context, id string) ApiGetScenarioRequest {
	return ApiGetScenarioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) GetScenarioExecute(r ApiGetScenarioRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.GetScenario")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScenariosRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id *string
	key *string
	scenarioTemplateId *string
}

func (r ApiGetScenariosRequest) Id(id string) ApiGetScenariosRequest {
	r.id = &id
	return r
}

func (r ApiGetScenariosRequest) Key(key string) ApiGetScenariosRequest {
	r.key = &key
	return r
}

func (r ApiGetScenariosRequest) ScenarioTemplateId(scenarioTemplateId string) ApiGetScenariosRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiGetScenariosRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.GetScenariosExecute(r)
}

/*
GetScenarios Method for GetScenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetScenariosRequest
*/
func (a *ScenariosAPIService) GetScenarios(ctx context.Context) ApiGetScenariosRequest {
	return ApiGetScenariosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) GetScenariosExecute(r ApiGetScenariosRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.GetScenarios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenario"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListScenariosRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
}

func (r ApiListScenariosRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListScenariosExecute(r)
}

/*
ListScenarios Method for ListScenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListScenariosRequest
*/
func (a *ScenariosAPIService) ListScenarios(ctx context.Context) ApiListScenariosRequest {
	return ApiListScenariosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ScenariosAPIService) ListScenariosExecute(r ApiListScenariosRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.ListScenarios")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchScenarioRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id string
	updateScenarioDto *UpdateScenarioDto
	id2 *string
	key *string
	scenarioTemplateId *string
}

func (r ApiPatchScenarioRequest) UpdateScenarioDto(updateScenarioDto UpdateScenarioDto) ApiPatchScenarioRequest {
	r.updateScenarioDto = &updateScenarioDto
	return r
}

func (r ApiPatchScenarioRequest) Id2(id2 string) ApiPatchScenarioRequest {
	r.id2 = &id2
	return r
}

func (r ApiPatchScenarioRequest) Key(key string) ApiPatchScenarioRequest {
	r.key = &key
	return r
}

func (r ApiPatchScenarioRequest) ScenarioTemplateId(scenarioTemplateId string) ApiPatchScenarioRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiPatchScenarioRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.PatchScenarioExecute(r)
}

/*
PatchScenario Method for PatchScenario

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPatchScenarioRequest
*/
func (a *ScenariosAPIService) PatchScenario(ctx context.Context, id string) ApiPatchScenarioRequest {
	return ApiPatchScenarioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) PatchScenarioExecute(r ApiPatchScenarioRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.PatchScenario")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateScenarioDto == nil {
		return localVarReturnValue, nil, reportError("updateScenarioDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateScenarioDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchScenariosRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	updateScenarioDto *UpdateScenarioDto
	id *string
	key *string
	scenarioTemplateId *string
}

func (r ApiPatchScenariosRequest) UpdateScenarioDto(updateScenarioDto UpdateScenarioDto) ApiPatchScenariosRequest {
	r.updateScenarioDto = &updateScenarioDto
	return r
}

func (r ApiPatchScenariosRequest) Id(id string) ApiPatchScenariosRequest {
	r.id = &id
	return r
}

func (r ApiPatchScenariosRequest) Key(key string) ApiPatchScenariosRequest {
	r.key = &key
	return r
}

func (r ApiPatchScenariosRequest) ScenarioTemplateId(scenarioTemplateId string) ApiPatchScenariosRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiPatchScenariosRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.PatchScenariosExecute(r)
}

/*
PatchScenarios Method for PatchScenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchScenariosRequest
*/
func (a *ScenariosAPIService) PatchScenarios(ctx context.Context) ApiPatchScenariosRequest {
	return ApiPatchScenariosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) PatchScenariosExecute(r ApiPatchScenariosRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.PatchScenarios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenario"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateScenarioDto == nil {
		return localVarReturnValue, nil, reportError("updateScenarioDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateScenarioDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutScenarioRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	id string
	updateScenarioDto *UpdateScenarioDto
	id2 *string
	key *string
	scenarioTemplateId *string
}

func (r ApiPutScenarioRequest) UpdateScenarioDto(updateScenarioDto UpdateScenarioDto) ApiPutScenarioRequest {
	r.updateScenarioDto = &updateScenarioDto
	return r
}

func (r ApiPutScenarioRequest) Id2(id2 string) ApiPutScenarioRequest {
	r.id2 = &id2
	return r
}

func (r ApiPutScenarioRequest) Key(key string) ApiPutScenarioRequest {
	r.key = &key
	return r
}

func (r ApiPutScenarioRequest) ScenarioTemplateId(scenarioTemplateId string) ApiPutScenarioRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiPutScenarioRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.PutScenarioExecute(r)
}

/*
PutScenario Method for PutScenario

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPutScenarioRequest
*/
func (a *ScenariosAPIService) PutScenario(ctx context.Context, id string) ApiPutScenarioRequest {
	return ApiPutScenarioRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) PutScenarioExecute(r ApiPutScenarioRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.PutScenario")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenarios/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateScenarioDto == nil {
		return localVarReturnValue, nil, reportError("updateScenarioDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateScenarioDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutScenariosRequest struct {
	ctx context.Context
	ApiService ScenariosAPI
	updateScenarioDto *UpdateScenarioDto
	id *string
	key *string
	scenarioTemplateId *string
}

func (r ApiPutScenariosRequest) UpdateScenarioDto(updateScenarioDto UpdateScenarioDto) ApiPutScenariosRequest {
	r.updateScenarioDto = &updateScenarioDto
	return r
}

func (r ApiPutScenariosRequest) Id(id string) ApiPutScenariosRequest {
	r.id = &id
	return r
}

func (r ApiPutScenariosRequest) Key(key string) ApiPutScenariosRequest {
	r.key = &key
	return r
}

func (r ApiPutScenariosRequest) ScenarioTemplateId(scenarioTemplateId string) ApiPutScenariosRequest {
	r.scenarioTemplateId = &scenarioTemplateId
	return r
}

func (r ApiPutScenariosRequest) Execute() (*ScenarioDto, *http.Response, error) {
	return r.ApiService.PutScenariosExecute(r)
}

/*
PutScenarios Method for PutScenarios

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutScenariosRequest
*/
func (a *ScenariosAPIService) PutScenarios(ctx context.Context) ApiPutScenariosRequest {
	return ApiPutScenariosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ScenarioDto
func (a *ScenariosAPIService) PutScenariosExecute(r ApiPutScenariosRequest) (*ScenarioDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ScenarioDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScenariosAPIService.PutScenarios")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scenario"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateScenarioDto == nil {
		return localVarReturnValue, nil, reportError("updateScenarioDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.scenarioTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scenarioTemplateId", r.scenarioTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateScenarioDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
