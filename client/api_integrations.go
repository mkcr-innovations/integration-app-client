/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type IntegrationsAPI interface {

	/*
	IntegrationsControllerArchiveIntegration Archive integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerArchiveIntegrationRequest
	*/
	IntegrationsControllerArchiveIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerArchiveIntegrationRequest

	// IntegrationsControllerArchiveIntegrationExecute executes the request
	IntegrationsControllerArchiveIntegrationExecute(r ApiIntegrationsControllerArchiveIntegrationRequest) (*http.Response, error)

	/*
	IntegrationsControllerCreateIntegration Create integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIntegrationsControllerCreateIntegrationRequest
	*/
	IntegrationsControllerCreateIntegration(ctx context.Context) ApiIntegrationsControllerCreateIntegrationRequest

	// IntegrationsControllerCreateIntegrationExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerCreateIntegrationExecute(r ApiIntegrationsControllerCreateIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	IntegrationsControllerGetConnectorSpec Get integration connector spec

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetConnectorSpecRequest
	*/
	IntegrationsControllerGetConnectorSpec(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetConnectorSpecRequest

	// IntegrationsControllerGetConnectorSpecExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetConnectorSpecExecute(r ApiIntegrationsControllerGetConnectorSpecRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegration Get integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationRequest
	*/
	IntegrationsControllerGetIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationRequest

	// IntegrationsControllerGetIntegrationExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerGetIntegrationExecute(r ApiIntegrationsControllerGetIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationDataCollectionSpecs List integration data collection specs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest
	*/
	IntegrationsControllerGetIntegrationDataCollectionSpecs(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest

	// IntegrationsControllerGetIntegrationDataCollectionSpecsExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationDataCollectionSpecsExecute(r ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationDataLocationByKey Get integration data location

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param dataLocationKey
	@return ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest
	*/
	IntegrationsControllerGetIntegrationDataLocationByKey(ctx context.Context, idOrKey string, dataLocationKey string) ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest

	// IntegrationsControllerGetIntegrationDataLocationByKeyExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetIntegrationDataLocationByKeyExecute(r ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationDataLocations List integration data locations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationDataLocationsRequest
	*/
	IntegrationsControllerGetIntegrationDataLocations(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDataLocationsRequest

	// IntegrationsControllerGetIntegrationDataLocationsExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationDataLocationsExecute(r ApiIntegrationsControllerGetIntegrationDataLocationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationDocumentation Get integration connector documentation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationDocumentationRequest
	*/
	IntegrationsControllerGetIntegrationDocumentation(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDocumentationRequest

	// IntegrationsControllerGetIntegrationDocumentationExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetIntegrationDocumentationExecute(r ApiIntegrationsControllerGetIntegrationDocumentationRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationEventByKey Get integration event

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param eventKey
	@return ApiIntegrationsControllerGetIntegrationEventByKeyRequest
	*/
	IntegrationsControllerGetIntegrationEventByKey(ctx context.Context, idOrKey string, eventKey string) ApiIntegrationsControllerGetIntegrationEventByKeyRequest

	// IntegrationsControllerGetIntegrationEventByKeyExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetIntegrationEventByKeyExecute(r ApiIntegrationsControllerGetIntegrationEventByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationEvents List integration events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationEventsRequest
	*/
	IntegrationsControllerGetIntegrationEvents(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationEventsRequest

	// IntegrationsControllerGetIntegrationEventsExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationEventsExecute(r ApiIntegrationsControllerGetIntegrationEventsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationGlobalWebhooks List integration global webhooks

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest
	*/
	IntegrationsControllerGetIntegrationGlobalWebhooks(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest

	// IntegrationsControllerGetIntegrationGlobalWebhooksExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationGlobalWebhooksExecute(r ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationOperationByKey Get integration operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param operationKey
	@return ApiIntegrationsControllerGetIntegrationOperationByKeyRequest
	*/
	IntegrationsControllerGetIntegrationOperationByKey(ctx context.Context, idOrKey string, operationKey string) ApiIntegrationsControllerGetIntegrationOperationByKeyRequest

	// IntegrationsControllerGetIntegrationOperationByKeyExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetIntegrationOperationByKeyExecute(r ApiIntegrationsControllerGetIntegrationOperationByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationOperations List integration operations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationOperationsRequest
	*/
	IntegrationsControllerGetIntegrationOperations(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationOperationsRequest

	// IntegrationsControllerGetIntegrationOperationsExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationOperationsExecute(r ApiIntegrationsControllerGetIntegrationOperationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationUdmByKey Get integration UDM

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param udmKey
	@return ApiIntegrationsControllerGetIntegrationUdmByKeyRequest
	*/
	IntegrationsControllerGetIntegrationUdmByKey(ctx context.Context, idOrKey string, udmKey string) ApiIntegrationsControllerGetIntegrationUdmByKeyRequest

	// IntegrationsControllerGetIntegrationUdmByKeyExecute executes the request
	//  @return map[string]interface{}
	IntegrationsControllerGetIntegrationUdmByKeyExecute(r ApiIntegrationsControllerGetIntegrationUdmByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerGetIntegrationUdms List integration UDMs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerGetIntegrationUdmsRequest
	*/
	IntegrationsControllerGetIntegrationUdms(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationUdmsRequest

	// IntegrationsControllerGetIntegrationUdmsExecute executes the request
	//  @return []map[string]interface{}
	IntegrationsControllerGetIntegrationUdmsExecute(r ApiIntegrationsControllerGetIntegrationUdmsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	IntegrationsControllerListIntegrations List integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiIntegrationsControllerListIntegrationsRequest
	*/
	IntegrationsControllerListIntegrations(ctx context.Context) ApiIntegrationsControllerListIntegrationsRequest

	// IntegrationsControllerListIntegrationsExecute executes the request
	//  @return IntegrationsControllerListIntegrations200Response
	IntegrationsControllerListIntegrationsExecute(r ApiIntegrationsControllerListIntegrationsRequest) (*IntegrationsControllerListIntegrations200Response, *http.Response, error)

	/*
	IntegrationsControllerPatchIntegration Patch integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerPatchIntegrationRequest
	*/
	IntegrationsControllerPatchIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerPatchIntegrationRequest

	// IntegrationsControllerPatchIntegrationExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerPatchIntegrationExecute(r ApiIntegrationsControllerPatchIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	IntegrationsControllerPutIntegration Update integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerPutIntegrationRequest
	*/
	IntegrationsControllerPutIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerPutIntegrationRequest

	// IntegrationsControllerPutIntegrationExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerPutIntegrationExecute(r ApiIntegrationsControllerPutIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	IntegrationsControllerSetupIntegration Setup integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerSetupIntegrationRequest
	*/
	IntegrationsControllerSetupIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerSetupIntegrationRequest

	// IntegrationsControllerSetupIntegrationExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerSetupIntegrationExecute(r ApiIntegrationsControllerSetupIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	IntegrationsControllerUploadConnector Upload integration connector

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiIntegrationsControllerUploadConnectorRequest
	*/
	IntegrationsControllerUploadConnector(ctx context.Context, idOrKey string) ApiIntegrationsControllerUploadConnectorRequest

	// IntegrationsControllerUploadConnectorExecute executes the request
	//  @return IntegrationDto
	IntegrationsControllerUploadConnectorExecute(r ApiIntegrationsControllerUploadConnectorRequest) (*IntegrationDto, *http.Response, error)
}

// IntegrationsAPIService IntegrationsAPI service
type IntegrationsAPIService service

type ApiIntegrationsControllerArchiveIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerArchiveIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationsControllerArchiveIntegrationExecute(r)
}

/*
IntegrationsControllerArchiveIntegration Archive integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerArchiveIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerArchiveIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerArchiveIntegrationRequest {
	return ApiIntegrationsControllerArchiveIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
func (a *IntegrationsAPIService) IntegrationsControllerArchiveIntegrationExecute(r ApiIntegrationsControllerArchiveIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerArchiveIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationsControllerCreateIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	createIntegrationDto *CreateIntegrationDto
}

func (r ApiIntegrationsControllerCreateIntegrationRequest) CreateIntegrationDto(createIntegrationDto CreateIntegrationDto) ApiIntegrationsControllerCreateIntegrationRequest {
	r.createIntegrationDto = &createIntegrationDto
	return r
}

func (r ApiIntegrationsControllerCreateIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerCreateIntegrationExecute(r)
}

/*
IntegrationsControllerCreateIntegration Create integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsControllerCreateIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerCreateIntegration(ctx context.Context) ApiIntegrationsControllerCreateIntegrationRequest {
	return ApiIntegrationsControllerCreateIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerCreateIntegrationExecute(r ApiIntegrationsControllerCreateIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerCreateIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetConnectorSpecRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetConnectorSpecRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetConnectorSpecExecute(r)
}

/*
IntegrationsControllerGetConnectorSpec Get integration connector spec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetConnectorSpecRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetConnectorSpec(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetConnectorSpecRequest {
	return ApiIntegrationsControllerGetConnectorSpecRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetConnectorSpecExecute(r ApiIntegrationsControllerGetConnectorSpecRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetConnectorSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/connector-spec"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationExecute(r)
}

/*
IntegrationsControllerGetIntegration Get integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationRequest {
	return ApiIntegrationsControllerGetIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationExecute(r ApiIntegrationsControllerGetIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationDataCollectionSpecsExecute(r)
}

/*
IntegrationsControllerGetIntegrationDataCollectionSpecs List integration data collection specs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataCollectionSpecs(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest {
	return ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataCollectionSpecsExecute(r ApiIntegrationsControllerGetIntegrationDataCollectionSpecsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationDataCollectionSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data-collection-specs"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	dataLocationKey string
}

func (r ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationDataLocationByKeyExecute(r)
}

/*
IntegrationsControllerGetIntegrationDataLocationByKey Get integration data location

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param dataLocationKey
 @return ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataLocationByKey(ctx context.Context, idOrKey string, dataLocationKey string) ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest {
	return ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		dataLocationKey: dataLocationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataLocationByKeyExecute(r ApiIntegrationsControllerGetIntegrationDataLocationByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationDataLocationByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data/{dataLocationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationDataLocationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationDataLocationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationDataLocationsExecute(r)
}

/*
IntegrationsControllerGetIntegrationDataLocations List integration data locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationDataLocationsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataLocations(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDataLocationsRequest {
	return ApiIntegrationsControllerGetIntegrationDataLocationsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDataLocationsExecute(r ApiIntegrationsControllerGetIntegrationDataLocationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationDataLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationDocumentationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationDocumentationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationDocumentationExecute(r)
}

/*
IntegrationsControllerGetIntegrationDocumentation Get integration connector documentation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationDocumentationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDocumentation(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationDocumentationRequest {
	return ApiIntegrationsControllerGetIntegrationDocumentationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationDocumentationExecute(r ApiIntegrationsControllerGetIntegrationDocumentationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationDocumentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/documentation"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationEventByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	eventKey string
}

func (r ApiIntegrationsControllerGetIntegrationEventByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationEventByKeyExecute(r)
}

/*
IntegrationsControllerGetIntegrationEventByKey Get integration event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param eventKey
 @return ApiIntegrationsControllerGetIntegrationEventByKeyRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationEventByKey(ctx context.Context, idOrKey string, eventKey string) ApiIntegrationsControllerGetIntegrationEventByKeyRequest {
	return ApiIntegrationsControllerGetIntegrationEventByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		eventKey: eventKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationEventByKeyExecute(r ApiIntegrationsControllerGetIntegrationEventByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationEventByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/events/{eventKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventKey"+"}", url.PathEscape(parameterValueToString(r.eventKey, "eventKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationEventsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationEventsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationEventsExecute(r)
}

/*
IntegrationsControllerGetIntegrationEvents List integration events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationEventsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationEvents(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationEventsRequest {
	return ApiIntegrationsControllerGetIntegrationEventsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationEventsExecute(r ApiIntegrationsControllerGetIntegrationEventsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationGlobalWebhooksExecute(r)
}

/*
IntegrationsControllerGetIntegrationGlobalWebhooks List integration global webhooks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationGlobalWebhooks(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest {
	return ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationGlobalWebhooksExecute(r ApiIntegrationsControllerGetIntegrationGlobalWebhooksRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationGlobalWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/global-webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationOperationByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	operationKey string
}

func (r ApiIntegrationsControllerGetIntegrationOperationByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationOperationByKeyExecute(r)
}

/*
IntegrationsControllerGetIntegrationOperationByKey Get integration operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param operationKey
 @return ApiIntegrationsControllerGetIntegrationOperationByKeyRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationOperationByKey(ctx context.Context, idOrKey string, operationKey string) ApiIntegrationsControllerGetIntegrationOperationByKeyRequest {
	return ApiIntegrationsControllerGetIntegrationOperationByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationOperationByKeyExecute(r ApiIntegrationsControllerGetIntegrationOperationByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationOperationByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/operations/{operationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationOperationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationOperationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationOperationsExecute(r)
}

/*
IntegrationsControllerGetIntegrationOperations List integration operations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationOperationsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationOperations(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationOperationsRequest {
	return ApiIntegrationsControllerGetIntegrationOperationsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationOperationsExecute(r ApiIntegrationsControllerGetIntegrationOperationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationUdmByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	udmKey string
}

func (r ApiIntegrationsControllerGetIntegrationUdmByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationUdmByKeyExecute(r)
}

/*
IntegrationsControllerGetIntegrationUdmByKey Get integration UDM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param udmKey
 @return ApiIntegrationsControllerGetIntegrationUdmByKeyRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationUdmByKey(ctx context.Context, idOrKey string, udmKey string) ApiIntegrationsControllerGetIntegrationUdmByKeyRequest {
	return ApiIntegrationsControllerGetIntegrationUdmByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		udmKey: udmKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationUdmByKeyExecute(r ApiIntegrationsControllerGetIntegrationUdmByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationUdmByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/udm/{udmKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"udmKey"+"}", url.PathEscape(parameterValueToString(r.udmKey, "udmKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerGetIntegrationUdmsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerGetIntegrationUdmsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationsControllerGetIntegrationUdmsExecute(r)
}

/*
IntegrationsControllerGetIntegrationUdms List integration UDMs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerGetIntegrationUdmsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationUdms(ctx context.Context, idOrKey string) ApiIntegrationsControllerGetIntegrationUdmsRequest {
	return ApiIntegrationsControllerGetIntegrationUdmsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) IntegrationsControllerGetIntegrationUdmsExecute(r ApiIntegrationsControllerGetIntegrationUdmsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerGetIntegrationUdms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/udm"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerListIntegrationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
}

func (r ApiIntegrationsControllerListIntegrationsRequest) Limit(limit float32) ApiIntegrationsControllerListIntegrationsRequest {
	r.limit = &limit
	return r
}

func (r ApiIntegrationsControllerListIntegrationsRequest) Cursor(cursor string) ApiIntegrationsControllerListIntegrationsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiIntegrationsControllerListIntegrationsRequest) Search(search string) ApiIntegrationsControllerListIntegrationsRequest {
	r.search = &search
	return r
}

func (r ApiIntegrationsControllerListIntegrationsRequest) ConnectorId(connectorId string) ApiIntegrationsControllerListIntegrationsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiIntegrationsControllerListIntegrationsRequest) IncludeArchived(includeArchived bool) ApiIntegrationsControllerListIntegrationsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiIntegrationsControllerListIntegrationsRequest) Execute() (*IntegrationsControllerListIntegrations200Response, *http.Response, error) {
	return r.ApiService.IntegrationsControllerListIntegrationsExecute(r)
}

/*
IntegrationsControllerListIntegrations List integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntegrationsControllerListIntegrationsRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerListIntegrations(ctx context.Context) ApiIntegrationsControllerListIntegrationsRequest {
	return ApiIntegrationsControllerListIntegrationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IntegrationsControllerListIntegrations200Response
func (a *IntegrationsAPIService) IntegrationsControllerListIntegrationsExecute(r ApiIntegrationsControllerListIntegrationsRequest) (*IntegrationsControllerListIntegrations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationsControllerListIntegrations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerListIntegrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerPatchIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	updateIntegrationDto *UpdateIntegrationDto
}

func (r ApiIntegrationsControllerPatchIntegrationRequest) UpdateIntegrationDto(updateIntegrationDto UpdateIntegrationDto) ApiIntegrationsControllerPatchIntegrationRequest {
	r.updateIntegrationDto = &updateIntegrationDto
	return r
}

func (r ApiIntegrationsControllerPatchIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerPatchIntegrationExecute(r)
}

/*
IntegrationsControllerPatchIntegration Patch integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerPatchIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerPatchIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerPatchIntegrationRequest {
	return ApiIntegrationsControllerPatchIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerPatchIntegrationExecute(r ApiIntegrationsControllerPatchIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerPatchIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("updateIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerPutIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	createIntegrationDto *CreateIntegrationDto
}

func (r ApiIntegrationsControllerPutIntegrationRequest) CreateIntegrationDto(createIntegrationDto CreateIntegrationDto) ApiIntegrationsControllerPutIntegrationRequest {
	r.createIntegrationDto = &createIntegrationDto
	return r
}

func (r ApiIntegrationsControllerPutIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerPutIntegrationExecute(r)
}

/*
IntegrationsControllerPutIntegration Update integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerPutIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerPutIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerPutIntegrationRequest {
	return ApiIntegrationsControllerPutIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerPutIntegrationExecute(r ApiIntegrationsControllerPutIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerPutIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerSetupIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerSetupIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerSetupIntegrationExecute(r)
}

/*
IntegrationsControllerSetupIntegration Setup integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerSetupIntegrationRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerSetupIntegration(ctx context.Context, idOrKey string) ApiIntegrationsControllerSetupIntegrationRequest {
	return ApiIntegrationsControllerSetupIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerSetupIntegrationExecute(r ApiIntegrationsControllerSetupIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerSetupIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationsControllerUploadConnectorRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiIntegrationsControllerUploadConnectorRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.IntegrationsControllerUploadConnectorExecute(r)
}

/*
IntegrationsControllerUploadConnector Upload integration connector

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiIntegrationsControllerUploadConnectorRequest
*/
func (a *IntegrationsAPIService) IntegrationsControllerUploadConnector(ctx context.Context, idOrKey string) ApiIntegrationsControllerUploadConnectorRequest {
	return ApiIntegrationsControllerUploadConnectorRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) IntegrationsControllerUploadConnectorExecute(r ApiIntegrationsControllerUploadConnectorRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.IntegrationsControllerUploadConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/upload-connector"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
