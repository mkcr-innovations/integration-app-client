/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type IntegrationsAPI interface {

	/*
	ArchiveIntegration Method for ArchiveIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param isOrKey
	@return ApiArchiveIntegrationRequest
	*/
	ArchiveIntegration(ctx context.Context, isOrKey string) ApiArchiveIntegrationRequest

	// ArchiveIntegrationExecute executes the request
	ArchiveIntegrationExecute(r ApiArchiveIntegrationRequest) (*http.Response, error)

	/*
	CreateIntegration Method for CreateIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateIntegrationRequest
	*/
	CreateIntegration(ctx context.Context) ApiCreateIntegrationRequest

	// CreateIntegrationExecute executes the request
	//  @return IntegrationDto
	CreateIntegrationExecute(r ApiCreateIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	DisconnectIntegration Method for DisconnectIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiDisconnectIntegrationRequest
	*/
	DisconnectIntegration(ctx context.Context, idOrKey string) ApiDisconnectIntegrationRequest

	// DisconnectIntegrationExecute executes the request
	DisconnectIntegrationExecute(r ApiDisconnectIntegrationRequest) (*http.Response, error)

	/*
	GetConnectorSpec Method for GetConnectorSpec

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetConnectorSpecRequest
	*/
	GetConnectorSpec(ctx context.Context, idOrKey string) ApiGetConnectorSpecRequest

	// GetConnectorSpecExecute executes the request
	//  @return map[string]interface{}
	GetConnectorSpecExecute(r ApiGetConnectorSpecRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegration Method for GetIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationRequest
	*/
	GetIntegration(ctx context.Context, idOrKey string) ApiGetIntegrationRequest

	// GetIntegrationExecute executes the request
	//  @return IntegrationDto
	GetIntegrationExecute(r ApiGetIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	GetIntegrationDataCollectionSpecs Method for GetIntegrationDataCollectionSpecs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationDataCollectionSpecsRequest
	*/
	GetIntegrationDataCollectionSpecs(ctx context.Context, idOrKey string) ApiGetIntegrationDataCollectionSpecsRequest

	// GetIntegrationDataCollectionSpecsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationDataCollectionSpecsExecute(r ApiGetIntegrationDataCollectionSpecsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationDataLocationByKey Method for GetIntegrationDataLocationByKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param dataLocationKey
	@return ApiGetIntegrationDataLocationByKeyRequest
	*/
	GetIntegrationDataLocationByKey(ctx context.Context, idOrKey string, dataLocationKey string) ApiGetIntegrationDataLocationByKeyRequest

	// GetIntegrationDataLocationByKeyExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationDataLocationByKeyExecute(r ApiGetIntegrationDataLocationByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationDataLocations Method for GetIntegrationDataLocations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationDataLocationsRequest
	*/
	GetIntegrationDataLocations(ctx context.Context, idOrKey string) ApiGetIntegrationDataLocationsRequest

	// GetIntegrationDataLocationsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationDataLocationsExecute(r ApiGetIntegrationDataLocationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationDocumentation Method for GetIntegrationDocumentation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationDocumentationRequest
	*/
	GetIntegrationDocumentation(ctx context.Context, idOrKey string) ApiGetIntegrationDocumentationRequest

	// GetIntegrationDocumentationExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationDocumentationExecute(r ApiGetIntegrationDocumentationRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationEventByKey Method for GetIntegrationEventByKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param eventKey
	@return ApiGetIntegrationEventByKeyRequest
	*/
	GetIntegrationEventByKey(ctx context.Context, idOrKey string, eventKey string) ApiGetIntegrationEventByKeyRequest

	// GetIntegrationEventByKeyExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationEventByKeyExecute(r ApiGetIntegrationEventByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationEvents Method for GetIntegrationEvents

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationEventsRequest
	*/
	GetIntegrationEvents(ctx context.Context, idOrKey string) ApiGetIntegrationEventsRequest

	// GetIntegrationEventsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationEventsExecute(r ApiGetIntegrationEventsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationFlowNodes Method for GetIntegrationFlowNodes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationFlowNodesRequest
	*/
	GetIntegrationFlowNodes(ctx context.Context, idOrKey string) ApiGetIntegrationFlowNodesRequest

	// GetIntegrationFlowNodesExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationFlowNodesExecute(r ApiGetIntegrationFlowNodesRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationOpenapiOperation Method for GetIntegrationOpenapiOperation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOpenapiOperationRequest
	*/
	GetIntegrationOpenapiOperation(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiOperationRequest

	// GetIntegrationOpenapiOperationExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationOpenapiOperationExecute(r ApiGetIntegrationOpenapiOperationRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationOpenapiPathMethods Method for GetIntegrationOpenapiPathMethods

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOpenapiPathMethodsRequest
	*/
	GetIntegrationOpenapiPathMethods(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiPathMethodsRequest

	// GetIntegrationOpenapiPathMethodsExecute executes the request
	//  @return []string
	GetIntegrationOpenapiPathMethodsExecute(r ApiGetIntegrationOpenapiPathMethodsRequest) ([]string, *http.Response, error)

	/*
	GetIntegrationOpenapiPaths Method for GetIntegrationOpenapiPaths

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOpenapiPathsRequest
	*/
	GetIntegrationOpenapiPaths(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiPathsRequest

	// GetIntegrationOpenapiPathsExecute executes the request
	//  @return []string
	GetIntegrationOpenapiPathsExecute(r ApiGetIntegrationOpenapiPathsRequest) ([]string, *http.Response, error)

	/*
	GetIntegrationOpenapiRequests Method for GetIntegrationOpenapiRequests

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOpenapiRequestsRequest
	*/
	GetIntegrationOpenapiRequests(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiRequestsRequest

	// GetIntegrationOpenapiRequestsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationOpenapiRequestsExecute(r ApiGetIntegrationOpenapiRequestsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationOpenapiResponseSchema Method for GetIntegrationOpenapiResponseSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOpenapiResponseSchemaRequest
	*/
	GetIntegrationOpenapiResponseSchema(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiResponseSchemaRequest

	// GetIntegrationOpenapiResponseSchemaExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationOpenapiResponseSchemaExecute(r ApiGetIntegrationOpenapiResponseSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationOperationByKey Method for GetIntegrationOperationByKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param operationKey
	@return ApiGetIntegrationOperationByKeyRequest
	*/
	GetIntegrationOperationByKey(ctx context.Context, idOrKey string, operationKey string) ApiGetIntegrationOperationByKeyRequest

	// GetIntegrationOperationByKeyExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationOperationByKeyExecute(r ApiGetIntegrationOperationByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationOperations Method for GetIntegrationOperations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationOperationsRequest
	*/
	GetIntegrationOperations(ctx context.Context, idOrKey string) ApiGetIntegrationOperationsRequest

	// GetIntegrationOperationsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationOperationsExecute(r ApiGetIntegrationOperationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationUdmByKey Method for GetIntegrationUdmByKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@param udmKey
	@return ApiGetIntegrationUdmByKeyRequest
	*/
	GetIntegrationUdmByKey(ctx context.Context, idOrKey string, udmKey string) ApiGetIntegrationUdmByKeyRequest

	// GetIntegrationUdmByKeyExecute executes the request
	//  @return map[string]interface{}
	GetIntegrationUdmByKeyExecute(r ApiGetIntegrationUdmByKeyRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetIntegrationUdms Method for GetIntegrationUdms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiGetIntegrationUdmsRequest
	*/
	GetIntegrationUdms(ctx context.Context, idOrKey string) ApiGetIntegrationUdmsRequest

	// GetIntegrationUdmsExecute executes the request
	//  @return []map[string]interface{}
	GetIntegrationUdmsExecute(r ApiGetIntegrationUdmsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	ListIntegrations Method for ListIntegrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListIntegrationsRequest
	*/
	ListIntegrations(ctx context.Context) ApiListIntegrationsRequest

	// ListIntegrationsExecute executes the request
	//  @return ListIntegrations200Response
	ListIntegrationsExecute(r ApiListIntegrationsRequest) (*ListIntegrations200Response, *http.Response, error)

	/*
	PatchIntegration Method for PatchIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiPatchIntegrationRequest
	*/
	PatchIntegration(ctx context.Context, idOrKey string) ApiPatchIntegrationRequest

	// PatchIntegrationExecute executes the request
	//  @return IntegrationDto
	PatchIntegrationExecute(r ApiPatchIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	PublishConnectorToIntegration Method for PublishConnectorToIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiPublishConnectorToIntegrationRequest
	*/
	PublishConnectorToIntegration(ctx context.Context, idOrKey string) ApiPublishConnectorToIntegrationRequest

	// PublishConnectorToIntegrationExecute executes the request
	//  @return IntegrationDto
	PublishConnectorToIntegrationExecute(r ApiPublishConnectorToIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	PutIntegration Method for PutIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiPutIntegrationRequest
	*/
	PutIntegration(ctx context.Context, idOrKey string) ApiPutIntegrationRequest

	// PutIntegrationExecute executes the request
	//  @return IntegrationDto
	PutIntegrationExecute(r ApiPutIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	ReUploadIntegration Method for ReUploadIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiReUploadIntegrationRequest
	*/
	ReUploadIntegration(ctx context.Context, id string) ApiReUploadIntegrationRequest

	// ReUploadIntegrationExecute executes the request
	//  @return IntegrationDto
	ReUploadIntegrationExecute(r ApiReUploadIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	ResetParameters Method for ResetParameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiResetParametersRequest
	*/
	ResetParameters(ctx context.Context, idOrKey string) ApiResetParametersRequest

	// ResetParametersExecute executes the request
	//  @return IntegrationDto
	ResetParametersExecute(r ApiResetParametersRequest) (*IntegrationDto, *http.Response, error)

	/*
	SetupIntegration Method for SetupIntegration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiSetupIntegrationRequest
	*/
	SetupIntegration(ctx context.Context, idOrKey string) ApiSetupIntegrationRequest

	// SetupIntegrationExecute executes the request
	//  @return IntegrationDto
	SetupIntegrationExecute(r ApiSetupIntegrationRequest) (*IntegrationDto, *http.Response, error)

	/*
	UpdateIntegrationConnector Method for UpdateIntegrationConnector

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idOrKey
	@return ApiUpdateIntegrationConnectorRequest
	*/
	UpdateIntegrationConnector(ctx context.Context, idOrKey string) ApiUpdateIntegrationConnectorRequest

	// UpdateIntegrationConnectorExecute executes the request
	//  @return IntegrationDto
	UpdateIntegrationConnectorExecute(r ApiUpdateIntegrationConnectorRequest) (*IntegrationDto, *http.Response, error)
}

// IntegrationsAPIService IntegrationsAPI service
type IntegrationsAPIService service

type ApiArchiveIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	isOrKey string
}

func (r ApiArchiveIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveIntegrationExecute(r)
}

/*
ArchiveIntegration Method for ArchiveIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param isOrKey
 @return ApiArchiveIntegrationRequest
*/
func (a *IntegrationsAPIService) ArchiveIntegration(ctx context.Context, isOrKey string) ApiArchiveIntegrationRequest {
	return ApiArchiveIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		isOrKey: isOrKey,
	}
}

// Execute executes the request
func (a *IntegrationsAPIService) ArchiveIntegrationExecute(r ApiArchiveIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.ArchiveIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{isOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"isOrKey"+"}", url.PathEscape(parameterValueToString(r.isOrKey, "isOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	createIntegrationDto *CreateIntegrationDto
}

func (r ApiCreateIntegrationRequest) CreateIntegrationDto(createIntegrationDto CreateIntegrationDto) ApiCreateIntegrationRequest {
	r.createIntegrationDto = &createIntegrationDto
	return r
}

func (r ApiCreateIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.CreateIntegrationExecute(r)
}

/*
CreateIntegration Method for CreateIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIntegrationRequest
*/
func (a *IntegrationsAPIService) CreateIntegration(ctx context.Context) ApiCreateIntegrationRequest {
	return ApiCreateIntegrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) CreateIntegrationExecute(r ApiCreateIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.CreateIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDisconnectIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiDisconnectIntegrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisconnectIntegrationExecute(r)
}

/*
DisconnectIntegration Method for DisconnectIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiDisconnectIntegrationRequest
*/
func (a *IntegrationsAPIService) DisconnectIntegration(ctx context.Context, idOrKey string) ApiDisconnectIntegrationRequest {
	return ApiDisconnectIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
func (a *IntegrationsAPIService) DisconnectIntegrationExecute(r ApiDisconnectIntegrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.DisconnectIntegration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/disconnect"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConnectorSpecRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetConnectorSpecRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetConnectorSpecExecute(r)
}

/*
GetConnectorSpec Method for GetConnectorSpec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetConnectorSpecRequest
*/
func (a *IntegrationsAPIService) GetConnectorSpec(ctx context.Context, idOrKey string) ApiGetConnectorSpecRequest {
	return ApiGetConnectorSpecRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetConnectorSpecExecute(r ApiGetConnectorSpecRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetConnectorSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/connector-spec"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.GetIntegrationExecute(r)
}

/*
GetIntegration Method for GetIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationRequest
*/
func (a *IntegrationsAPIService) GetIntegration(ctx context.Context, idOrKey string) ApiGetIntegrationRequest {
	return ApiGetIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) GetIntegrationExecute(r ApiGetIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationDataCollectionSpecsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationDataCollectionSpecsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationDataCollectionSpecsExecute(r)
}

/*
GetIntegrationDataCollectionSpecs Method for GetIntegrationDataCollectionSpecs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationDataCollectionSpecsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationDataCollectionSpecs(ctx context.Context, idOrKey string) ApiGetIntegrationDataCollectionSpecsRequest {
	return ApiGetIntegrationDataCollectionSpecsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationDataCollectionSpecsExecute(r ApiGetIntegrationDataCollectionSpecsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationDataCollectionSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data-collection-specs"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationDataLocationByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	dataLocationKey string
}

func (r ApiGetIntegrationDataLocationByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationDataLocationByKeyExecute(r)
}

/*
GetIntegrationDataLocationByKey Method for GetIntegrationDataLocationByKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param dataLocationKey
 @return ApiGetIntegrationDataLocationByKeyRequest
*/
func (a *IntegrationsAPIService) GetIntegrationDataLocationByKey(ctx context.Context, idOrKey string, dataLocationKey string) ApiGetIntegrationDataLocationByKeyRequest {
	return ApiGetIntegrationDataLocationByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		dataLocationKey: dataLocationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationDataLocationByKeyExecute(r ApiGetIntegrationDataLocationByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationDataLocationByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data/{dataLocationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationDataLocationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationDataLocationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationDataLocationsExecute(r)
}

/*
GetIntegrationDataLocations Method for GetIntegrationDataLocations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationDataLocationsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationDataLocations(ctx context.Context, idOrKey string) ApiGetIntegrationDataLocationsRequest {
	return ApiGetIntegrationDataLocationsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationDataLocationsExecute(r ApiGetIntegrationDataLocationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationDataLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationDocumentationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationDocumentationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationDocumentationExecute(r)
}

/*
GetIntegrationDocumentation Method for GetIntegrationDocumentation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationDocumentationRequest
*/
func (a *IntegrationsAPIService) GetIntegrationDocumentation(ctx context.Context, idOrKey string) ApiGetIntegrationDocumentationRequest {
	return ApiGetIntegrationDocumentationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationDocumentationExecute(r ApiGetIntegrationDocumentationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationDocumentation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/documentation"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationEventByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	eventKey string
}

func (r ApiGetIntegrationEventByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationEventByKeyExecute(r)
}

/*
GetIntegrationEventByKey Method for GetIntegrationEventByKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param eventKey
 @return ApiGetIntegrationEventByKeyRequest
*/
func (a *IntegrationsAPIService) GetIntegrationEventByKey(ctx context.Context, idOrKey string, eventKey string) ApiGetIntegrationEventByKeyRequest {
	return ApiGetIntegrationEventByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		eventKey: eventKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationEventByKeyExecute(r ApiGetIntegrationEventByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationEventByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/events/{eventKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventKey"+"}", url.PathEscape(parameterValueToString(r.eventKey, "eventKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationEventsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationEventsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationEventsExecute(r)
}

/*
GetIntegrationEvents Method for GetIntegrationEvents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationEventsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationEvents(ctx context.Context, idOrKey string) ApiGetIntegrationEventsRequest {
	return ApiGetIntegrationEventsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationEventsExecute(r ApiGetIntegrationEventsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationFlowNodesRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationFlowNodesRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationFlowNodesExecute(r)
}

/*
GetIntegrationFlowNodes Method for GetIntegrationFlowNodes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationFlowNodesRequest
*/
func (a *IntegrationsAPIService) GetIntegrationFlowNodes(ctx context.Context, idOrKey string) ApiGetIntegrationFlowNodesRequest {
	return ApiGetIntegrationFlowNodesRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationFlowNodesExecute(r ApiGetIntegrationFlowNodesRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationFlowNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/flow-nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOpenapiOperationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	path *string
	method *string
}

func (r ApiGetIntegrationOpenapiOperationRequest) Path(path string) ApiGetIntegrationOpenapiOperationRequest {
	r.path = &path
	return r
}

func (r ApiGetIntegrationOpenapiOperationRequest) Method(method string) ApiGetIntegrationOpenapiOperationRequest {
	r.method = &method
	return r
}

func (r ApiGetIntegrationOpenapiOperationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationOpenapiOperationExecute(r)
}

/*
GetIntegrationOpenapiOperation Method for GetIntegrationOpenapiOperation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOpenapiOperationRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOpenapiOperation(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiOperationRequest {
	return ApiGetIntegrationOpenapiOperationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationOpenapiOperationExecute(r ApiGetIntegrationOpenapiOperationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOpenapiOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/openapi/request-schema"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.method == nil {
		return localVarReturnValue, nil, reportError("method is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOpenapiPathMethodsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	path *string
}

func (r ApiGetIntegrationOpenapiPathMethodsRequest) Path(path string) ApiGetIntegrationOpenapiPathMethodsRequest {
	r.path = &path
	return r
}

func (r ApiGetIntegrationOpenapiPathMethodsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetIntegrationOpenapiPathMethodsExecute(r)
}

/*
GetIntegrationOpenapiPathMethods Method for GetIntegrationOpenapiPathMethods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOpenapiPathMethodsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOpenapiPathMethods(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiPathMethodsRequest {
	return ApiGetIntegrationOpenapiPathMethodsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []string
func (a *IntegrationsAPIService) GetIntegrationOpenapiPathMethodsExecute(r ApiGetIntegrationOpenapiPathMethodsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOpenapiPathMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/openapi/path-methods"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOpenapiPathsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationOpenapiPathsRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetIntegrationOpenapiPathsExecute(r)
}

/*
GetIntegrationOpenapiPaths Method for GetIntegrationOpenapiPaths

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOpenapiPathsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOpenapiPaths(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiPathsRequest {
	return ApiGetIntegrationOpenapiPathsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []string
func (a *IntegrationsAPIService) GetIntegrationOpenapiPathsExecute(r ApiGetIntegrationOpenapiPathsRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOpenapiPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/openapi/paths"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOpenapiRequestsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationOpenapiRequestsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationOpenapiRequestsExecute(r)
}

/*
GetIntegrationOpenapiRequests Method for GetIntegrationOpenapiRequests

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOpenapiRequestsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOpenapiRequests(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiRequestsRequest {
	return ApiGetIntegrationOpenapiRequestsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationOpenapiRequestsExecute(r ApiGetIntegrationOpenapiRequestsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOpenapiRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/openapi/request-specs"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOpenapiResponseSchemaRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	path *string
	method *string
}

func (r ApiGetIntegrationOpenapiResponseSchemaRequest) Path(path string) ApiGetIntegrationOpenapiResponseSchemaRequest {
	r.path = &path
	return r
}

func (r ApiGetIntegrationOpenapiResponseSchemaRequest) Method(method string) ApiGetIntegrationOpenapiResponseSchemaRequest {
	r.method = &method
	return r
}

func (r ApiGetIntegrationOpenapiResponseSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationOpenapiResponseSchemaExecute(r)
}

/*
GetIntegrationOpenapiResponseSchema Method for GetIntegrationOpenapiResponseSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOpenapiResponseSchemaRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOpenapiResponseSchema(ctx context.Context, idOrKey string) ApiGetIntegrationOpenapiResponseSchemaRequest {
	return ApiGetIntegrationOpenapiResponseSchemaRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationOpenapiResponseSchemaExecute(r ApiGetIntegrationOpenapiResponseSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOpenapiResponseSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/openapi/response-schema"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.method == nil {
		return localVarReturnValue, nil, reportError("method is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "method", r.method, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOperationByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	operationKey string
}

func (r ApiGetIntegrationOperationByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationOperationByKeyExecute(r)
}

/*
GetIntegrationOperationByKey Method for GetIntegrationOperationByKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param operationKey
 @return ApiGetIntegrationOperationByKeyRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOperationByKey(ctx context.Context, idOrKey string, operationKey string) ApiGetIntegrationOperationByKeyRequest {
	return ApiGetIntegrationOperationByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationOperationByKeyExecute(r ApiGetIntegrationOperationByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOperationByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/operations/{operationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationOperationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationOperationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationOperationsExecute(r)
}

/*
GetIntegrationOperations Method for GetIntegrationOperations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationOperationsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationOperations(ctx context.Context, idOrKey string) ApiGetIntegrationOperationsRequest {
	return ApiGetIntegrationOperationsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationOperationsExecute(r ApiGetIntegrationOperationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationUdmByKeyRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	udmKey string
}

func (r ApiGetIntegrationUdmByKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationUdmByKeyExecute(r)
}

/*
GetIntegrationUdmByKey Method for GetIntegrationUdmByKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @param udmKey
 @return ApiGetIntegrationUdmByKeyRequest
*/
func (a *IntegrationsAPIService) GetIntegrationUdmByKey(ctx context.Context, idOrKey string, udmKey string) ApiGetIntegrationUdmByKeyRequest {
	return ApiGetIntegrationUdmByKeyRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
		udmKey: udmKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationUdmByKeyExecute(r ApiGetIntegrationUdmByKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationUdmByKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/udm/{udmKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"udmKey"+"}", url.PathEscape(parameterValueToString(r.udmKey, "udmKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIntegrationUdmsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiGetIntegrationUdmsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetIntegrationUdmsExecute(r)
}

/*
GetIntegrationUdms Method for GetIntegrationUdms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiGetIntegrationUdmsRequest
*/
func (a *IntegrationsAPIService) GetIntegrationUdms(ctx context.Context, idOrKey string) ApiGetIntegrationUdmsRequest {
	return ApiGetIntegrationUdmsRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *IntegrationsAPIService) GetIntegrationUdmsExecute(r ApiGetIntegrationUdmsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.GetIntegrationUdms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/udm"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIntegrationsRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
}

func (r ApiListIntegrationsRequest) Execute() (*ListIntegrations200Response, *http.Response, error) {
	return r.ApiService.ListIntegrationsExecute(r)
}

/*
ListIntegrations Method for ListIntegrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIntegrationsRequest
*/
func (a *IntegrationsAPIService) ListIntegrations(ctx context.Context) ApiListIntegrationsRequest {
	return ApiListIntegrationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIntegrations200Response
func (a *IntegrationsAPIService) ListIntegrationsExecute(r ApiListIntegrationsRequest) (*ListIntegrations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIntegrations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.ListIntegrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	updateIntegrationDto *UpdateIntegrationDto
}

func (r ApiPatchIntegrationRequest) UpdateIntegrationDto(updateIntegrationDto UpdateIntegrationDto) ApiPatchIntegrationRequest {
	r.updateIntegrationDto = &updateIntegrationDto
	return r
}

func (r ApiPatchIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.PatchIntegrationExecute(r)
}

/*
PatchIntegration Method for PatchIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiPatchIntegrationRequest
*/
func (a *IntegrationsAPIService) PatchIntegration(ctx context.Context, idOrKey string) ApiPatchIntegrationRequest {
	return ApiPatchIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) PatchIntegrationExecute(r ApiPatchIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.PatchIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("updateIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishConnectorToIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	publishConnectorToIntegrationDto *PublishConnectorToIntegrationDto
}

func (r ApiPublishConnectorToIntegrationRequest) PublishConnectorToIntegrationDto(publishConnectorToIntegrationDto PublishConnectorToIntegrationDto) ApiPublishConnectorToIntegrationRequest {
	r.publishConnectorToIntegrationDto = &publishConnectorToIntegrationDto
	return r
}

func (r ApiPublishConnectorToIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.PublishConnectorToIntegrationExecute(r)
}

/*
PublishConnectorToIntegration Method for PublishConnectorToIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiPublishConnectorToIntegrationRequest
*/
func (a *IntegrationsAPIService) PublishConnectorToIntegration(ctx context.Context, idOrKey string) ApiPublishConnectorToIntegrationRequest {
	return ApiPublishConnectorToIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) PublishConnectorToIntegrationExecute(r ApiPublishConnectorToIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.PublishConnectorToIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/publish-connector"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publishConnectorToIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("publishConnectorToIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publishConnectorToIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
	createIntegrationDto *CreateIntegrationDto
}

func (r ApiPutIntegrationRequest) CreateIntegrationDto(createIntegrationDto CreateIntegrationDto) ApiPutIntegrationRequest {
	r.createIntegrationDto = &createIntegrationDto
	return r
}

func (r ApiPutIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.PutIntegrationExecute(r)
}

/*
PutIntegration Method for PutIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiPutIntegrationRequest
*/
func (a *IntegrationsAPIService) PutIntegration(ctx context.Context, idOrKey string) ApiPutIntegrationRequest {
	return ApiPutIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) PutIntegrationExecute(r ApiPutIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.PutIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReUploadIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	id string
}

func (r ApiReUploadIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.ReUploadIntegrationExecute(r)
}

/*
ReUploadIntegration Method for ReUploadIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiReUploadIntegrationRequest
*/
func (a *IntegrationsAPIService) ReUploadIntegration(ctx context.Context, id string) ApiReUploadIntegrationRequest {
	return ApiReUploadIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) ReUploadIntegrationExecute(r ApiReUploadIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.ReUploadIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetParametersRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiResetParametersRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.ResetParametersExecute(r)
}

/*
ResetParameters Method for ResetParameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiResetParametersRequest
*/
func (a *IntegrationsAPIService) ResetParameters(ctx context.Context, idOrKey string) ApiResetParametersRequest {
	return ApiResetParametersRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) ResetParametersExecute(r ApiResetParametersRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.ResetParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/reset-parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetupIntegrationRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiSetupIntegrationRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.SetupIntegrationExecute(r)
}

/*
SetupIntegration Method for SetupIntegration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiSetupIntegrationRequest
*/
func (a *IntegrationsAPIService) SetupIntegration(ctx context.Context, idOrKey string) ApiSetupIntegrationRequest {
	return ApiSetupIntegrationRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) SetupIntegrationExecute(r ApiSetupIntegrationRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.SetupIntegration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIntegrationConnectorRequest struct {
	ctx context.Context
	ApiService IntegrationsAPI
	idOrKey string
}

func (r ApiUpdateIntegrationConnectorRequest) Execute() (*IntegrationDto, *http.Response, error) {
	return r.ApiService.UpdateIntegrationConnectorExecute(r)
}

/*
UpdateIntegrationConnector Method for UpdateIntegrationConnector

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrKey
 @return ApiUpdateIntegrationConnectorRequest
*/
func (a *IntegrationsAPIService) UpdateIntegrationConnector(ctx context.Context, idOrKey string) ApiUpdateIntegrationConnectorRequest {
	return ApiUpdateIntegrationConnectorRequest{
		ApiService: a,
		ctx: ctx,
		idOrKey: idOrKey,
	}
}

// Execute executes the request
//  @return IntegrationDto
func (a *IntegrationsAPIService) UpdateIntegrationConnectorExecute(r ApiUpdateIntegrationConnectorRequest) (*IntegrationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntegrationsAPIService.UpdateIntegrationConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{idOrKey}/update-connector"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrKey"+"}", url.PathEscape(parameterValueToString(r.idOrKey, "idOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
