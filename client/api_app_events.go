/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AppEventsAPI interface {

	/*
	ArchiveAppEventSubscription Method for ArchiveAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveAppEventSubscriptionRequest
	*/
	ArchiveAppEventSubscription(ctx context.Context) ApiArchiveAppEventSubscriptionRequest

	// ArchiveAppEventSubscriptionExecute executes the request
	ArchiveAppEventSubscriptionExecute(r ApiArchiveAppEventSubscriptionRequest) (*http.Response, error)

	/*
	CreateAppEventSubscription Method for CreateAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateAppEventSubscriptionRequest
	*/
	CreateAppEventSubscription(ctx context.Context) ApiCreateAppEventSubscriptionRequest

	// CreateAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	CreateAppEventSubscriptionExecute(r ApiCreateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)

	/*
	CreateAppEventType Method for CreateAppEventType

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateAppEventTypeRequest
	*/
	CreateAppEventType(ctx context.Context) ApiCreateAppEventTypeRequest

	// CreateAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	CreateAppEventTypeExecute(r ApiCreateAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	DeleteAppEventType Method for DeleteAppEventType

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiDeleteAppEventTypeRequest
	*/
	DeleteAppEventType(ctx context.Context, id string) ApiDeleteAppEventTypeRequest

	// DeleteAppEventTypeExecute executes the request
	DeleteAppEventTypeExecute(r ApiDeleteAppEventTypeRequest) (*http.Response, error)

	/*
	GetAppEvent Method for GetAppEvent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetAppEventRequest
	*/
	GetAppEvent(ctx context.Context, id string) ApiGetAppEventRequest

	// GetAppEventExecute executes the request
	//  @return AppEventDto
	GetAppEventExecute(r ApiGetAppEventRequest) (*AppEventDto, *http.Response, error)

	/*
	GetAppEventSubscription Method for GetAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAppEventSubscriptionRequest
	*/
	GetAppEventSubscription(ctx context.Context) ApiGetAppEventSubscriptionRequest

	// GetAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	GetAppEventSubscriptionExecute(r ApiGetAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)

	/*
	GetAppEventSubscriptionSchema Method for GetAppEventSubscriptionSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAppEventSubscriptionSchemaRequest
	*/
	GetAppEventSubscriptionSchema(ctx context.Context) ApiGetAppEventSubscriptionSchemaRequest

	// GetAppEventSubscriptionSchemaExecute executes the request
	//  @return map[string]interface{}
	GetAppEventSubscriptionSchemaExecute(r ApiGetAppEventSubscriptionSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetAppEventType Method for GetAppEventType

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetAppEventTypeRequest
	*/
	GetAppEventType(ctx context.Context, id string) ApiGetAppEventTypeRequest

	// GetAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	GetAppEventTypeExecute(r ApiGetAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	GetAppEventTypeSchema Method for GetAppEventTypeSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetAppEventTypeSchemaRequest
	*/
	GetAppEventTypeSchema(ctx context.Context, id string) ApiGetAppEventTypeSchemaRequest

	// GetAppEventTypeSchemaExecute executes the request
	//  @return map[string]interface{}
	GetAppEventTypeSchemaExecute(r ApiGetAppEventTypeSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListAppEventSubscriptions Method for ListAppEventSubscriptions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAppEventSubscriptionsRequest
	*/
	ListAppEventSubscriptions(ctx context.Context) ApiListAppEventSubscriptionsRequest

	// ListAppEventSubscriptionsExecute executes the request
	//  @return ListAppEventSubscriptions200Response
	ListAppEventSubscriptionsExecute(r ApiListAppEventSubscriptionsRequest) (*ListAppEventSubscriptions200Response, *http.Response, error)

	/*
	ListAppEventTypes Method for ListAppEventTypes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAppEventTypesRequest
	*/
	ListAppEventTypes(ctx context.Context) ApiListAppEventTypesRequest

	// ListAppEventTypesExecute executes the request
	//  @return ListAppEventTypes200Response
	ListAppEventTypesExecute(r ApiListAppEventTypesRequest) (*ListAppEventTypes200Response, *http.Response, error)

	/*
	ListAppEvents Method for ListAppEvents

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAppEventsRequest
	*/
	ListAppEvents(ctx context.Context) ApiListAppEventsRequest

	// ListAppEventsExecute executes the request
	//  @return ListAppEvents200Response
	ListAppEventsExecute(r ApiListAppEventsRequest) (*ListAppEvents200Response, *http.Response, error)

	/*
	PatchAppEventSubscription Method for PatchAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchAppEventSubscriptionRequest
	*/
	PatchAppEventSubscription(ctx context.Context) ApiPatchAppEventSubscriptionRequest

	// PatchAppEventSubscriptionExecute executes the request
	//  @return map[string]interface{}
	PatchAppEventSubscriptionExecute(r ApiPatchAppEventSubscriptionRequest) (map[string]interface{}, *http.Response, error)

	/*
	PatchAppEventType Method for PatchAppEventType

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPatchAppEventTypeRequest
	*/
	PatchAppEventType(ctx context.Context, id string) ApiPatchAppEventTypeRequest

	// PatchAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	PatchAppEventTypeExecute(r ApiPatchAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	PutAppEventType Method for PutAppEventType

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiPutAppEventTypeRequest
	*/
	PutAppEventType(ctx context.Context, id string) ApiPutAppEventTypeRequest

	// PutAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	PutAppEventTypeExecute(r ApiPutAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	SubscribeToAppEventSubscription Method for SubscribeToAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSubscribeToAppEventSubscriptionRequest
	*/
	SubscribeToAppEventSubscription(ctx context.Context) ApiSubscribeToAppEventSubscriptionRequest

	// SubscribeToAppEventSubscriptionExecute executes the request
	SubscribeToAppEventSubscriptionExecute(r ApiSubscribeToAppEventSubscriptionRequest) (*http.Response, error)

	/*
	UpdateAppEventSubscription Method for UpdateAppEventSubscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateAppEventSubscriptionRequest
	*/
	UpdateAppEventSubscription(ctx context.Context) ApiUpdateAppEventSubscriptionRequest

	// UpdateAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	UpdateAppEventSubscriptionExecute(r ApiUpdateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)
}

// AppEventsAPIService AppEventsAPI service
type AppEventsAPIService service

type ApiArchiveAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiArchiveAppEventSubscriptionRequest) Id(id string) ApiArchiveAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiArchiveAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiArchiveAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiArchiveAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiArchiveAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) UserId(userId string) ApiArchiveAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiArchiveAppEventSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAppEventSubscriptionExecute(r)
}

/*
ArchiveAppEventSubscription Method for ArchiveAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) ArchiveAppEventSubscription(ctx context.Context) ApiArchiveAppEventSubscriptionRequest {
	return ApiArchiveAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) ArchiveAppEventSubscriptionExecute(r ApiArchiveAppEventSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.ArchiveAppEventSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiCreateAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiCreateAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) Id(id string) ApiCreateAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiCreateAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiCreateAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiCreateAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiCreateAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) UserId(userId string) ApiCreateAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiCreateAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.CreateAppEventSubscriptionExecute(r)
}

/*
CreateAppEventSubscription Method for CreateAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) CreateAppEventSubscription(ctx context.Context) ApiCreateAppEventSubscriptionRequest {
	return ApiCreateAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) CreateAppEventSubscriptionExecute(r ApiCreateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.CreateAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	createAppEventTypeDto *CreateAppEventTypeDto
}

func (r ApiCreateAppEventTypeRequest) CreateAppEventTypeDto(createAppEventTypeDto CreateAppEventTypeDto) ApiCreateAppEventTypeRequest {
	r.createAppEventTypeDto = &createAppEventTypeDto
	return r
}

func (r ApiCreateAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.CreateAppEventTypeExecute(r)
}

/*
CreateAppEventType Method for CreateAppEventType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAppEventTypeRequest
*/
func (a *AppEventsAPIService) CreateAppEventType(ctx context.Context) ApiCreateAppEventTypeRequest {
	return ApiCreateAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) CreateAppEventTypeExecute(r ApiCreateAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.CreateAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("createAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiDeleteAppEventTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAppEventTypeExecute(r)
}

/*
DeleteAppEventType Method for DeleteAppEventType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiDeleteAppEventTypeRequest
*/
func (a *AppEventsAPIService) DeleteAppEventType(ctx context.Context, id string) ApiDeleteAppEventTypeRequest {
	return ApiDeleteAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) DeleteAppEventTypeExecute(r ApiDeleteAppEventTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.DeleteAppEventType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAppEventRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiGetAppEventRequest) Execute() (*AppEventDto, *http.Response, error) {
	return r.ApiService.GetAppEventExecute(r)
}

/*
GetAppEvent Method for GetAppEvent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAppEventRequest
*/
func (a *AppEventsAPIService) GetAppEvent(ctx context.Context, id string) ApiGetAppEventRequest {
	return ApiGetAppEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventDto
func (a *AppEventsAPIService) GetAppEventExecute(r ApiGetAppEventRequest) (*AppEventDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.GetAppEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-events/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiGetAppEventSubscriptionRequest) Id(id string) ApiGetAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiGetAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiGetAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiGetAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiGetAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiGetAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiGetAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiGetAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetAppEventSubscriptionRequest) UserId(userId string) ApiGetAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiGetAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.GetAppEventSubscriptionExecute(r)
}

/*
GetAppEventSubscription Method for GetAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) GetAppEventSubscription(ctx context.Context) ApiGetAppEventSubscriptionRequest {
	return ApiGetAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) GetAppEventSubscriptionExecute(r ApiGetAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.GetAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppEventSubscriptionSchemaRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiGetAppEventSubscriptionSchemaRequest) Id(id string) ApiGetAppEventSubscriptionSchemaRequest {
	r.id = &id
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) InstanceKey(instanceKey string) ApiGetAppEventSubscriptionSchemaRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) AppEventTypeId(appEventTypeId string) ApiGetAppEventSubscriptionSchemaRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) AppEventTypeKey(appEventTypeKey string) ApiGetAppEventSubscriptionSchemaRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) AutoCreate(autoCreate bool) ApiGetAppEventSubscriptionSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) UserId(userId string) ApiGetAppEventSubscriptionSchemaRequest {
	r.userId = &userId
	return r
}

func (r ApiGetAppEventSubscriptionSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAppEventSubscriptionSchemaExecute(r)
}

/*
GetAppEventSubscriptionSchema Method for GetAppEventSubscriptionSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAppEventSubscriptionSchemaRequest
*/
func (a *AppEventsAPIService) GetAppEventSubscriptionSchema(ctx context.Context) ApiGetAppEventSubscriptionSchemaRequest {
	return ApiGetAppEventSubscriptionSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) GetAppEventSubscriptionSchemaExecute(r ApiGetAppEventSubscriptionSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.GetAppEventSubscriptionSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription/schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiGetAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.GetAppEventTypeExecute(r)
}

/*
GetAppEventType Method for GetAppEventType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAppEventTypeRequest
*/
func (a *AppEventsAPIService) GetAppEventType(ctx context.Context, id string) ApiGetAppEventTypeRequest {
	return ApiGetAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) GetAppEventTypeExecute(r ApiGetAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.GetAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppEventTypeSchemaRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiGetAppEventTypeSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAppEventTypeSchemaExecute(r)
}

/*
GetAppEventTypeSchema Method for GetAppEventTypeSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetAppEventTypeSchemaRequest
*/
func (a *AppEventsAPIService) GetAppEventTypeSchema(ctx context.Context, id string) ApiGetAppEventTypeSchemaRequest {
	return ApiGetAppEventTypeSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) GetAppEventTypeSchemaExecute(r ApiGetAppEventTypeSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.GetAppEventTypeSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}/schema"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppEventSubscriptionsRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	userId *string
	appEventTypeId *string
	isSubscribed *bool
	instanceKey *string
}

func (r ApiListAppEventSubscriptionsRequest) Id(id string) ApiListAppEventSubscriptionsRequest {
	r.id = &id
	return r
}

func (r ApiListAppEventSubscriptionsRequest) UserId(userId string) ApiListAppEventSubscriptionsRequest {
	r.userId = &userId
	return r
}

func (r ApiListAppEventSubscriptionsRequest) AppEventTypeId(appEventTypeId string) ApiListAppEventSubscriptionsRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiListAppEventSubscriptionsRequest) IsSubscribed(isSubscribed bool) ApiListAppEventSubscriptionsRequest {
	r.isSubscribed = &isSubscribed
	return r
}

func (r ApiListAppEventSubscriptionsRequest) InstanceKey(instanceKey string) ApiListAppEventSubscriptionsRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListAppEventSubscriptionsRequest) Execute() (*ListAppEventSubscriptions200Response, *http.Response, error) {
	return r.ApiService.ListAppEventSubscriptionsExecute(r)
}

/*
ListAppEventSubscriptions Method for ListAppEventSubscriptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAppEventSubscriptionsRequest
*/
func (a *AppEventsAPIService) ListAppEventSubscriptions(ctx context.Context) ApiListAppEventSubscriptionsRequest {
	return ApiListAppEventSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAppEventSubscriptions200Response
func (a *AppEventsAPIService) ListAppEventSubscriptionsExecute(r ApiListAppEventSubscriptionsRequest) (*ListAppEventSubscriptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAppEventSubscriptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.ListAppEventSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.isSubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSubscribed", r.isSubscribed, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppEventTypesRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
}

func (r ApiListAppEventTypesRequest) Execute() (*ListAppEventTypes200Response, *http.Response, error) {
	return r.ApiService.ListAppEventTypesExecute(r)
}

/*
ListAppEventTypes Method for ListAppEventTypes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAppEventTypesRequest
*/
func (a *AppEventsAPIService) ListAppEventTypes(ctx context.Context) ApiListAppEventTypesRequest {
	return ApiListAppEventTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAppEventTypes200Response
func (a *AppEventsAPIService) ListAppEventTypesExecute(r ApiListAppEventTypesRequest) (*ListAppEventTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAppEventTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.ListAppEventTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppEventsRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	userId *string
	appEventTypeId *string
	appEventSubscriptionId *string
	startDatetime *string
	endDatetime *string
	instanceKey *string
}

func (r ApiListAppEventsRequest) Id(id string) ApiListAppEventsRequest {
	r.id = &id
	return r
}

func (r ApiListAppEventsRequest) UserId(userId string) ApiListAppEventsRequest {
	r.userId = &userId
	return r
}

func (r ApiListAppEventsRequest) AppEventTypeId(appEventTypeId string) ApiListAppEventsRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiListAppEventsRequest) AppEventSubscriptionId(appEventSubscriptionId string) ApiListAppEventsRequest {
	r.appEventSubscriptionId = &appEventSubscriptionId
	return r
}

func (r ApiListAppEventsRequest) StartDatetime(startDatetime string) ApiListAppEventsRequest {
	r.startDatetime = &startDatetime
	return r
}

func (r ApiListAppEventsRequest) EndDatetime(endDatetime string) ApiListAppEventsRequest {
	r.endDatetime = &endDatetime
	return r
}

func (r ApiListAppEventsRequest) InstanceKey(instanceKey string) ApiListAppEventsRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListAppEventsRequest) Execute() (*ListAppEvents200Response, *http.Response, error) {
	return r.ApiService.ListAppEventsExecute(r)
}

/*
ListAppEvents Method for ListAppEvents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAppEventsRequest
*/
func (a *AppEventsAPIService) ListAppEvents(ctx context.Context) ApiListAppEventsRequest {
	return ApiListAppEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAppEvents200Response
func (a *AppEventsAPIService) ListAppEventsExecute(r ApiListAppEventsRequest) (*ListAppEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAppEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.ListAppEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventSubscriptionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventSubscriptionId", r.appEventSubscriptionId, "")
	}
	if r.startDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDatetime", r.startDatetime, "")
	}
	if r.endDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDatetime", r.endDatetime, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiPatchAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiPatchAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) Id(id string) ApiPatchAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiPatchAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiPatchAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiPatchAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiPatchAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) UserId(userId string) ApiPatchAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiPatchAppEventSubscriptionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PatchAppEventSubscriptionExecute(r)
}

/*
PatchAppEventSubscription Method for PatchAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) PatchAppEventSubscription(ctx context.Context) ApiPatchAppEventSubscriptionRequest {
	return ApiPatchAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) PatchAppEventSubscriptionExecute(r ApiPatchAppEventSubscriptionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.PatchAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
	updateAppEventTypeDto *UpdateAppEventTypeDto
}

func (r ApiPatchAppEventTypeRequest) UpdateAppEventTypeDto(updateAppEventTypeDto UpdateAppEventTypeDto) ApiPatchAppEventTypeRequest {
	r.updateAppEventTypeDto = &updateAppEventTypeDto
	return r
}

func (r ApiPatchAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.PatchAppEventTypeExecute(r)
}

/*
PatchAppEventType Method for PatchAppEventType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPatchAppEventTypeRequest
*/
func (a *AppEventsAPIService) PatchAppEventType(ctx context.Context, id string) ApiPatchAppEventTypeRequest {
	return ApiPatchAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) PatchAppEventTypeExecute(r ApiPatchAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.PatchAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("updateAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
	updateAppEventTypeDto *UpdateAppEventTypeDto
}

func (r ApiPutAppEventTypeRequest) UpdateAppEventTypeDto(updateAppEventTypeDto UpdateAppEventTypeDto) ApiPutAppEventTypeRequest {
	r.updateAppEventTypeDto = &updateAppEventTypeDto
	return r
}

func (r ApiPutAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.PutAppEventTypeExecute(r)
}

/*
PutAppEventType Method for PutAppEventType

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPutAppEventTypeRequest
*/
func (a *AppEventsAPIService) PutAppEventType(ctx context.Context, id string) ApiPutAppEventTypeRequest {
	return ApiPutAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) PutAppEventTypeExecute(r ApiPutAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.PutAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("updateAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscribeToAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiSubscribeToAppEventSubscriptionRequest) Id(id string) ApiSubscribeToAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiSubscribeToAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiSubscribeToAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiSubscribeToAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiSubscribeToAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) UserId(userId string) ApiSubscribeToAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiSubscribeToAppEventSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscribeToAppEventSubscriptionExecute(r)
}

/*
SubscribeToAppEventSubscription Method for SubscribeToAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubscribeToAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) SubscribeToAppEventSubscription(ctx context.Context) ApiSubscribeToAppEventSubscriptionRequest {
	return ApiSubscribeToAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) SubscribeToAppEventSubscriptionExecute(r ApiSubscribeToAppEventSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.SubscribeToAppEventSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiUpdateAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiUpdateAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) Id(id string) ApiUpdateAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiUpdateAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiUpdateAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiUpdateAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiUpdateAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) UserId(userId string) ApiUpdateAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiUpdateAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.UpdateAppEventSubscriptionExecute(r)
}

/*
UpdateAppEventSubscription Method for UpdateAppEventSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) UpdateAppEventSubscription(ctx context.Context) ApiUpdateAppEventSubscriptionRequest {
	return ApiUpdateAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) UpdateAppEventSubscriptionExecute(r ApiUpdateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.UpdateAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
