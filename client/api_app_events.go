/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AppEventsAPI interface {

	/*
	AppEventSubscriptionControllerArchiveAppEventSubscription Archive app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerArchiveAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest

	// AppEventSubscriptionControllerArchiveAppEventSubscriptionExecute executes the request
	AppEventSubscriptionControllerArchiveAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) (*http.Response, error)

	/*
	AppEventSubscriptionControllerCreateAppEventSubscription Create app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerCreateAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest

	// AppEventSubscriptionControllerCreateAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	AppEventSubscriptionControllerCreateAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)

	/*
	AppEventSubscriptionControllerGetAppEventSubscription Get app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerGetAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest

	// AppEventSubscriptionControllerGetAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	AppEventSubscriptionControllerGetAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)

	/*
	AppEventSubscriptionControllerGetAppEventSubscriptionSchema Get app event subscription schema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest
	*/
	AppEventSubscriptionControllerGetAppEventSubscriptionSchema(ctx context.Context) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest

	// AppEventSubscriptionControllerGetAppEventSubscriptionSchemaExecute executes the request
	//  @return map[string]interface{}
	AppEventSubscriptionControllerGetAppEventSubscriptionSchemaExecute(r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	AppEventSubscriptionControllerPatchAppEventSubscription Patch app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerPatchAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest

	// AppEventSubscriptionControllerPatchAppEventSubscriptionExecute executes the request
	//  @return map[string]interface{}
	AppEventSubscriptionControllerPatchAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) (map[string]interface{}, *http.Response, error)

	/*
	AppEventSubscriptionControllerSubscribeToAppEventSubscription Subscribe to app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerSubscribeToAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest

	// AppEventSubscriptionControllerSubscribeToAppEventSubscriptionExecute executes the request
	AppEventSubscriptionControllerSubscribeToAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) (*http.Response, error)

	/*
	AppEventSubscriptionControllerUpdateAppEventSubscription Update app event subscription

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest
	*/
	AppEventSubscriptionControllerUpdateAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest

	// AppEventSubscriptionControllerUpdateAppEventSubscriptionExecute executes the request
	//  @return AppEventSubscriptionDto
	AppEventSubscriptionControllerUpdateAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error)

	/*
	AppEventSubscriptionsControllerListAppEventSubscriptions List app event subscriptions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest
	*/
	AppEventSubscriptionsControllerListAppEventSubscriptions(ctx context.Context) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest

	// AppEventSubscriptionsControllerListAppEventSubscriptionsExecute executes the request
	//  @return AppEventSubscriptionsControllerListAppEventSubscriptions200Response
	AppEventSubscriptionsControllerListAppEventSubscriptionsExecute(r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) (*AppEventSubscriptionsControllerListAppEventSubscriptions200Response, *http.Response, error)

	/*
	AppEventTypesControllerCreateAppEventType Create app event type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventTypesControllerCreateAppEventTypeRequest
	*/
	AppEventTypesControllerCreateAppEventType(ctx context.Context) ApiAppEventTypesControllerCreateAppEventTypeRequest

	// AppEventTypesControllerCreateAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	AppEventTypesControllerCreateAppEventTypeExecute(r ApiAppEventTypesControllerCreateAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	AppEventTypesControllerDeleteAppEventType Archive app event type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerDeleteAppEventTypeRequest
	*/
	AppEventTypesControllerDeleteAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerDeleteAppEventTypeRequest

	// AppEventTypesControllerDeleteAppEventTypeExecute executes the request
	AppEventTypesControllerDeleteAppEventTypeExecute(r ApiAppEventTypesControllerDeleteAppEventTypeRequest) (*http.Response, error)

	/*
	AppEventTypesControllerExportAppEventType Export App Event Type to JSON

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerExportAppEventTypeRequest
	*/
	AppEventTypesControllerExportAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerExportAppEventTypeRequest

	// AppEventTypesControllerExportAppEventTypeExecute executes the request
	//  @return AppEventTypeExportDto
	AppEventTypesControllerExportAppEventTypeExecute(r ApiAppEventTypesControllerExportAppEventTypeRequest) (*AppEventTypeExportDto, *http.Response, error)

	/*
	AppEventTypesControllerGetAppEventType Get app event type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerGetAppEventTypeRequest
	*/
	AppEventTypesControllerGetAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerGetAppEventTypeRequest

	// AppEventTypesControllerGetAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	AppEventTypesControllerGetAppEventTypeExecute(r ApiAppEventTypesControllerGetAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	AppEventTypesControllerGetAppEventTypeSchema Get app event type schema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerGetAppEventTypeSchemaRequest
	*/
	AppEventTypesControllerGetAppEventTypeSchema(ctx context.Context, id string) ApiAppEventTypesControllerGetAppEventTypeSchemaRequest

	// AppEventTypesControllerGetAppEventTypeSchemaExecute executes the request
	//  @return map[string]interface{}
	AppEventTypesControllerGetAppEventTypeSchemaExecute(r ApiAppEventTypesControllerGetAppEventTypeSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	AppEventTypesControllerListAppEventTypes List app event types

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventTypesControllerListAppEventTypesRequest
	*/
	AppEventTypesControllerListAppEventTypes(ctx context.Context) ApiAppEventTypesControllerListAppEventTypesRequest

	// AppEventTypesControllerListAppEventTypesExecute executes the request
	//  @return AppEventTypesControllerListAppEventTypes200Response
	AppEventTypesControllerListAppEventTypesExecute(r ApiAppEventTypesControllerListAppEventTypesRequest) (*AppEventTypesControllerListAppEventTypes200Response, *http.Response, error)

	/*
	AppEventTypesControllerPatchAppEventType Patch app event type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerPatchAppEventTypeRequest
	*/
	AppEventTypesControllerPatchAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerPatchAppEventTypeRequest

	// AppEventTypesControllerPatchAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	AppEventTypesControllerPatchAppEventTypeExecute(r ApiAppEventTypesControllerPatchAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	AppEventTypesControllerPutAppEventType Update app event type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventTypesControllerPutAppEventTypeRequest
	*/
	AppEventTypesControllerPutAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerPutAppEventTypeRequest

	// AppEventTypesControllerPutAppEventTypeExecute executes the request
	//  @return AppEventTypeDto
	AppEventTypesControllerPutAppEventTypeExecute(r ApiAppEventTypesControllerPutAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error)

	/*
	AppEventsControllerGetAppEvent Get app event

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiAppEventsControllerGetAppEventRequest
	*/
	AppEventsControllerGetAppEvent(ctx context.Context, id string) ApiAppEventsControllerGetAppEventRequest

	// AppEventsControllerGetAppEventExecute executes the request
	//  @return AppEventDto
	AppEventsControllerGetAppEventExecute(r ApiAppEventsControllerGetAppEventRequest) (*AppEventDto, *http.Response, error)

	/*
	AppEventsControllerListAppEvents List app events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAppEventsControllerListAppEventsRequest
	*/
	AppEventsControllerListAppEvents(ctx context.Context) ApiAppEventsControllerListAppEventsRequest

	// AppEventsControllerListAppEventsExecute executes the request
	//  @return AppEventsControllerListAppEvents200Response
	AppEventsControllerListAppEventsExecute(r ApiAppEventsControllerListAppEventsRequest) (*AppEventsControllerListAppEvents200Response, *http.Response, error)
}

// AppEventsAPIService AppEventsAPI service
type AppEventsAPIService service

type ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerArchiveAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerArchiveAppEventSubscription Archive app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerArchiveAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) AppEventSubscriptionControllerArchiveAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerArchiveAppEventSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerArchiveAppEventSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerCreateAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerCreateAppEventSubscription Create app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerCreateAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) AppEventSubscriptionControllerCreateAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerCreateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerCreateAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerGetAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerGetAppEventSubscription Get app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerGetAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) AppEventSubscriptionControllerGetAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerGetAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerGetAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) Id(id string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) UserId(userId string) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerGetAppEventSubscriptionSchemaExecute(r)
}

/*
AppEventSubscriptionControllerGetAppEventSubscriptionSchema Get app event subscription schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerGetAppEventSubscriptionSchema(ctx context.Context) ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest {
	return ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) AppEventSubscriptionControllerGetAppEventSubscriptionSchemaExecute(r ApiAppEventSubscriptionControllerGetAppEventSubscriptionSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerGetAppEventSubscriptionSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription/schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerPatchAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerPatchAppEventSubscription Patch app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerPatchAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) AppEventSubscriptionControllerPatchAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerPatchAppEventSubscriptionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerPatchAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerSubscribeToAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerSubscribeToAppEventSubscription Subscribe to app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerSubscribeToAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) AppEventSubscriptionControllerSubscribeToAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerSubscribeToAppEventSubscriptionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerSubscribeToAppEventSubscription")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription/subscribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appEventTypeId *string
	appEventTypeKey *string
	autoCreate *bool
	userId *string
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) Body(body map[string]interface{}) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) Id(id string) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) AppEventTypeKey(appEventTypeKey string) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.appEventTypeKey = &appEventTypeKey
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) AutoCreate(autoCreate bool) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) UserId(userId string) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) Execute() (*AppEventSubscriptionDto, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionControllerUpdateAppEventSubscriptionExecute(r)
}

/*
AppEventSubscriptionControllerUpdateAppEventSubscription Update app event subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionControllerUpdateAppEventSubscription(ctx context.Context) ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest {
	return ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionDto
func (a *AppEventsAPIService) AppEventSubscriptionControllerUpdateAppEventSubscriptionExecute(r ApiAppEventSubscriptionControllerUpdateAppEventSubscriptionRequest) (*AppEventSubscriptionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionControllerUpdateAppEventSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventTypeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeKey", r.appEventTypeKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	id *string
	userId *string
	appEventTypeId *string
	isSubscribed *bool
	instanceKey *string
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) Limit(limit float32) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.limit = &limit
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) Cursor(cursor string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) Search(search string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.search = &search
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) ConnectorId(connectorId string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) Id(id string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.id = &id
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) UserId(userId string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) AppEventTypeId(appEventTypeId string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) IsSubscribed(isSubscribed bool) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.isSubscribed = &isSubscribed
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) InstanceKey(instanceKey string) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) Execute() (*AppEventSubscriptionsControllerListAppEventSubscriptions200Response, *http.Response, error) {
	return r.ApiService.AppEventSubscriptionsControllerListAppEventSubscriptionsExecute(r)
}

/*
AppEventSubscriptionsControllerListAppEventSubscriptions List app event subscriptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest
*/
func (a *AppEventsAPIService) AppEventSubscriptionsControllerListAppEventSubscriptions(ctx context.Context) ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest {
	return ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventSubscriptionsControllerListAppEventSubscriptions200Response
func (a *AppEventsAPIService) AppEventSubscriptionsControllerListAppEventSubscriptionsExecute(r ApiAppEventSubscriptionsControllerListAppEventSubscriptionsRequest) (*AppEventSubscriptionsControllerListAppEventSubscriptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventSubscriptionsControllerListAppEventSubscriptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventSubscriptionsControllerListAppEventSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.isSubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSubscribed", r.isSubscribed, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerCreateAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	createAppEventTypeDto *CreateAppEventTypeDto
}

func (r ApiAppEventTypesControllerCreateAppEventTypeRequest) CreateAppEventTypeDto(createAppEventTypeDto CreateAppEventTypeDto) ApiAppEventTypesControllerCreateAppEventTypeRequest {
	r.createAppEventTypeDto = &createAppEventTypeDto
	return r
}

func (r ApiAppEventTypesControllerCreateAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerCreateAppEventTypeExecute(r)
}

/*
AppEventTypesControllerCreateAppEventType Create app event type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventTypesControllerCreateAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerCreateAppEventType(ctx context.Context) ApiAppEventTypesControllerCreateAppEventTypeRequest {
	return ApiAppEventTypesControllerCreateAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) AppEventTypesControllerCreateAppEventTypeExecute(r ApiAppEventTypesControllerCreateAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerCreateAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("createAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerDeleteAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiAppEventTypesControllerDeleteAppEventTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppEventTypesControllerDeleteAppEventTypeExecute(r)
}

/*
AppEventTypesControllerDeleteAppEventType Archive app event type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerDeleteAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerDeleteAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerDeleteAppEventTypeRequest {
	return ApiAppEventTypesControllerDeleteAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppEventsAPIService) AppEventTypesControllerDeleteAppEventTypeExecute(r ApiAppEventTypesControllerDeleteAppEventTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerDeleteAppEventType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerExportAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiAppEventTypesControllerExportAppEventTypeRequest) Execute() (*AppEventTypeExportDto, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerExportAppEventTypeExecute(r)
}

/*
AppEventTypesControllerExportAppEventType Export App Event Type to JSON

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerExportAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerExportAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerExportAppEventTypeRequest {
	return ApiAppEventTypesControllerExportAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeExportDto
func (a *AppEventsAPIService) AppEventTypesControllerExportAppEventTypeExecute(r ApiAppEventTypesControllerExportAppEventTypeRequest) (*AppEventTypeExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerExportAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerGetAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiAppEventTypesControllerGetAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerGetAppEventTypeExecute(r)
}

/*
AppEventTypesControllerGetAppEventType Get app event type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerGetAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerGetAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerGetAppEventTypeRequest {
	return ApiAppEventTypesControllerGetAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) AppEventTypesControllerGetAppEventTypeExecute(r ApiAppEventTypesControllerGetAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerGetAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerGetAppEventTypeSchemaRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiAppEventTypesControllerGetAppEventTypeSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerGetAppEventTypeSchemaExecute(r)
}

/*
AppEventTypesControllerGetAppEventTypeSchema Get app event type schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerGetAppEventTypeSchemaRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerGetAppEventTypeSchema(ctx context.Context, id string) ApiAppEventTypesControllerGetAppEventTypeSchemaRequest {
	return ApiAppEventTypesControllerGetAppEventTypeSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AppEventsAPIService) AppEventTypesControllerGetAppEventTypeSchemaExecute(r ApiAppEventTypesControllerGetAppEventTypeSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerGetAppEventTypeSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}/schema"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerListAppEventTypesRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) Limit(limit float32) ApiAppEventTypesControllerListAppEventTypesRequest {
	r.limit = &limit
	return r
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) Cursor(cursor string) ApiAppEventTypesControllerListAppEventTypesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) Search(search string) ApiAppEventTypesControllerListAppEventTypesRequest {
	r.search = &search
	return r
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) ConnectorId(connectorId string) ApiAppEventTypesControllerListAppEventTypesRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) IncludeArchived(includeArchived bool) ApiAppEventTypesControllerListAppEventTypesRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiAppEventTypesControllerListAppEventTypesRequest) Execute() (*AppEventTypesControllerListAppEventTypes200Response, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerListAppEventTypesExecute(r)
}

/*
AppEventTypesControllerListAppEventTypes List app event types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventTypesControllerListAppEventTypesRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerListAppEventTypes(ctx context.Context) ApiAppEventTypesControllerListAppEventTypesRequest {
	return ApiAppEventTypesControllerListAppEventTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventTypesControllerListAppEventTypes200Response
func (a *AppEventsAPIService) AppEventTypesControllerListAppEventTypesExecute(r ApiAppEventTypesControllerListAppEventTypesRequest) (*AppEventTypesControllerListAppEventTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypesControllerListAppEventTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerListAppEventTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerPatchAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
	updateAppEventTypeDto *UpdateAppEventTypeDto
}

func (r ApiAppEventTypesControllerPatchAppEventTypeRequest) UpdateAppEventTypeDto(updateAppEventTypeDto UpdateAppEventTypeDto) ApiAppEventTypesControllerPatchAppEventTypeRequest {
	r.updateAppEventTypeDto = &updateAppEventTypeDto
	return r
}

func (r ApiAppEventTypesControllerPatchAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerPatchAppEventTypeExecute(r)
}

/*
AppEventTypesControllerPatchAppEventType Patch app event type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerPatchAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerPatchAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerPatchAppEventTypeRequest {
	return ApiAppEventTypesControllerPatchAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) AppEventTypesControllerPatchAppEventTypeExecute(r ApiAppEventTypesControllerPatchAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerPatchAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("updateAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventTypesControllerPutAppEventTypeRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
	updateAppEventTypeDto *UpdateAppEventTypeDto
}

func (r ApiAppEventTypesControllerPutAppEventTypeRequest) UpdateAppEventTypeDto(updateAppEventTypeDto UpdateAppEventTypeDto) ApiAppEventTypesControllerPutAppEventTypeRequest {
	r.updateAppEventTypeDto = &updateAppEventTypeDto
	return r
}

func (r ApiAppEventTypesControllerPutAppEventTypeRequest) Execute() (*AppEventTypeDto, *http.Response, error) {
	return r.ApiService.AppEventTypesControllerPutAppEventTypeExecute(r)
}

/*
AppEventTypesControllerPutAppEventType Update app event type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventTypesControllerPutAppEventTypeRequest
*/
func (a *AppEventsAPIService) AppEventTypesControllerPutAppEventType(ctx context.Context, id string) ApiAppEventTypesControllerPutAppEventTypeRequest {
	return ApiAppEventTypesControllerPutAppEventTypeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventTypeDto
func (a *AppEventsAPIService) AppEventTypesControllerPutAppEventTypeExecute(r ApiAppEventTypesControllerPutAppEventTypeRequest) (*AppEventTypeDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventTypeDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventTypesControllerPutAppEventType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-event-types/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAppEventTypeDto == nil {
		return localVarReturnValue, nil, reportError("updateAppEventTypeDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAppEventTypeDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventsControllerGetAppEventRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	id string
}

func (r ApiAppEventsControllerGetAppEventRequest) Execute() (*AppEventDto, *http.Response, error) {
	return r.ApiService.AppEventsControllerGetAppEventExecute(r)
}

/*
AppEventsControllerGetAppEvent Get app event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAppEventsControllerGetAppEventRequest
*/
func (a *AppEventsAPIService) AppEventsControllerGetAppEvent(ctx context.Context, id string) ApiAppEventsControllerGetAppEventRequest {
	return ApiAppEventsControllerGetAppEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventDto
func (a *AppEventsAPIService) AppEventsControllerGetAppEventExecute(r ApiAppEventsControllerGetAppEventRequest) (*AppEventDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventsControllerGetAppEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-events/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppEventsControllerListAppEventsRequest struct {
	ctx context.Context
	ApiService AppEventsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	id *string
	userId *string
	appEventTypeId *string
	appEventSubscriptionId *string
	startDatetime *string
	endDatetime *string
	instanceKey *string
}

func (r ApiAppEventsControllerListAppEventsRequest) Limit(limit float32) ApiAppEventsControllerListAppEventsRequest {
	r.limit = &limit
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) Cursor(cursor string) ApiAppEventsControllerListAppEventsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) Search(search string) ApiAppEventsControllerListAppEventsRequest {
	r.search = &search
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) ConnectorId(connectorId string) ApiAppEventsControllerListAppEventsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) Id(id string) ApiAppEventsControllerListAppEventsRequest {
	r.id = &id
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) UserId(userId string) ApiAppEventsControllerListAppEventsRequest {
	r.userId = &userId
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) AppEventTypeId(appEventTypeId string) ApiAppEventsControllerListAppEventsRequest {
	r.appEventTypeId = &appEventTypeId
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) AppEventSubscriptionId(appEventSubscriptionId string) ApiAppEventsControllerListAppEventsRequest {
	r.appEventSubscriptionId = &appEventSubscriptionId
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) StartDatetime(startDatetime string) ApiAppEventsControllerListAppEventsRequest {
	r.startDatetime = &startDatetime
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) EndDatetime(endDatetime string) ApiAppEventsControllerListAppEventsRequest {
	r.endDatetime = &endDatetime
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) InstanceKey(instanceKey string) ApiAppEventsControllerListAppEventsRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiAppEventsControllerListAppEventsRequest) Execute() (*AppEventsControllerListAppEvents200Response, *http.Response, error) {
	return r.ApiService.AppEventsControllerListAppEventsExecute(r)
}

/*
AppEventsControllerListAppEvents List app events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppEventsControllerListAppEventsRequest
*/
func (a *AppEventsAPIService) AppEventsControllerListAppEvents(ctx context.Context) ApiAppEventsControllerListAppEventsRequest {
	return ApiAppEventsControllerListAppEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppEventsControllerListAppEvents200Response
func (a *AppEventsAPIService) AppEventsControllerListAppEventsExecute(r ApiAppEventsControllerListAppEventsRequest) (*AppEventsControllerListAppEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventsControllerListAppEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppEventsAPIService.AppEventsControllerListAppEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.appEventTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventTypeId", r.appEventTypeId, "")
	}
	if r.appEventSubscriptionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appEventSubscriptionId", r.appEventSubscriptionId, "")
	}
	if r.startDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDatetime", r.startDatetime, "")
	}
	if r.endDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDatetime", r.endDatetime, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
