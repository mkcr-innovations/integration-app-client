/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FlowsAPI interface {

	/*
	ApplyFlow Method for ApplyFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to apply
	@return ApiApplyFlowRequest
	*/
	ApplyFlow(ctx context.Context, id string) ApiApplyFlowRequest

	// ApplyFlowExecute executes the request
	//  @return []FlowDto
	ApplyFlowExecute(r ApiApplyFlowRequest) ([]FlowDto, *http.Response, error)

	/*
	ApplyFlows Method for ApplyFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplyFlowsRequest
	*/
	ApplyFlows(ctx context.Context) ApiApplyFlowsRequest

	// ApplyFlowsExecute executes the request
	//  @return []FlowDto
	ApplyFlowsExecute(r ApiApplyFlowsRequest) ([]FlowDto, *http.Response, error)

	/*
	ArchiveFlow Method for ArchiveFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to retrive
	@return ApiArchiveFlowRequest
	*/
	ArchiveFlow(ctx context.Context, id string) ApiArchiveFlowRequest

	// ArchiveFlowExecute executes the request
	ArchiveFlowExecute(r ApiArchiveFlowRequest) (*http.Response, error)

	/*
	ArchiveFlowInstance Method for ArchiveFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveFlowInstanceRequest
	*/
	ArchiveFlowInstance(ctx context.Context) ApiArchiveFlowInstanceRequest

	// ArchiveFlowInstanceExecute executes the request
	ArchiveFlowInstanceExecute(r ApiArchiveFlowInstanceRequest) (*http.Response, error)

	/*
	ArchiveFlows Method for ArchiveFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveFlowsRequest
	*/
	ArchiveFlows(ctx context.Context) ApiArchiveFlowsRequest

	// ArchiveFlowsExecute executes the request
	ArchiveFlowsExecute(r ApiArchiveFlowsRequest) (*http.Response, error)

	/*
	CreateFlow Method for CreateFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFlowRequest
	*/
	CreateFlow(ctx context.Context) ApiCreateFlowRequest

	// CreateFlowExecute executes the request
	//  @return FlowDto
	CreateFlowExecute(r ApiCreateFlowRequest) (*FlowDto, *http.Response, error)

	/*
	CreateFlowInstance Method for CreateFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFlowInstanceRequest
	*/
	CreateFlowInstance(ctx context.Context) ApiCreateFlowInstanceRequest

	// CreateFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	CreateFlowInstanceExecute(r ApiCreateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	GetFlow Method for GetFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to retrive
	@return ApiGetFlowRequest
	*/
	GetFlow(ctx context.Context, id string) ApiGetFlowRequest

	// GetFlowExecute executes the request
	//  @return FlowDto
	GetFlowExecute(r ApiGetFlowRequest) (*FlowDto, *http.Response, error)

	/*
	GetFlowInstance Method for GetFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFlowInstanceRequest
	*/
	GetFlowInstance(ctx context.Context) ApiGetFlowInstanceRequest

	// GetFlowInstanceExecute executes the request
	//  @return map[string]interface{}
	GetFlowInstanceExecute(r ApiGetFlowInstanceRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetFlowNodeRun Method for GetFlowNodeRun

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@param nodeRunId
	@return ApiGetFlowNodeRunRequest
	*/
	GetFlowNodeRun(ctx context.Context, id string, nodeKey string, nodeRunId string) ApiGetFlowNodeRunRequest

	// GetFlowNodeRunExecute executes the request
	//  @return map[string]interface{}
	GetFlowNodeRunExecute(r ApiGetFlowNodeRunRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetFlowRun Method for GetFlowRun

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetFlowRunRequest
	*/
	GetFlowRun(ctx context.Context, id string) ApiGetFlowRunRequest

	// GetFlowRunExecute executes the request
	//  @return FlowRunDto
	GetFlowRunExecute(r ApiGetFlowRunRequest) (*FlowRunDto, *http.Response, error)

	/*
	GetFlowRunOutput Method for GetFlowRunOutput

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiGetFlowRunOutputRequest
	*/
	GetFlowRunOutput(ctx context.Context, id string) ApiGetFlowRunOutputRequest

	// GetFlowRunOutputExecute executes the request
	GetFlowRunOutputExecute(r ApiGetFlowRunOutputRequest) (*http.Response, error)

	/*
	GetFlows Method for GetFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFlowsRequest
	*/
	GetFlows(ctx context.Context) ApiGetFlowsRequest

	// GetFlowsExecute executes the request
	//  @return FlowDto
	GetFlowsExecute(r ApiGetFlowsRequest) (*FlowDto, *http.Response, error)

	/*
	GetNodeRunOutput Method for GetNodeRunOutput

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@param outputId
	@return ApiGetNodeRunOutputRequest
	*/
	GetNodeRunOutput(ctx context.Context, id string, nodeKey string, outputId string) ApiGetNodeRunOutputRequest

	// GetNodeRunOutputExecute executes the request
	//  @return map[string]interface{}
	GetNodeRunOutputExecute(r ApiGetNodeRunOutputRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListFlowInstances Method for ListFlowInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFlowInstancesRequest
	*/
	ListFlowInstances(ctx context.Context) ApiListFlowInstancesRequest

	// ListFlowInstancesExecute executes the request
	//  @return ListFlowInstances200Response
	ListFlowInstancesExecute(r ApiListFlowInstancesRequest) (*ListFlowInstances200Response, *http.Response, error)

	/*
	ListFlowNodeRuns Method for ListFlowNodeRuns

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@return ApiListFlowNodeRunsRequest
	*/
	ListFlowNodeRuns(ctx context.Context, id string, nodeKey string) ApiListFlowNodeRunsRequest

	// ListFlowNodeRunsExecute executes the request
	ListFlowNodeRunsExecute(r ApiListFlowNodeRunsRequest) (*http.Response, error)

	/*
	ListFlowRuns Method for ListFlowRuns

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFlowRunsRequest
	*/
	ListFlowRuns(ctx context.Context) ApiListFlowRunsRequest

	// ListFlowRunsExecute executes the request
	//  @return ListFlowRuns200Response
	ListFlowRunsExecute(r ApiListFlowRunsRequest) (*ListFlowRuns200Response, *http.Response, error)

	/*
	ListFlows Method for ListFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFlowsRequest
	*/
	ListFlows(ctx context.Context) ApiListFlowsRequest

	// ListFlowsExecute executes the request
	//  @return ListFlows200Response
	ListFlowsExecute(r ApiListFlowsRequest) (*ListFlows200Response, *http.Response, error)

	/*
	ListNodeRunOutputs Method for ListNodeRunOutputs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@return ApiListNodeRunOutputsRequest
	*/
	ListNodeRunOutputs(ctx context.Context, id string, nodeKey string) ApiListNodeRunOutputsRequest

	// ListNodeRunOutputsExecute executes the request
	ListNodeRunOutputsExecute(r ApiListNodeRunOutputsRequest) (*http.Response, error)

	/*
	PatchFlow Method for PatchFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to retrive
	@return ApiPatchFlowRequest
	*/
	PatchFlow(ctx context.Context, id string) ApiPatchFlowRequest

	// PatchFlowExecute executes the request
	//  @return FlowDto
	PatchFlowExecute(r ApiPatchFlowRequest) (*FlowDto, *http.Response, error)

	/*
	PatchFlowInstance Method for PatchFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchFlowInstanceRequest
	*/
	PatchFlowInstance(ctx context.Context) ApiPatchFlowInstanceRequest

	// PatchFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	PatchFlowInstanceExecute(r ApiPatchFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	PatchFlows Method for PatchFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchFlowsRequest
	*/
	PatchFlows(ctx context.Context) ApiPatchFlowsRequest

	// PatchFlowsExecute executes the request
	//  @return FlowDto
	PatchFlowsExecute(r ApiPatchFlowsRequest) (*FlowDto, *http.Response, error)

	/*
	PutFlow Method for PutFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to retrive
	@return ApiPutFlowRequest
	*/
	PutFlow(ctx context.Context, id string) ApiPutFlowRequest

	// PutFlowExecute executes the request
	//  @return FlowDto
	PutFlowExecute(r ApiPutFlowRequest) (*FlowDto, *http.Response, error)

	/*
	PutFlows Method for PutFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutFlowsRequest
	*/
	PutFlows(ctx context.Context) ApiPutFlowsRequest

	// PutFlowsExecute executes the request
	//  @return FlowDto
	PutFlowsExecute(r ApiPutFlowsRequest) (*FlowDto, *http.Response, error)

	/*
	ResetFlow Method for ResetFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the flow to reset
	@return ApiResetFlowRequest
	*/
	ResetFlow(ctx context.Context, id string) ApiResetFlowRequest

	// ResetFlowExecute executes the request
	//  @return FlowDto
	ResetFlowExecute(r ApiResetFlowRequest) (*FlowDto, *http.Response, error)

	/*
	ResetFlowInstance Method for ResetFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetFlowInstanceRequest
	*/
	ResetFlowInstance(ctx context.Context) ApiResetFlowInstanceRequest

	// ResetFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	ResetFlowInstanceExecute(r ApiResetFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ResetFlows Method for ResetFlows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetFlowsRequest
	*/
	ResetFlows(ctx context.Context) ApiResetFlowsRequest

	// ResetFlowsExecute executes the request
	//  @return FlowDto
	ResetFlowsExecute(r ApiResetFlowsRequest) (*FlowDto, *http.Response, error)

	/*
	RunFlow Method for RunFlow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param flowKey
	@return ApiRunFlowRequest
	*/
	RunFlow(ctx context.Context, connectionIdOrKey string, flowKey string) ApiRunFlowRequest

	// RunFlowExecute executes the request
	RunFlowExecute(r ApiRunFlowRequest) (*http.Response, error)

	/*
	SetupFlowInstance Method for SetupFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetupFlowInstanceRequest
	*/
	SetupFlowInstance(ctx context.Context) ApiSetupFlowInstanceRequest

	// SetupFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	SetupFlowInstanceExecute(r ApiSetupFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	StopFlowRun Method for StopFlowRun

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiStopFlowRunRequest
	*/
	StopFlowRun(ctx context.Context, id string) ApiStopFlowRunRequest

	// StopFlowRunExecute executes the request
	StopFlowRunExecute(r ApiStopFlowRunRequest) (*http.Response, error)

	/*
	UpdateFlowInstance Method for UpdateFlowInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateFlowInstanceRequest
	*/
	UpdateFlowInstance(ctx context.Context) ApiUpdateFlowInstanceRequest

	// UpdateFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	UpdateFlowInstanceExecute(r ApiUpdateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)
}

// FlowsAPIService FlowsAPI service
type FlowsAPIService service

type ApiApplyFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiApplyFlowRequest) Id2(id2 string) ApiApplyFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiApplyFlowRequest) Key(key string) ApiApplyFlowRequest {
	r.key = &key
	return r
}

func (r ApiApplyFlowRequest) IntegrationId(integrationId string) ApiApplyFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyFlowRequest) IntegrationKey(integrationKey string) ApiApplyFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyFlowRequest) AutoCreate(autoCreate bool) ApiApplyFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiApplyFlowRequest) Execute() ([]FlowDto, *http.Response, error) {
	return r.ApiService.ApplyFlowExecute(r)
}

/*
ApplyFlow Method for ApplyFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to apply
 @return ApiApplyFlowRequest
*/
func (a *FlowsAPIService) ApplyFlow(ctx context.Context, id string) ApiApplyFlowRequest {
	return ApiApplyFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []FlowDto
func (a *FlowsAPIService) ApplyFlowExecute(r ApiApplyFlowRequest) ([]FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ApplyFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiApplyFlowsRequest) Id(id string) ApiApplyFlowsRequest {
	r.id = &id
	return r
}

func (r ApiApplyFlowsRequest) Key(key string) ApiApplyFlowsRequest {
	r.key = &key
	return r
}

func (r ApiApplyFlowsRequest) IntegrationId(integrationId string) ApiApplyFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyFlowsRequest) IntegrationKey(integrationKey string) ApiApplyFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyFlowsRequest) AutoCreate(autoCreate bool) ApiApplyFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiApplyFlowsRequest) Execute() ([]FlowDto, *http.Response, error) {
	return r.ApiService.ApplyFlowsExecute(r)
}

/*
ApplyFlows Method for ApplyFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyFlowsRequest
*/
func (a *FlowsAPIService) ApplyFlows(ctx context.Context) ApiApplyFlowsRequest {
	return ApiApplyFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FlowDto
func (a *FlowsAPIService) ApplyFlowsExecute(r ApiApplyFlowsRequest) ([]FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ApplyFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiArchiveFlowRequest) Id2(id2 string) ApiArchiveFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiArchiveFlowRequest) Key(key string) ApiArchiveFlowRequest {
	r.key = &key
	return r
}

func (r ApiArchiveFlowRequest) IntegrationId(integrationId string) ApiArchiveFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveFlowRequest) IntegrationKey(integrationKey string) ApiArchiveFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveFlowRequest) AutoCreate(autoCreate bool) ApiArchiveFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveFlowRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveFlowExecute(r)
}

/*
ArchiveFlow Method for ArchiveFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to retrive
 @return ApiArchiveFlowRequest
*/
func (a *FlowsAPIService) ArchiveFlow(ctx context.Context, id string) ApiArchiveFlowRequest {
	return ApiArchiveFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ArchiveFlowExecute(r ApiArchiveFlowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ArchiveFlow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiArchiveFlowInstanceRequest) Id(id string) ApiArchiveFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiArchiveFlowInstanceRequest) FlowId(flowId string) ApiArchiveFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiArchiveFlowInstanceRequest) FlowKey(flowKey string) ApiArchiveFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiArchiveFlowInstanceRequest) InstanceKey(instanceKey string) ApiArchiveFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiArchiveFlowInstanceRequest) AutoCreate(autoCreate bool) ApiArchiveFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiArchiveFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiArchiveFlowInstanceRequest) IntegrationKey(integrationKey string) ApiArchiveFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveFlowInstanceRequest) IntegrationId(integrationId string) ApiArchiveFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveFlowInstanceRequest) ConnectionId(connectionId string) ApiArchiveFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiArchiveFlowInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveFlowInstanceExecute(r)
}

/*
ArchiveFlowInstance Method for ArchiveFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveFlowInstanceRequest
*/
func (a *FlowsAPIService) ArchiveFlowInstance(ctx context.Context) ApiArchiveFlowInstanceRequest {
	return ApiArchiveFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ArchiveFlowInstanceExecute(r ApiArchiveFlowInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ArchiveFlowInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiArchiveFlowsRequest) Id(id string) ApiArchiveFlowsRequest {
	r.id = &id
	return r
}

func (r ApiArchiveFlowsRequest) Key(key string) ApiArchiveFlowsRequest {
	r.key = &key
	return r
}

func (r ApiArchiveFlowsRequest) IntegrationId(integrationId string) ApiArchiveFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveFlowsRequest) IntegrationKey(integrationKey string) ApiArchiveFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveFlowsRequest) AutoCreate(autoCreate bool) ApiArchiveFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveFlowsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveFlowsExecute(r)
}

/*
ArchiveFlows Method for ArchiveFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveFlowsRequest
*/
func (a *FlowsAPIService) ArchiveFlows(ctx context.Context) ApiArchiveFlowsRequest {
	return ApiArchiveFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ArchiveFlowsExecute(r ApiArchiveFlowsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ArchiveFlows")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	createFlowDto *CreateFlowDto
}

func (r ApiCreateFlowRequest) CreateFlowDto(createFlowDto CreateFlowDto) ApiCreateFlowRequest {
	r.createFlowDto = &createFlowDto
	return r
}

func (r ApiCreateFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.CreateFlowExecute(r)
}

/*
CreateFlow Method for CreateFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFlowRequest
*/
func (a *FlowsAPIService) CreateFlow(ctx context.Context) ApiCreateFlowRequest {
	return ApiCreateFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) CreateFlowExecute(r ApiCreateFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.CreateFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFlowDto == nil {
		return localVarReturnValue, nil, reportError("createFlowDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	updateFlowInstanceRequestDto *UpdateFlowInstanceRequestDto
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiCreateFlowInstanceRequest) UpdateFlowInstanceRequestDto(updateFlowInstanceRequestDto UpdateFlowInstanceRequestDto) ApiCreateFlowInstanceRequest {
	r.updateFlowInstanceRequestDto = &updateFlowInstanceRequestDto
	return r
}

func (r ApiCreateFlowInstanceRequest) Id(id string) ApiCreateFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiCreateFlowInstanceRequest) FlowId(flowId string) ApiCreateFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiCreateFlowInstanceRequest) FlowKey(flowKey string) ApiCreateFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiCreateFlowInstanceRequest) InstanceKey(instanceKey string) ApiCreateFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiCreateFlowInstanceRequest) AutoCreate(autoCreate bool) ApiCreateFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiCreateFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiCreateFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiCreateFlowInstanceRequest) IntegrationKey(integrationKey string) ApiCreateFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiCreateFlowInstanceRequest) IntegrationId(integrationId string) ApiCreateFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiCreateFlowInstanceRequest) ConnectionId(connectionId string) ApiCreateFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiCreateFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.CreateFlowInstanceExecute(r)
}

/*
CreateFlowInstance Method for CreateFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFlowInstanceRequest
*/
func (a *FlowsAPIService) CreateFlowInstance(ctx context.Context) ApiCreateFlowInstanceRequest {
	return ApiCreateFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) CreateFlowInstanceExecute(r ApiCreateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.CreateFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceRequestDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceRequestDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiGetFlowRequest) Id2(id2 string) ApiGetFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiGetFlowRequest) Key(key string) ApiGetFlowRequest {
	r.key = &key
	return r
}

func (r ApiGetFlowRequest) IntegrationId(integrationId string) ApiGetFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFlowRequest) IntegrationKey(integrationKey string) ApiGetFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFlowRequest) AutoCreate(autoCreate bool) ApiGetFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.GetFlowExecute(r)
}

/*
GetFlow Method for GetFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to retrive
 @return ApiGetFlowRequest
*/
func (a *FlowsAPIService) GetFlow(ctx context.Context, id string) ApiGetFlowRequest {
	return ApiGetFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) GetFlowExecute(r ApiGetFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiGetFlowInstanceRequest) Id(id string) ApiGetFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetFlowInstanceRequest) FlowId(flowId string) ApiGetFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiGetFlowInstanceRequest) FlowKey(flowKey string) ApiGetFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiGetFlowInstanceRequest) InstanceKey(instanceKey string) ApiGetFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetFlowInstanceRequest) AutoCreate(autoCreate bool) ApiGetFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiGetFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiGetFlowInstanceRequest) IntegrationKey(integrationKey string) ApiGetFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFlowInstanceRequest) IntegrationId(integrationId string) ApiGetFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFlowInstanceRequest) ConnectionId(connectionId string) ApiGetFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetFlowInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFlowInstanceExecute(r)
}

/*
GetFlowInstance Method for GetFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFlowInstanceRequest
*/
func (a *FlowsAPIService) GetFlowInstance(ctx context.Context) ApiGetFlowInstanceRequest {
	return ApiGetFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) GetFlowInstanceExecute(r ApiGetFlowInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowNodeRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	nodeRunId string
}

func (r ApiGetFlowNodeRunRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFlowNodeRunExecute(r)
}

/*
GetFlowNodeRun Method for GetFlowNodeRun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @param nodeRunId
 @return ApiGetFlowNodeRunRequest
*/
func (a *FlowsAPIService) GetFlowNodeRun(ctx context.Context, id string, nodeKey string, nodeRunId string) ApiGetFlowNodeRunRequest {
	return ApiGetFlowNodeRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
		nodeRunId: nodeRunId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) GetFlowNodeRunExecute(r ApiGetFlowNodeRunRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlowNodeRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/runs/{nodeRunId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeRunId"+"}", url.PathEscape(parameterValueToString(r.nodeRunId, "nodeRunId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
}

func (r ApiGetFlowRunRequest) Execute() (*FlowRunDto, *http.Response, error) {
	return r.ApiService.GetFlowRunExecute(r)
}

/*
GetFlowRun Method for GetFlowRun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetFlowRunRequest
*/
func (a *FlowsAPIService) GetFlowRun(ctx context.Context, id string) ApiGetFlowRunRequest {
	return ApiGetFlowRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowRunDto
func (a *FlowsAPIService) GetFlowRunExecute(r ApiGetFlowRunRequest) (*FlowRunDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowRunDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowRunOutputRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	cursor *string
}

func (r ApiGetFlowRunOutputRequest) Cursor(cursor string) ApiGetFlowRunOutputRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetFlowRunOutputRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetFlowRunOutputExecute(r)
}

/*
GetFlowRunOutput Method for GetFlowRunOutput

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetFlowRunOutputRequest
*/
func (a *FlowsAPIService) GetFlowRunOutput(ctx context.Context, id string) ApiGetFlowRunOutputRequest {
	return ApiGetFlowRunOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) GetFlowRunOutputExecute(r ApiGetFlowRunOutputRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlowRunOutput")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/output"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiGetFlowsRequest) Id(id string) ApiGetFlowsRequest {
	r.id = &id
	return r
}

func (r ApiGetFlowsRequest) Key(key string) ApiGetFlowsRequest {
	r.key = &key
	return r
}

func (r ApiGetFlowsRequest) IntegrationId(integrationId string) ApiGetFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFlowsRequest) IntegrationKey(integrationKey string) ApiGetFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFlowsRequest) AutoCreate(autoCreate bool) ApiGetFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetFlowsRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.GetFlowsExecute(r)
}

/*
GetFlows Method for GetFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFlowsRequest
*/
func (a *FlowsAPIService) GetFlows(ctx context.Context) ApiGetFlowsRequest {
	return ApiGetFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) GetFlowsExecute(r ApiGetFlowsRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeRunOutputRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	outputId string
}

func (r ApiGetNodeRunOutputRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetNodeRunOutputExecute(r)
}

/*
GetNodeRunOutput Method for GetNodeRunOutput

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @param outputId
 @return ApiGetNodeRunOutputRequest
*/
func (a *FlowsAPIService) GetNodeRunOutput(ctx context.Context, id string, nodeKey string, outputId string) ApiGetNodeRunOutputRequest {
	return ApiGetNodeRunOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
		outputId: outputId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) GetNodeRunOutputExecute(r ApiGetNodeRunOutputRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.GetNodeRunOutput")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/outputs/{outputId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outputId"+"}", url.PathEscape(parameterValueToString(r.outputId, "outputId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFlowInstancesRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	userId *string
	flowId *string
	universalFlowId *string
	flowKey *string
	connectionId *string
	integrationKey *string
	integrationId *string
	instanceKey *string
	enabled *bool
	dependencyInstanceId *string
}

func (r ApiListFlowInstancesRequest) Id(id string) ApiListFlowInstancesRequest {
	r.id = &id
	return r
}

func (r ApiListFlowInstancesRequest) UserId(userId string) ApiListFlowInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiListFlowInstancesRequest) FlowId(flowId string) ApiListFlowInstancesRequest {
	r.flowId = &flowId
	return r
}

func (r ApiListFlowInstancesRequest) UniversalFlowId(universalFlowId string) ApiListFlowInstancesRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiListFlowInstancesRequest) FlowKey(flowKey string) ApiListFlowInstancesRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiListFlowInstancesRequest) ConnectionId(connectionId string) ApiListFlowInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListFlowInstancesRequest) IntegrationKey(integrationKey string) ApiListFlowInstancesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListFlowInstancesRequest) IntegrationId(integrationId string) ApiListFlowInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFlowInstancesRequest) InstanceKey(instanceKey string) ApiListFlowInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListFlowInstancesRequest) Enabled(enabled bool) ApiListFlowInstancesRequest {
	r.enabled = &enabled
	return r
}

func (r ApiListFlowInstancesRequest) DependencyInstanceId(dependencyInstanceId string) ApiListFlowInstancesRequest {
	r.dependencyInstanceId = &dependencyInstanceId
	return r
}

func (r ApiListFlowInstancesRequest) Execute() (*ListFlowInstances200Response, *http.Response, error) {
	return r.ApiService.ListFlowInstancesExecute(r)
}

/*
ListFlowInstances Method for ListFlowInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFlowInstancesRequest
*/
func (a *FlowsAPIService) ListFlowInstances(ctx context.Context) ApiListFlowInstancesRequest {
	return ApiListFlowInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFlowInstances200Response
func (a *FlowsAPIService) ListFlowInstancesExecute(r ApiListFlowInstancesRequest) (*ListFlowInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFlowInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ListFlowInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.dependencyInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyInstanceId", r.dependencyInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFlowNodeRunsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	cursor *string
}

func (r ApiListFlowNodeRunsRequest) Cursor(cursor string) ApiListFlowNodeRunsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiListFlowNodeRunsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListFlowNodeRunsExecute(r)
}

/*
ListFlowNodeRuns Method for ListFlowNodeRuns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @return ApiListFlowNodeRunsRequest
*/
func (a *FlowsAPIService) ListFlowNodeRuns(ctx context.Context, id string, nodeKey string) ApiListFlowNodeRunsRequest {
	return ApiListFlowNodeRunsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ListFlowNodeRunsExecute(r ApiListFlowNodeRunsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ListFlowNodeRuns")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListFlowRunsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	flowInstanceId *string
	startNodeKey *string
	flowId *string
	universalFlowId *string
	userId *string
	state *string
	integrationId *string
	connectionId *string
	startedAfter *string
}

func (r ApiListFlowRunsRequest) Id(id string) ApiListFlowRunsRequest {
	r.id = &id
	return r
}

func (r ApiListFlowRunsRequest) FlowInstanceId(flowInstanceId string) ApiListFlowRunsRequest {
	r.flowInstanceId = &flowInstanceId
	return r
}

func (r ApiListFlowRunsRequest) StartNodeKey(startNodeKey string) ApiListFlowRunsRequest {
	r.startNodeKey = &startNodeKey
	return r
}

func (r ApiListFlowRunsRequest) FlowId(flowId string) ApiListFlowRunsRequest {
	r.flowId = &flowId
	return r
}

func (r ApiListFlowRunsRequest) UniversalFlowId(universalFlowId string) ApiListFlowRunsRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiListFlowRunsRequest) UserId(userId string) ApiListFlowRunsRequest {
	r.userId = &userId
	return r
}

func (r ApiListFlowRunsRequest) State(state string) ApiListFlowRunsRequest {
	r.state = &state
	return r
}

func (r ApiListFlowRunsRequest) IntegrationId(integrationId string) ApiListFlowRunsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFlowRunsRequest) ConnectionId(connectionId string) ApiListFlowRunsRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListFlowRunsRequest) StartedAfter(startedAfter string) ApiListFlowRunsRequest {
	r.startedAfter = &startedAfter
	return r
}

func (r ApiListFlowRunsRequest) Execute() (*ListFlowRuns200Response, *http.Response, error) {
	return r.ApiService.ListFlowRunsExecute(r)
}

/*
ListFlowRuns Method for ListFlowRuns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFlowRunsRequest
*/
func (a *FlowsAPIService) ListFlowRuns(ctx context.Context) ApiListFlowRunsRequest {
	return ApiListFlowRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFlowRuns200Response
func (a *FlowsAPIService) ListFlowRunsExecute(r ApiListFlowRunsRequest) (*ListFlowRuns200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFlowRuns200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ListFlowRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowInstanceId", r.flowInstanceId, "")
	}
	if r.startNodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startNodeKey", r.startNodeKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	integrationKey *string
	integrationId *string
	universalFlowId *string
}

func (r ApiListFlowsRequest) IntegrationKey(integrationKey string) ApiListFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListFlowsRequest) IntegrationId(integrationId string) ApiListFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFlowsRequest) UniversalFlowId(universalFlowId string) ApiListFlowsRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiListFlowsRequest) Execute() (*ListFlows200Response, *http.Response, error) {
	return r.ApiService.ListFlowsExecute(r)
}

/*
ListFlows Method for ListFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFlowsRequest
*/
func (a *FlowsAPIService) ListFlows(ctx context.Context) ApiListFlowsRequest {
	return ApiListFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFlows200Response
func (a *FlowsAPIService) ListFlowsExecute(r ApiListFlowsRequest) (*ListFlows200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFlows200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ListFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNodeRunOutputsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	cursor *string
}

func (r ApiListNodeRunOutputsRequest) Cursor(cursor string) ApiListNodeRunOutputsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiListNodeRunOutputsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListNodeRunOutputsExecute(r)
}

/*
ListNodeRunOutputs Method for ListNodeRunOutputs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @return ApiListNodeRunOutputsRequest
*/
func (a *FlowsAPIService) ListNodeRunOutputs(ctx context.Context, id string, nodeKey string) ApiListNodeRunOutputsRequest {
	return ApiListNodeRunOutputsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ListNodeRunOutputsExecute(r ApiListNodeRunOutputsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ListNodeRunOutputs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/outputs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPatchFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowDto *UpdateFlowDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiPatchFlowRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiPatchFlowRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiPatchFlowRequest) Id2(id2 string) ApiPatchFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiPatchFlowRequest) Key(key string) ApiPatchFlowRequest {
	r.key = &key
	return r
}

func (r ApiPatchFlowRequest) IntegrationId(integrationId string) ApiPatchFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFlowRequest) IntegrationKey(integrationKey string) ApiPatchFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFlowRequest) AutoCreate(autoCreate bool) ApiPatchFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.PatchFlowExecute(r)
}

/*
PatchFlow Method for PatchFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to retrive
 @return ApiPatchFlowRequest
*/
func (a *FlowsAPIService) PatchFlow(ctx context.Context, id string) ApiPatchFlowRequest {
	return ApiPatchFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) PatchFlowExecute(r ApiPatchFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.PatchFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	updateFlowInstanceRequestDto *UpdateFlowInstanceRequestDto
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPatchFlowInstanceRequest) UpdateFlowInstanceRequestDto(updateFlowInstanceRequestDto UpdateFlowInstanceRequestDto) ApiPatchFlowInstanceRequest {
	r.updateFlowInstanceRequestDto = &updateFlowInstanceRequestDto
	return r
}

func (r ApiPatchFlowInstanceRequest) Id(id string) ApiPatchFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPatchFlowInstanceRequest) FlowId(flowId string) ApiPatchFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPatchFlowInstanceRequest) FlowKey(flowKey string) ApiPatchFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPatchFlowInstanceRequest) InstanceKey(instanceKey string) ApiPatchFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchFlowInstanceRequest) AutoCreate(autoCreate bool) ApiPatchFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiPatchFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiPatchFlowInstanceRequest) IntegrationKey(integrationKey string) ApiPatchFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFlowInstanceRequest) IntegrationId(integrationId string) ApiPatchFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFlowInstanceRequest) ConnectionId(connectionId string) ApiPatchFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPatchFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.PatchFlowInstanceExecute(r)
}

/*
PatchFlowInstance Method for PatchFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchFlowInstanceRequest
*/
func (a *FlowsAPIService) PatchFlowInstance(ctx context.Context) ApiPatchFlowInstanceRequest {
	return ApiPatchFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) PatchFlowInstanceExecute(r ApiPatchFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.PatchFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceRequestDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceRequestDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	updateFlowDto *UpdateFlowDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiPatchFlowsRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiPatchFlowsRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiPatchFlowsRequest) Id(id string) ApiPatchFlowsRequest {
	r.id = &id
	return r
}

func (r ApiPatchFlowsRequest) Key(key string) ApiPatchFlowsRequest {
	r.key = &key
	return r
}

func (r ApiPatchFlowsRequest) IntegrationId(integrationId string) ApiPatchFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFlowsRequest) IntegrationKey(integrationKey string) ApiPatchFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFlowsRequest) AutoCreate(autoCreate bool) ApiPatchFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchFlowsRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.PatchFlowsExecute(r)
}

/*
PatchFlows Method for PatchFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchFlowsRequest
*/
func (a *FlowsAPIService) PatchFlows(ctx context.Context) ApiPatchFlowsRequest {
	return ApiPatchFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) PatchFlowsExecute(r ApiPatchFlowsRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.PatchFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowDto *UpdateFlowDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiPutFlowRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiPutFlowRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiPutFlowRequest) Id2(id2 string) ApiPutFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiPutFlowRequest) Key(key string) ApiPutFlowRequest {
	r.key = &key
	return r
}

func (r ApiPutFlowRequest) IntegrationId(integrationId string) ApiPutFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutFlowRequest) IntegrationKey(integrationKey string) ApiPutFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutFlowRequest) AutoCreate(autoCreate bool) ApiPutFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.PutFlowExecute(r)
}

/*
PutFlow Method for PutFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to retrive
 @return ApiPutFlowRequest
*/
func (a *FlowsAPIService) PutFlow(ctx context.Context, id string) ApiPutFlowRequest {
	return ApiPutFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) PutFlowExecute(r ApiPutFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.PutFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	updateFlowDto *UpdateFlowDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiPutFlowsRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiPutFlowsRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiPutFlowsRequest) Id(id string) ApiPutFlowsRequest {
	r.id = &id
	return r
}

func (r ApiPutFlowsRequest) Key(key string) ApiPutFlowsRequest {
	r.key = &key
	return r
}

func (r ApiPutFlowsRequest) IntegrationId(integrationId string) ApiPutFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutFlowsRequest) IntegrationKey(integrationKey string) ApiPutFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutFlowsRequest) AutoCreate(autoCreate bool) ApiPutFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutFlowsRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.PutFlowsExecute(r)
}

/*
PutFlows Method for PutFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutFlowsRequest
*/
func (a *FlowsAPIService) PutFlows(ctx context.Context) ApiPutFlowsRequest {
	return ApiPutFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) PutFlowsExecute(r ApiPutFlowsRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.PutFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiResetFlowRequest) Id2(id2 string) ApiResetFlowRequest {
	r.id2 = &id2
	return r
}

func (r ApiResetFlowRequest) Key(key string) ApiResetFlowRequest {
	r.key = &key
	return r
}

func (r ApiResetFlowRequest) IntegrationId(integrationId string) ApiResetFlowRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFlowRequest) IntegrationKey(integrationKey string) ApiResetFlowRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFlowRequest) AutoCreate(autoCreate bool) ApiResetFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.ResetFlowExecute(r)
}

/*
ResetFlow Method for ResetFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the flow to reset
 @return ApiResetFlowRequest
*/
func (a *FlowsAPIService) ResetFlow(ctx context.Context, id string) ApiResetFlowRequest {
	return ApiResetFlowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) ResetFlowExecute(r ApiResetFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ResetFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiResetFlowInstanceRequest) Id(id string) ApiResetFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiResetFlowInstanceRequest) FlowId(flowId string) ApiResetFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiResetFlowInstanceRequest) FlowKey(flowKey string) ApiResetFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiResetFlowInstanceRequest) InstanceKey(instanceKey string) ApiResetFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiResetFlowInstanceRequest) AutoCreate(autoCreate bool) ApiResetFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiResetFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiResetFlowInstanceRequest) IntegrationKey(integrationKey string) ApiResetFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFlowInstanceRequest) IntegrationId(integrationId string) ApiResetFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFlowInstanceRequest) ConnectionId(connectionId string) ApiResetFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiResetFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ResetFlowInstanceExecute(r)
}

/*
ResetFlowInstance Method for ResetFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetFlowInstanceRequest
*/
func (a *FlowsAPIService) ResetFlowInstance(ctx context.Context) ApiResetFlowInstanceRequest {
	return ApiResetFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ResetFlowInstanceExecute(r ApiResetFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ResetFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiResetFlowsRequest) Id(id string) ApiResetFlowsRequest {
	r.id = &id
	return r
}

func (r ApiResetFlowsRequest) Key(key string) ApiResetFlowsRequest {
	r.key = &key
	return r
}

func (r ApiResetFlowsRequest) IntegrationId(integrationId string) ApiResetFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFlowsRequest) IntegrationKey(integrationKey string) ApiResetFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFlowsRequest) AutoCreate(autoCreate bool) ApiResetFlowsRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetFlowsRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.ResetFlowsExecute(r)
}

/*
ResetFlows Method for ResetFlows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetFlowsRequest
*/
func (a *FlowsAPIService) ResetFlows(ctx context.Context) ApiResetFlowsRequest {
	return ApiResetFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) ResetFlowsExecute(r ApiResetFlowsRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ResetFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	connectionIdOrKey string
	flowKey string
	runFlowPayload *RunFlowPayload
}

func (r ApiRunFlowRequest) RunFlowPayload(runFlowPayload RunFlowPayload) ApiRunFlowRequest {
	r.runFlowPayload = &runFlowPayload
	return r
}

func (r ApiRunFlowRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunFlowExecute(r)
}

/*
RunFlow Method for RunFlow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param flowKey
 @return ApiRunFlowRequest
*/
func (a *FlowsAPIService) RunFlow(ctx context.Context, connectionIdOrKey string, flowKey string) ApiRunFlowRequest {
	return ApiRunFlowRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		flowKey: flowKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) RunFlowExecute(r ApiRunFlowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.RunFlow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/flows/{flowKey}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowKey"+"}", url.PathEscape(parameterValueToString(r.flowKey, "flowKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.runFlowPayload == nil {
		return nil, reportError("runFlowPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.runFlowPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetupFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiSetupFlowInstanceRequest) Id(id string) ApiSetupFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiSetupFlowInstanceRequest) FlowId(flowId string) ApiSetupFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiSetupFlowInstanceRequest) FlowKey(flowKey string) ApiSetupFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiSetupFlowInstanceRequest) InstanceKey(instanceKey string) ApiSetupFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiSetupFlowInstanceRequest) AutoCreate(autoCreate bool) ApiSetupFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiSetupFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiSetupFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiSetupFlowInstanceRequest) IntegrationKey(integrationKey string) ApiSetupFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiSetupFlowInstanceRequest) IntegrationId(integrationId string) ApiSetupFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiSetupFlowInstanceRequest) ConnectionId(connectionId string) ApiSetupFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiSetupFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.SetupFlowInstanceExecute(r)
}

/*
SetupFlowInstance Method for SetupFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetupFlowInstanceRequest
*/
func (a *FlowsAPIService) SetupFlowInstance(ctx context.Context) ApiSetupFlowInstanceRequest {
	return ApiSetupFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) SetupFlowInstanceExecute(r ApiSetupFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.SetupFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance/setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopFlowRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
}

func (r ApiStopFlowRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopFlowRunExecute(r)
}

/*
StopFlowRun Method for StopFlowRun

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiStopFlowRunRequest
*/
func (a *FlowsAPIService) StopFlowRun(ctx context.Context, id string) ApiStopFlowRunRequest {
	return ApiStopFlowRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) StopFlowRunExecute(r ApiStopFlowRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.StopFlowRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	updateFlowInstanceRequestDto *UpdateFlowInstanceRequestDto
	id *string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiUpdateFlowInstanceRequest) UpdateFlowInstanceRequestDto(updateFlowInstanceRequestDto UpdateFlowInstanceRequestDto) ApiUpdateFlowInstanceRequest {
	r.updateFlowInstanceRequestDto = &updateFlowInstanceRequestDto
	return r
}

func (r ApiUpdateFlowInstanceRequest) Id(id string) ApiUpdateFlowInstanceRequest {
	r.id = &id
	return r
}

func (r ApiUpdateFlowInstanceRequest) FlowId(flowId string) ApiUpdateFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiUpdateFlowInstanceRequest) FlowKey(flowKey string) ApiUpdateFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiUpdateFlowInstanceRequest) InstanceKey(instanceKey string) ApiUpdateFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiUpdateFlowInstanceRequest) AutoCreate(autoCreate bool) ApiUpdateFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiUpdateFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiUpdateFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiUpdateFlowInstanceRequest) IntegrationKey(integrationKey string) ApiUpdateFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiUpdateFlowInstanceRequest) IntegrationId(integrationId string) ApiUpdateFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiUpdateFlowInstanceRequest) ConnectionId(connectionId string) ApiUpdateFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiUpdateFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.UpdateFlowInstanceExecute(r)
}

/*
UpdateFlowInstance Method for UpdateFlowInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateFlowInstanceRequest
*/
func (a *FlowsAPIService) UpdateFlowInstance(ctx context.Context) ApiUpdateFlowInstanceRequest {
	return ApiUpdateFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) UpdateFlowInstanceExecute(r ApiUpdateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.UpdateFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceRequestDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceRequestDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
