/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FlowsAPI interface {

	/*
	ConnectionLevelFlowControllerArchive Archive flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerArchiveRequest
	*/
	ConnectionLevelFlowControllerArchive(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerArchiveRequest

	// ConnectionLevelFlowControllerArchiveExecute executes the request
	ConnectionLevelFlowControllerArchiveExecute(r ApiConnectionLevelFlowControllerArchiveRequest) (*http.Response, error)

	/*
	ConnectionLevelFlowControllerGet Get flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerGetRequest
	*/
	ConnectionLevelFlowControllerGet(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerGetRequest

	// ConnectionLevelFlowControllerGetExecute executes the request
	//  @return FlowInstanceDto
	ConnectionLevelFlowControllerGetExecute(r ApiConnectionLevelFlowControllerGetRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFlowControllerPatch Patch update flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerPatchRequest
	*/
	ConnectionLevelFlowControllerPatch(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerPatchRequest

	// ConnectionLevelFlowControllerPatchExecute executes the request
	//  @return FlowInstanceDto
	ConnectionLevelFlowControllerPatchExecute(r ApiConnectionLevelFlowControllerPatchRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFlowControllerPut Update flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerPutRequest
	*/
	ConnectionLevelFlowControllerPut(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerPutRequest

	// ConnectionLevelFlowControllerPutExecute executes the request
	//  @return FlowInstanceDto
	ConnectionLevelFlowControllerPutExecute(r ApiConnectionLevelFlowControllerPutRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFlowControllerReset Reset flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerResetRequest
	*/
	ConnectionLevelFlowControllerReset(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerResetRequest

	// ConnectionLevelFlowControllerResetExecute executes the request
	//  @return FlowInstanceDto
	ConnectionLevelFlowControllerResetExecute(r ApiConnectionLevelFlowControllerResetRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFlowControllerSetup Setup flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowControllerSetupRequest
	*/
	ConnectionLevelFlowControllerSetup(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerSetupRequest

	// ConnectionLevelFlowControllerSetupExecute executes the request
	//  @return FlowInstanceDto
	ConnectionLevelFlowControllerSetupExecute(r ApiConnectionLevelFlowControllerSetupRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFlowsControllerList List flow instances for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFlowsControllerListRequest
	*/
	ConnectionLevelFlowsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelFlowsControllerListRequest

	// ConnectionLevelFlowsControllerListExecute executes the request
	ConnectionLevelFlowsControllerListExecute(r ApiConnectionLevelFlowsControllerListRequest) (*http.Response, error)

	/*
	FlowByIdControllerApply Apply flow to integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerApplyRequest
	*/
	FlowByIdControllerApply(ctx context.Context, id string) ApiFlowByIdControllerApplyRequest

	// FlowByIdControllerApplyExecute executes the request
	//  @return []FlowDto
	FlowByIdControllerApplyExecute(r ApiFlowByIdControllerApplyRequest) ([]FlowDto, *http.Response, error)

	/*
	FlowByIdControllerArchive Archive flow by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerArchiveRequest
	*/
	FlowByIdControllerArchive(ctx context.Context, id string) ApiFlowByIdControllerArchiveRequest

	// FlowByIdControllerArchiveExecute executes the request
	FlowByIdControllerArchiveExecute(r ApiFlowByIdControllerArchiveRequest) (*http.Response, error)

	/*
	FlowByIdControllerClone Method for FlowByIdControllerClone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerCloneRequest
	*/
	FlowByIdControllerClone(ctx context.Context, id string) ApiFlowByIdControllerCloneRequest

	// FlowByIdControllerCloneExecute executes the request
	//  @return FlowDto
	FlowByIdControllerCloneExecute(r ApiFlowByIdControllerCloneRequest) (*FlowDto, *http.Response, error)

	/*
	FlowByIdControllerExport Method for FlowByIdControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerExportRequest
	*/
	FlowByIdControllerExport(ctx context.Context, id string) ApiFlowByIdControllerExportRequest

	// FlowByIdControllerExportExecute executes the request
	//  @return FlowExportDto
	FlowByIdControllerExportExecute(r ApiFlowByIdControllerExportRequest) (*FlowExportDto, *http.Response, error)

	/*
	FlowByIdControllerGet Get flow by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerGetRequest
	*/
	FlowByIdControllerGet(ctx context.Context, id string) ApiFlowByIdControllerGetRequest

	// FlowByIdControllerGetExecute executes the request
	//  @return FlowDto
	FlowByIdControllerGetExecute(r ApiFlowByIdControllerGetRequest) (*FlowDto, *http.Response, error)

	/*
	FlowByIdControllerPatch Patch flow by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerPatchRequest
	*/
	FlowByIdControllerPatch(ctx context.Context, id string) ApiFlowByIdControllerPatchRequest

	// FlowByIdControllerPatchExecute executes the request
	//  @return FlowDto
	FlowByIdControllerPatchExecute(r ApiFlowByIdControllerPatchRequest) (*FlowDto, *http.Response, error)

	/*
	FlowByIdControllerPut Update flow by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerPutRequest
	*/
	FlowByIdControllerPut(ctx context.Context, id string) ApiFlowByIdControllerPutRequest

	// FlowByIdControllerPutExecute executes the request
	//  @return FlowDto
	FlowByIdControllerPutExecute(r ApiFlowByIdControllerPutRequest) (*FlowDto, *http.Response, error)

	/*
	FlowByIdControllerReset Reset flow by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowByIdControllerResetRequest
	*/
	FlowByIdControllerReset(ctx context.Context, id string) ApiFlowByIdControllerResetRequest

	// FlowByIdControllerResetExecute executes the request
	//  @return FlowDto
	FlowByIdControllerResetExecute(r ApiFlowByIdControllerResetRequest) (*FlowDto, *http.Response, error)

	/*
	FlowInstanceByIdControllerArchiveFlowInstance Archive flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest
	*/
	FlowInstanceByIdControllerArchiveFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest

	// FlowInstanceByIdControllerArchiveFlowInstanceExecute executes the request
	FlowInstanceByIdControllerArchiveFlowInstanceExecute(r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) (*http.Response, error)

	/*
	FlowInstanceByIdControllerCreateFlowInstance Create flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerCreateFlowInstanceRequest
	*/
	FlowInstanceByIdControllerCreateFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest

	// FlowInstanceByIdControllerCreateFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	FlowInstanceByIdControllerCreateFlowInstanceExecute(r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	FlowInstanceByIdControllerExport Method for FlowInstanceByIdControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerExportRequest
	*/
	FlowInstanceByIdControllerExport(ctx context.Context, id string) ApiFlowInstanceByIdControllerExportRequest

	// FlowInstanceByIdControllerExportExecute executes the request
	//  @return map[string]interface{}
	FlowInstanceByIdControllerExportExecute(r ApiFlowInstanceByIdControllerExportRequest) (map[string]interface{}, *http.Response, error)

	/*
	FlowInstanceByIdControllerGetFlowInstance Get flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerGetFlowInstanceRequest
	*/
	FlowInstanceByIdControllerGetFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest

	// FlowInstanceByIdControllerGetFlowInstanceExecute executes the request
	//  @return map[string]interface{}
	FlowInstanceByIdControllerGetFlowInstanceExecute(r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) (map[string]interface{}, *http.Response, error)

	/*
	FlowInstanceByIdControllerPatchFlowInstance Patch flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerPatchFlowInstanceRequest
	*/
	FlowInstanceByIdControllerPatchFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest

	// FlowInstanceByIdControllerPatchFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	FlowInstanceByIdControllerPatchFlowInstanceExecute(r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	FlowInstanceByIdControllerResetFlowInstance Reset flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerResetFlowInstanceRequest
	*/
	FlowInstanceByIdControllerResetFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest

	// FlowInstanceByIdControllerResetFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	FlowInstanceByIdControllerResetFlowInstanceExecute(r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	FlowInstanceByIdControllerSetupFlowInstance Setup flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerSetupFlowInstanceRequest
	*/
	FlowInstanceByIdControllerSetupFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest

	// FlowInstanceByIdControllerSetupFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	FlowInstanceByIdControllerSetupFlowInstanceExecute(r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	FlowInstanceByIdControllerUpdateFlowInstance Update flow instance by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest
	*/
	FlowInstanceByIdControllerUpdateFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest

	// FlowInstanceByIdControllerUpdateFlowInstanceExecute executes the request
	//  @return FlowInstanceDto
	FlowInstanceByIdControllerUpdateFlowInstanceExecute(r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error)

	/*
	FlowInstancesControllerListFlowInstances List flow instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFlowInstancesControllerListFlowInstancesRequest
	*/
	FlowInstancesControllerListFlowInstances(ctx context.Context) ApiFlowInstancesControllerListFlowInstancesRequest

	// FlowInstancesControllerListFlowInstancesExecute executes the request
	//  @return FlowInstancesControllerListFlowInstances200Response
	FlowInstancesControllerListFlowInstancesExecute(r ApiFlowInstancesControllerListFlowInstancesRequest) (*FlowInstancesControllerListFlowInstances200Response, *http.Response, error)

	/*
	FlowRunsControllerGetFlowNodeRun Get node run

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@param nodeRunId
	@return ApiFlowRunsControllerGetFlowNodeRunRequest
	*/
	FlowRunsControllerGetFlowNodeRun(ctx context.Context, id string, nodeKey string, nodeRunId string) ApiFlowRunsControllerGetFlowNodeRunRequest

	// FlowRunsControllerGetFlowNodeRunExecute executes the request
	//  @return map[string]interface{}
	FlowRunsControllerGetFlowNodeRunExecute(r ApiFlowRunsControllerGetFlowNodeRunRequest) (map[string]interface{}, *http.Response, error)

	/*
	FlowRunsControllerGetFlowRun Get flow run

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiFlowRunsControllerGetFlowRunRequest
	*/
	FlowRunsControllerGetFlowRun(ctx context.Context, id string) ApiFlowRunsControllerGetFlowRunRequest

	// FlowRunsControllerGetFlowRunExecute executes the request
	//  @return FlowRunDto
	FlowRunsControllerGetFlowRunExecute(r ApiFlowRunsControllerGetFlowRunRequest) (*FlowRunDto, *http.Response, error)

	/*
	FlowRunsControllerGetFlowRunOutput Get flow run output

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiFlowRunsControllerGetFlowRunOutputRequest
	*/
	FlowRunsControllerGetFlowRunOutput(ctx context.Context, id string) ApiFlowRunsControllerGetFlowRunOutputRequest

	// FlowRunsControllerGetFlowRunOutputExecute executes the request
	FlowRunsControllerGetFlowRunOutputExecute(r ApiFlowRunsControllerGetFlowRunOutputRequest) (*http.Response, error)

	/*
	FlowRunsControllerGetFlowRunOutputForNode Get flow run output for specific node

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@return ApiFlowRunsControllerGetFlowRunOutputForNodeRequest
	*/
	FlowRunsControllerGetFlowRunOutputForNode(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerGetFlowRunOutputForNodeRequest

	// FlowRunsControllerGetFlowRunOutputForNodeExecute executes the request
	FlowRunsControllerGetFlowRunOutputForNodeExecute(r ApiFlowRunsControllerGetFlowRunOutputForNodeRequest) (*http.Response, error)

	/*
	FlowRunsControllerGetNodeRunOutput Get node run output

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@param outputId
	@return ApiFlowRunsControllerGetNodeRunOutputRequest
	*/
	FlowRunsControllerGetNodeRunOutput(ctx context.Context, id string, nodeKey string, outputId string) ApiFlowRunsControllerGetNodeRunOutputRequest

	// FlowRunsControllerGetNodeRunOutputExecute executes the request
	//  @return map[string]interface{}
	FlowRunsControllerGetNodeRunOutputExecute(r ApiFlowRunsControllerGetNodeRunOutputRequest) (map[string]interface{}, *http.Response, error)

	/*
	FlowRunsControllerListFlowNodeRuns Get node runs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@return ApiFlowRunsControllerListFlowNodeRunsRequest
	*/
	FlowRunsControllerListFlowNodeRuns(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerListFlowNodeRunsRequest

	// FlowRunsControllerListFlowNodeRunsExecute executes the request
	FlowRunsControllerListFlowNodeRunsExecute(r ApiFlowRunsControllerListFlowNodeRunsRequest) (*http.Response, error)

	/*
	FlowRunsControllerListFlowRuns List flow runs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFlowRunsControllerListFlowRunsRequest
	*/
	FlowRunsControllerListFlowRuns(ctx context.Context) ApiFlowRunsControllerListFlowRunsRequest

	// FlowRunsControllerListFlowRunsExecute executes the request
	//  @return FlowRunsControllerListFlowRuns200Response
	FlowRunsControllerListFlowRunsExecute(r ApiFlowRunsControllerListFlowRunsRequest) (*FlowRunsControllerListFlowRuns200Response, *http.Response, error)

	/*
	FlowRunsControllerListNodeRunOutputs Get node run outputs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@param nodeKey
	@return ApiFlowRunsControllerListNodeRunOutputsRequest
	*/
	FlowRunsControllerListNodeRunOutputs(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerListNodeRunOutputsRequest

	// FlowRunsControllerListNodeRunOutputsExecute executes the request
	FlowRunsControllerListNodeRunOutputsExecute(r ApiFlowRunsControllerListNodeRunOutputsRequest) (*http.Response, error)

	/*
	FlowRunsControllerStopFlowRun Stop flow run

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiFlowRunsControllerStopFlowRunRequest
	*/
	FlowRunsControllerStopFlowRun(ctx context.Context, id string) ApiFlowRunsControllerStopFlowRunRequest

	// FlowRunsControllerStopFlowRunExecute executes the request
	FlowRunsControllerStopFlowRunExecute(r ApiFlowRunsControllerStopFlowRunRequest) (*http.Response, error)

	/*
	FlowsControllerCreateFlow Create flow

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFlowsControllerCreateFlowRequest
	*/
	FlowsControllerCreateFlow(ctx context.Context) ApiFlowsControllerCreateFlowRequest

	// FlowsControllerCreateFlowExecute executes the request
	//  @return FlowDto
	FlowsControllerCreateFlowExecute(r ApiFlowsControllerCreateFlowRequest) (*FlowDto, *http.Response, error)

	/*
	FlowsControllerListFlows List flows

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFlowsControllerListFlowsRequest
	*/
	FlowsControllerListFlows(ctx context.Context) ApiFlowsControllerListFlowsRequest

	// FlowsControllerListFlowsExecute executes the request
	//  @return FlowsControllerListFlows200Response
	FlowsControllerListFlowsExecute(r ApiFlowsControllerListFlowsRequest) (*FlowsControllerListFlows200Response, *http.Response, error)

	/*
	IntegrationLevelFlowControllerArchive Archive flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowControllerArchiveRequest
	*/
	IntegrationLevelFlowControllerArchive(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerArchiveRequest

	// IntegrationLevelFlowControllerArchiveExecute executes the request
	IntegrationLevelFlowControllerArchiveExecute(r ApiIntegrationLevelFlowControllerArchiveRequest) (*http.Response, error)

	/*
	IntegrationLevelFlowControllerGet Get flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowControllerGetRequest
	*/
	IntegrationLevelFlowControllerGet(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerGetRequest

	// IntegrationLevelFlowControllerGetExecute executes the request
	//  @return FlowDto
	IntegrationLevelFlowControllerGetExecute(r ApiIntegrationLevelFlowControllerGetRequest) (*FlowDto, *http.Response, error)

	/*
	IntegrationLevelFlowControllerPatch Patch update flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowControllerPatchRequest
	*/
	IntegrationLevelFlowControllerPatch(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerPatchRequest

	// IntegrationLevelFlowControllerPatchExecute executes the request
	//  @return FlowDto
	IntegrationLevelFlowControllerPatchExecute(r ApiIntegrationLevelFlowControllerPatchRequest) (*FlowDto, *http.Response, error)

	/*
	IntegrationLevelFlowControllerPut Update flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowControllerPutRequest
	*/
	IntegrationLevelFlowControllerPut(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerPutRequest

	// IntegrationLevelFlowControllerPutExecute executes the request
	//  @return FlowDto
	IntegrationLevelFlowControllerPutExecute(r ApiIntegrationLevelFlowControllerPutRequest) (*FlowDto, *http.Response, error)

	/*
	IntegrationLevelFlowControllerReset Reset flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowControllerResetRequest
	*/
	IntegrationLevelFlowControllerReset(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerResetRequest

	// IntegrationLevelFlowControllerResetExecute executes the request
	//  @return FlowDto
	IntegrationLevelFlowControllerResetExecute(r ApiIntegrationLevelFlowControllerResetRequest) (*FlowDto, *http.Response, error)

	/*
	IntegrationLevelFlowsControllerCreate Create flow for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowsControllerCreateRequest
	*/
	IntegrationLevelFlowsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelFlowsControllerCreateRequest

	// IntegrationLevelFlowsControllerCreateExecute executes the request
	//  @return FlowDto
	IntegrationLevelFlowsControllerCreateExecute(r ApiIntegrationLevelFlowsControllerCreateRequest) (*FlowDto, *http.Response, error)

	/*
	IntegrationLevelFlowsControllerList List flows for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFlowsControllerListRequest
	*/
	IntegrationLevelFlowsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelFlowsControllerListRequest

	// IntegrationLevelFlowsControllerListExecute executes the request
	//  @return FlowsControllerListFlows200Response
	IntegrationLevelFlowsControllerListExecute(r ApiIntegrationLevelFlowsControllerListRequest) (*FlowsControllerListFlows200Response, *http.Response, error)

	/*
	RunFlowControllerRunFlow Run flow instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param flowSelector Flow ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiRunFlowControllerRunFlowRequest
	*/
	RunFlowControllerRunFlow(ctx context.Context, flowSelector string, connectionSelector string) ApiRunFlowControllerRunFlowRequest

	// RunFlowControllerRunFlowExecute executes the request
	RunFlowControllerRunFlowExecute(r ApiRunFlowControllerRunFlowRequest) (*http.Response, error)
}

// FlowsAPIService FlowsAPI service
type FlowsAPIService service

type ApiConnectionLevelFlowControllerArchiveRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	instanceKey *string
}

func (r ApiConnectionLevelFlowControllerArchiveRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerArchiveRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerArchiveExecute(r)
}

/*
ConnectionLevelFlowControllerArchive Archive flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerArchiveRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerArchive(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerArchiveRequest {
	return ApiConnectionLevelFlowControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ConnectionLevelFlowControllerArchiveExecute(r ApiConnectionLevelFlowControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowControllerGetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFlowControllerGetRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerGetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerGetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFlowControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFlowControllerGetRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerGetExecute(r)
}

/*
ConnectionLevelFlowControllerGet Get flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerGetRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerGet(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerGetRequest {
	return ApiConnectionLevelFlowControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ConnectionLevelFlowControllerGetExecute(r ApiConnectionLevelFlowControllerGetRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowControllerPatchRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	updateFlowInstanceDto *UpdateFlowInstanceDto
	instanceKey *string
}

func (r ApiConnectionLevelFlowControllerPatchRequest) UpdateFlowInstanceDto(updateFlowInstanceDto UpdateFlowInstanceDto) ApiConnectionLevelFlowControllerPatchRequest {
	r.updateFlowInstanceDto = &updateFlowInstanceDto
	return r
}

func (r ApiConnectionLevelFlowControllerPatchRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerPatchRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerPatchRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerPatchExecute(r)
}

/*
ConnectionLevelFlowControllerPatch Patch update flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerPatchRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerPatch(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerPatchRequest {
	return ApiConnectionLevelFlowControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ConnectionLevelFlowControllerPatchExecute(r ApiConnectionLevelFlowControllerPatchRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowControllerPutRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	updateFlowInstanceDto *UpdateFlowInstanceDto
	instanceKey *string
}

func (r ApiConnectionLevelFlowControllerPutRequest) UpdateFlowInstanceDto(updateFlowInstanceDto UpdateFlowInstanceDto) ApiConnectionLevelFlowControllerPutRequest {
	r.updateFlowInstanceDto = &updateFlowInstanceDto
	return r
}

func (r ApiConnectionLevelFlowControllerPutRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerPutRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerPutRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerPutExecute(r)
}

/*
ConnectionLevelFlowControllerPut Update flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerPutRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerPut(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerPutRequest {
	return ApiConnectionLevelFlowControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ConnectionLevelFlowControllerPutExecute(r ApiConnectionLevelFlowControllerPutRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowControllerResetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	instanceKey *string
}

func (r ApiConnectionLevelFlowControllerResetRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerResetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerResetRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerResetExecute(r)
}

/*
ConnectionLevelFlowControllerReset Reset flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerResetRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerReset(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerResetRequest {
	return ApiConnectionLevelFlowControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ConnectionLevelFlowControllerResetExecute(r ApiConnectionLevelFlowControllerResetRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowControllerSetupRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	instanceKey *string
}

func (r ApiConnectionLevelFlowControllerSetupRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowControllerSetupRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFlowControllerSetupExecute(r)
}

/*
ConnectionLevelFlowControllerSetup Setup flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowControllerSetupRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowControllerSetup(ctx context.Context, flowSelector string, connectionSelector string) ApiConnectionLevelFlowControllerSetupRequest {
	return ApiConnectionLevelFlowControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) ConnectionLevelFlowControllerSetupExecute(r ApiConnectionLevelFlowControllerSetupRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFlowsControllerListRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	connectionSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	instanceKey *string
	userId *string
	flowKey *string
	flowId *string
	universalFlowId *string
	enabled *bool
}

func (r ApiConnectionLevelFlowsControllerListRequest) Limit(limit float32) ApiConnectionLevelFlowsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) Cursor(cursor string) ApiConnectionLevelFlowsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) Search(search string) ApiConnectionLevelFlowsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) ConnectorId(connectorId string) ApiConnectionLevelFlowsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) IncludeArchived(includeArchived bool) ApiConnectionLevelFlowsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) Id(id string) ApiConnectionLevelFlowsControllerListRequest {
	r.id = &id
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) InstanceKey(instanceKey string) ApiConnectionLevelFlowsControllerListRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) UserId(userId string) ApiConnectionLevelFlowsControllerListRequest {
	r.userId = &userId
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) FlowKey(flowKey string) ApiConnectionLevelFlowsControllerListRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) FlowId(flowId string) ApiConnectionLevelFlowsControllerListRequest {
	r.flowId = &flowId
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) UniversalFlowId(universalFlowId string) ApiConnectionLevelFlowsControllerListRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) Enabled(enabled bool) ApiConnectionLevelFlowsControllerListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiConnectionLevelFlowsControllerListRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelFlowsControllerListExecute(r)
}

/*
ConnectionLevelFlowsControllerList List flow instances for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFlowsControllerListRequest
*/
func (a *FlowsAPIService) ConnectionLevelFlowsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelFlowsControllerListRequest {
	return ApiConnectionLevelFlowsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *FlowsAPIService) ConnectionLevelFlowsControllerListExecute(r ApiConnectionLevelFlowsControllerListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.ConnectionLevelFlowsControllerList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowByIdControllerApplyRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerApplyRequest) Key(key string) ApiFlowByIdControllerApplyRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerApplyRequest) IntegrationId(integrationId string) ApiFlowByIdControllerApplyRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerApplyRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerApplyRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerApplyRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerApplyRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerApplyRequest) Execute() ([]FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerApplyExecute(r)
}

/*
FlowByIdControllerApply Apply flow to integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerApplyRequest
*/
func (a *FlowsAPIService) FlowByIdControllerApply(ctx context.Context, id string) ApiFlowByIdControllerApplyRequest {
	return ApiFlowByIdControllerApplyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []FlowDto
func (a *FlowsAPIService) FlowByIdControllerApplyExecute(r ApiFlowByIdControllerApplyRequest) ([]FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerApply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerArchiveRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerArchiveRequest) Key(key string) ApiFlowByIdControllerArchiveRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerArchiveRequest) IntegrationId(integrationId string) ApiFlowByIdControllerArchiveRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerArchiveRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerArchiveRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerArchiveRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerArchiveRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowByIdControllerArchiveExecute(r)
}

/*
FlowByIdControllerArchive Archive flow by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerArchiveRequest
*/
func (a *FlowsAPIService) FlowByIdControllerArchive(ctx context.Context, id string) ApiFlowByIdControllerArchiveRequest {
	return ApiFlowByIdControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowByIdControllerArchiveExecute(r ApiFlowByIdControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowByIdControllerCloneRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerCloneRequest) Key(key string) ApiFlowByIdControllerCloneRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerCloneRequest) IntegrationId(integrationId string) ApiFlowByIdControllerCloneRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerCloneRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerCloneRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerCloneRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerCloneRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerCloneRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerCloneExecute(r)
}

/*
FlowByIdControllerClone Method for FlowByIdControllerClone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerCloneRequest
*/
func (a *FlowsAPIService) FlowByIdControllerClone(ctx context.Context, id string) ApiFlowByIdControllerCloneRequest {
	return ApiFlowByIdControllerCloneRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowByIdControllerCloneExecute(r ApiFlowByIdControllerCloneRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerExportRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerExportRequest) Key(key string) ApiFlowByIdControllerExportRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerExportRequest) IntegrationId(integrationId string) ApiFlowByIdControllerExportRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerExportRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerExportRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerExportRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerExportRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerExportRequest) Execute() (*FlowExportDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerExportExecute(r)
}

/*
FlowByIdControllerExport Method for FlowByIdControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerExportRequest
*/
func (a *FlowsAPIService) FlowByIdControllerExport(ctx context.Context, id string) ApiFlowByIdControllerExportRequest {
	return ApiFlowByIdControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowExportDto
func (a *FlowsAPIService) FlowByIdControllerExportExecute(r ApiFlowByIdControllerExportRequest) (*FlowExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerGetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerGetRequest) Key(key string) ApiFlowByIdControllerGetRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerGetRequest) IntegrationId(integrationId string) ApiFlowByIdControllerGetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerGetRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerGetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerGetRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerGetRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerGetExecute(r)
}

/*
FlowByIdControllerGet Get flow by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerGetRequest
*/
func (a *FlowsAPIService) FlowByIdControllerGet(ctx context.Context, id string) ApiFlowByIdControllerGetRequest {
	return ApiFlowByIdControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowByIdControllerGetExecute(r ApiFlowByIdControllerGetRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerPatchRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowDto *UpdateFlowDto
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerPatchRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiFlowByIdControllerPatchRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiFlowByIdControllerPatchRequest) Key(key string) ApiFlowByIdControllerPatchRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerPatchRequest) IntegrationId(integrationId string) ApiFlowByIdControllerPatchRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerPatchRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerPatchRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerPatchRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerPatchRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerPatchRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerPatchExecute(r)
}

/*
FlowByIdControllerPatch Patch flow by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerPatchRequest
*/
func (a *FlowsAPIService) FlowByIdControllerPatch(ctx context.Context, id string) ApiFlowByIdControllerPatchRequest {
	return ApiFlowByIdControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowByIdControllerPatchExecute(r ApiFlowByIdControllerPatchRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerPutRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowDto *UpdateFlowDto
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerPutRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiFlowByIdControllerPutRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiFlowByIdControllerPutRequest) Key(key string) ApiFlowByIdControllerPutRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerPutRequest) IntegrationId(integrationId string) ApiFlowByIdControllerPutRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerPutRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerPutRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerPutRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerPutRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerPutRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerPutExecute(r)
}

/*
FlowByIdControllerPut Update flow by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerPutRequest
*/
func (a *FlowsAPIService) FlowByIdControllerPut(ctx context.Context, id string) ApiFlowByIdControllerPutRequest {
	return ApiFlowByIdControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowByIdControllerPutExecute(r ApiFlowByIdControllerPutRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowByIdControllerResetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
	autoCreate *bool
}

func (r ApiFlowByIdControllerResetRequest) Key(key string) ApiFlowByIdControllerResetRequest {
	r.key = &key
	return r
}

func (r ApiFlowByIdControllerResetRequest) IntegrationId(integrationId string) ApiFlowByIdControllerResetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowByIdControllerResetRequest) IntegrationKey(integrationKey string) ApiFlowByIdControllerResetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowByIdControllerResetRequest) AutoCreate(autoCreate bool) ApiFlowByIdControllerResetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowByIdControllerResetRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowByIdControllerResetExecute(r)
}

/*
FlowByIdControllerReset Reset flow by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowByIdControllerResetRequest
*/
func (a *FlowsAPIService) FlowByIdControllerReset(ctx context.Context, id string) ApiFlowByIdControllerResetRequest {
	return ApiFlowByIdControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowByIdControllerResetExecute(r ApiFlowByIdControllerResetRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowByIdControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerArchiveFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerArchiveFlowInstance Archive flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerArchiveFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowInstanceByIdControllerArchiveFlowInstanceExecute(r ApiFlowInstanceByIdControllerArchiveFlowInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerArchiveFlowInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerCreateFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowInstanceDto *UpdateFlowInstanceDto
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) UpdateFlowInstanceDto(updateFlowInstanceDto UpdateFlowInstanceDto) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.updateFlowInstanceDto = &updateFlowInstanceDto
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerCreateFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerCreateFlowInstance Create flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerCreateFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerCreateFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerCreateFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerCreateFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) FlowInstanceByIdControllerCreateFlowInstanceExecute(r ApiFlowInstanceByIdControllerCreateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerCreateFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceDto is required and must be specified")
	}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerExportRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerExportRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerExportRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerExportRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerExportRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerExportRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerExportRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerExportRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerExportRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerExportRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerExportExecute(r)
}

/*
FlowInstanceByIdControllerExport Method for FlowInstanceByIdControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerExportRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerExport(ctx context.Context, id string) ApiFlowInstanceByIdControllerExportRequest {
	return ApiFlowInstanceByIdControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) FlowInstanceByIdControllerExportExecute(r ApiFlowInstanceByIdControllerExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerGetFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerGetFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerGetFlowInstance Get flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerGetFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerGetFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerGetFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerGetFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) FlowInstanceByIdControllerGetFlowInstanceExecute(r ApiFlowInstanceByIdControllerGetFlowInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerGetFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerPatchFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowInstanceDto *UpdateFlowInstanceDto
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) UpdateFlowInstanceDto(updateFlowInstanceDto UpdateFlowInstanceDto) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.updateFlowInstanceDto = &updateFlowInstanceDto
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerPatchFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerPatchFlowInstance Patch flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerPatchFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerPatchFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerPatchFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerPatchFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) FlowInstanceByIdControllerPatchFlowInstanceExecute(r ApiFlowInstanceByIdControllerPatchFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerPatchFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceDto is required and must be specified")
	}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerResetFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerResetFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerResetFlowInstance Reset flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerResetFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerResetFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerResetFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerResetFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) FlowInstanceByIdControllerResetFlowInstanceExecute(r ApiFlowInstanceByIdControllerResetFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerResetFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerSetupFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerSetupFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerSetupFlowInstance Setup flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerSetupFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerSetupFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerSetupFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerSetupFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) FlowInstanceByIdControllerSetupFlowInstanceExecute(r ApiFlowInstanceByIdControllerSetupFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerSetupFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	updateFlowInstanceDto *UpdateFlowInstanceDto
	flowId *string
	flowKey *string
	instanceKey *string
	autoCreate *bool
	autoUpdate *bool
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) UpdateFlowInstanceDto(updateFlowInstanceDto UpdateFlowInstanceDto) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.updateFlowInstanceDto = &updateFlowInstanceDto
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) FlowId(flowId string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) FlowKey(flowKey string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) InstanceKey(instanceKey string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) AutoCreate(autoCreate bool) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) AutoUpdate(autoUpdate bool) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.autoUpdate = &autoUpdate
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) IntegrationKey(integrationKey string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) IntegrationId(integrationId string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) ConnectionId(connectionId string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) Execute() (*FlowInstanceDto, *http.Response, error) {
	return r.ApiService.FlowInstanceByIdControllerUpdateFlowInstanceExecute(r)
}

/*
FlowInstanceByIdControllerUpdateFlowInstance Update flow instance by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest
*/
func (a *FlowsAPIService) FlowInstanceByIdControllerUpdateFlowInstance(ctx context.Context, id string) ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest {
	return ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowInstanceDto
func (a *FlowsAPIService) FlowInstanceByIdControllerUpdateFlowInstanceExecute(r ApiFlowInstanceByIdControllerUpdateFlowInstanceRequest) (*FlowInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstanceByIdControllerUpdateFlowInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowInstanceDto is required and must be specified")
	}

	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowInstancesControllerListFlowInstancesRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	instanceKey *string
	userId *string
	flowKey *string
	flowId *string
	universalFlowId *string
	enabled *bool
	connectionId *string
	integrationId *string
	integrationKey *string
	dependencyInstanceId *string
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Limit(limit float32) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.limit = &limit
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Cursor(cursor string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Search(search string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.search = &search
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) ConnectorId(connectorId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) IncludeArchived(includeArchived bool) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Id(id string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.id = &id
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) InstanceKey(instanceKey string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) UserId(userId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) FlowKey(flowKey string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) FlowId(flowId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) UniversalFlowId(universalFlowId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Enabled(enabled bool) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.enabled = &enabled
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) ConnectionId(connectionId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) IntegrationId(integrationId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) IntegrationKey(integrationKey string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) DependencyInstanceId(dependencyInstanceId string) ApiFlowInstancesControllerListFlowInstancesRequest {
	r.dependencyInstanceId = &dependencyInstanceId
	return r
}

func (r ApiFlowInstancesControllerListFlowInstancesRequest) Execute() (*FlowInstancesControllerListFlowInstances200Response, *http.Response, error) {
	return r.ApiService.FlowInstancesControllerListFlowInstancesExecute(r)
}

/*
FlowInstancesControllerListFlowInstances List flow instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlowInstancesControllerListFlowInstancesRequest
*/
func (a *FlowsAPIService) FlowInstancesControllerListFlowInstances(ctx context.Context) ApiFlowInstancesControllerListFlowInstancesRequest {
	return ApiFlowInstancesControllerListFlowInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowInstancesControllerListFlowInstances200Response
func (a *FlowsAPIService) FlowInstancesControllerListFlowInstancesExecute(r ApiFlowInstancesControllerListFlowInstancesRequest) (*FlowInstancesControllerListFlowInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowInstancesControllerListFlowInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowInstancesControllerListFlowInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.dependencyInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyInstanceId", r.dependencyInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowRunsControllerGetFlowNodeRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	nodeRunId string
}

func (r ApiFlowRunsControllerGetFlowNodeRunRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FlowRunsControllerGetFlowNodeRunExecute(r)
}

/*
FlowRunsControllerGetFlowNodeRun Get node run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @param nodeRunId
 @return ApiFlowRunsControllerGetFlowNodeRunRequest
*/
func (a *FlowsAPIService) FlowRunsControllerGetFlowNodeRun(ctx context.Context, id string, nodeKey string, nodeRunId string) ApiFlowRunsControllerGetFlowNodeRunRequest {
	return ApiFlowRunsControllerGetFlowNodeRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
		nodeRunId: nodeRunId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) FlowRunsControllerGetFlowNodeRunExecute(r ApiFlowRunsControllerGetFlowNodeRunRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerGetFlowNodeRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/runs/{nodeRunId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeRunId"+"}", url.PathEscape(parameterValueToString(r.nodeRunId, "nodeRunId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowRunsControllerGetFlowRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
}

func (r ApiFlowRunsControllerGetFlowRunRequest) Execute() (*FlowRunDto, *http.Response, error) {
	return r.ApiService.FlowRunsControllerGetFlowRunExecute(r)
}

/*
FlowRunsControllerGetFlowRun Get flow run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiFlowRunsControllerGetFlowRunRequest
*/
func (a *FlowsAPIService) FlowRunsControllerGetFlowRun(ctx context.Context, id string) ApiFlowRunsControllerGetFlowRunRequest {
	return ApiFlowRunsControllerGetFlowRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FlowRunDto
func (a *FlowsAPIService) FlowRunsControllerGetFlowRunExecute(r ApiFlowRunsControllerGetFlowRunRequest) (*FlowRunDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowRunDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerGetFlowRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowRunsControllerGetFlowRunOutputRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	cursor *string
}

func (r ApiFlowRunsControllerGetFlowRunOutputRequest) Cursor(cursor string) ApiFlowRunsControllerGetFlowRunOutputRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowRunsControllerGetFlowRunOutputRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowRunsControllerGetFlowRunOutputExecute(r)
}

/*
FlowRunsControllerGetFlowRunOutput Get flow run output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiFlowRunsControllerGetFlowRunOutputRequest
*/
func (a *FlowsAPIService) FlowRunsControllerGetFlowRunOutput(ctx context.Context, id string) ApiFlowRunsControllerGetFlowRunOutputRequest {
	return ApiFlowRunsControllerGetFlowRunOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowRunsControllerGetFlowRunOutputExecute(r ApiFlowRunsControllerGetFlowRunOutputRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerGetFlowRunOutput")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/output"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowRunsControllerGetFlowRunOutputForNodeRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	cursor *string
}

func (r ApiFlowRunsControllerGetFlowRunOutputForNodeRequest) Cursor(cursor string) ApiFlowRunsControllerGetFlowRunOutputForNodeRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowRunsControllerGetFlowRunOutputForNodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowRunsControllerGetFlowRunOutputForNodeExecute(r)
}

/*
FlowRunsControllerGetFlowRunOutputForNode Get flow run output for specific node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @return ApiFlowRunsControllerGetFlowRunOutputForNodeRequest
*/
func (a *FlowsAPIService) FlowRunsControllerGetFlowRunOutputForNode(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerGetFlowRunOutputForNodeRequest {
	return ApiFlowRunsControllerGetFlowRunOutputForNodeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowRunsControllerGetFlowRunOutputForNodeExecute(r ApiFlowRunsControllerGetFlowRunOutputForNodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerGetFlowRunOutputForNode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/output/{nodeKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowRunsControllerGetNodeRunOutputRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	outputId string
}

func (r ApiFlowRunsControllerGetNodeRunOutputRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FlowRunsControllerGetNodeRunOutputExecute(r)
}

/*
FlowRunsControllerGetNodeRunOutput Get node run output

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @param outputId
 @return ApiFlowRunsControllerGetNodeRunOutputRequest
*/
func (a *FlowsAPIService) FlowRunsControllerGetNodeRunOutput(ctx context.Context, id string, nodeKey string, outputId string) ApiFlowRunsControllerGetNodeRunOutputRequest {
	return ApiFlowRunsControllerGetNodeRunOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
		outputId: outputId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FlowsAPIService) FlowRunsControllerGetNodeRunOutputExecute(r ApiFlowRunsControllerGetNodeRunOutputRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerGetNodeRunOutput")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/outputs/{outputId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"outputId"+"}", url.PathEscape(parameterValueToString(r.outputId, "outputId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowRunsControllerListFlowNodeRunsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	cursor *string
}

func (r ApiFlowRunsControllerListFlowNodeRunsRequest) Cursor(cursor string) ApiFlowRunsControllerListFlowNodeRunsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowRunsControllerListFlowNodeRunsRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowRunsControllerListFlowNodeRunsExecute(r)
}

/*
FlowRunsControllerListFlowNodeRuns Get node runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @return ApiFlowRunsControllerListFlowNodeRunsRequest
*/
func (a *FlowsAPIService) FlowRunsControllerListFlowNodeRuns(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerListFlowNodeRunsRequest {
	return ApiFlowRunsControllerListFlowNodeRunsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowRunsControllerListFlowNodeRunsExecute(r ApiFlowRunsControllerListFlowNodeRunsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerListFlowNodeRuns")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowRunsControllerListFlowRunsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	id *string
	flowInstanceId *string
	startNodeKey *string
	flowId *string
	universalFlowId *string
	userId *string
	state *string
	integrationId *string
	connectionId *string
	startedAfter *string
}

func (r ApiFlowRunsControllerListFlowRunsRequest) Limit(limit float32) ApiFlowRunsControllerListFlowRunsRequest {
	r.limit = &limit
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) Cursor(cursor string) ApiFlowRunsControllerListFlowRunsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) Search(search string) ApiFlowRunsControllerListFlowRunsRequest {
	r.search = &search
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) ConnectorId(connectorId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) Id(id string) ApiFlowRunsControllerListFlowRunsRequest {
	r.id = &id
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) FlowInstanceId(flowInstanceId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.flowInstanceId = &flowInstanceId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) StartNodeKey(startNodeKey string) ApiFlowRunsControllerListFlowRunsRequest {
	r.startNodeKey = &startNodeKey
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) FlowId(flowId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) UniversalFlowId(universalFlowId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) UserId(userId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.userId = &userId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) State(state string) ApiFlowRunsControllerListFlowRunsRequest {
	r.state = &state
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) IntegrationId(integrationId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) ConnectionId(connectionId string) ApiFlowRunsControllerListFlowRunsRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) StartedAfter(startedAfter string) ApiFlowRunsControllerListFlowRunsRequest {
	r.startedAfter = &startedAfter
	return r
}

func (r ApiFlowRunsControllerListFlowRunsRequest) Execute() (*FlowRunsControllerListFlowRuns200Response, *http.Response, error) {
	return r.ApiService.FlowRunsControllerListFlowRunsExecute(r)
}

/*
FlowRunsControllerListFlowRuns List flow runs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlowRunsControllerListFlowRunsRequest
*/
func (a *FlowsAPIService) FlowRunsControllerListFlowRuns(ctx context.Context) ApiFlowRunsControllerListFlowRunsRequest {
	return ApiFlowRunsControllerListFlowRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowRunsControllerListFlowRuns200Response
func (a *FlowsAPIService) FlowRunsControllerListFlowRunsExecute(r ApiFlowRunsControllerListFlowRunsRequest) (*FlowRunsControllerListFlowRuns200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowRunsControllerListFlowRuns200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerListFlowRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.flowInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowInstanceId", r.flowInstanceId, "")
	}
	if r.startNodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startNodeKey", r.startNodeKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.startedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startedAfter", r.startedAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowRunsControllerListNodeRunOutputsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
	nodeKey string
	cursor *string
}

func (r ApiFlowRunsControllerListNodeRunOutputsRequest) Cursor(cursor string) ApiFlowRunsControllerListNodeRunOutputsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowRunsControllerListNodeRunOutputsRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowRunsControllerListNodeRunOutputsExecute(r)
}

/*
FlowRunsControllerListNodeRunOutputs Get node run outputs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param nodeKey
 @return ApiFlowRunsControllerListNodeRunOutputsRequest
*/
func (a *FlowsAPIService) FlowRunsControllerListNodeRunOutputs(ctx context.Context, id string, nodeKey string) ApiFlowRunsControllerListNodeRunOutputsRequest {
	return ApiFlowRunsControllerListNodeRunOutputsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodeKey: nodeKey,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowRunsControllerListNodeRunOutputsExecute(r ApiFlowRunsControllerListNodeRunOutputsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerListNodeRunOutputs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/nodes/{nodeKey}/outputs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeKey"+"}", url.PathEscape(parameterValueToString(r.nodeKey, "nodeKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cursor == nil {
		return nil, reportError("cursor is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowRunsControllerStopFlowRunRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	id string
}

func (r ApiFlowRunsControllerStopFlowRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlowRunsControllerStopFlowRunExecute(r)
}

/*
FlowRunsControllerStopFlowRun Stop flow run

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiFlowRunsControllerStopFlowRunRequest
*/
func (a *FlowsAPIService) FlowRunsControllerStopFlowRun(ctx context.Context, id string) ApiFlowRunsControllerStopFlowRunRequest {
	return ApiFlowRunsControllerStopFlowRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FlowsAPIService) FlowRunsControllerStopFlowRunExecute(r ApiFlowRunsControllerStopFlowRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowRunsControllerStopFlowRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow-runs/{id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlowsControllerCreateFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	createFlowDto *CreateFlowDto
}

func (r ApiFlowsControllerCreateFlowRequest) CreateFlowDto(createFlowDto CreateFlowDto) ApiFlowsControllerCreateFlowRequest {
	r.createFlowDto = &createFlowDto
	return r
}

func (r ApiFlowsControllerCreateFlowRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.FlowsControllerCreateFlowExecute(r)
}

/*
FlowsControllerCreateFlow Create flow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlowsControllerCreateFlowRequest
*/
func (a *FlowsAPIService) FlowsControllerCreateFlow(ctx context.Context) ApiFlowsControllerCreateFlowRequest {
	return ApiFlowsControllerCreateFlowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) FlowsControllerCreateFlowExecute(r ApiFlowsControllerCreateFlowRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowsControllerCreateFlow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFlowDto == nil {
		return localVarReturnValue, nil, reportError("createFlowDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlowsControllerListFlowsRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalFlowId *string
	integrationId *string
	integrationKey *string
}

func (r ApiFlowsControllerListFlowsRequest) Limit(limit float32) ApiFlowsControllerListFlowsRequest {
	r.limit = &limit
	return r
}

func (r ApiFlowsControllerListFlowsRequest) Cursor(cursor string) ApiFlowsControllerListFlowsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFlowsControllerListFlowsRequest) Search(search string) ApiFlowsControllerListFlowsRequest {
	r.search = &search
	return r
}

func (r ApiFlowsControllerListFlowsRequest) ConnectorId(connectorId string) ApiFlowsControllerListFlowsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiFlowsControllerListFlowsRequest) IncludeArchived(includeArchived bool) ApiFlowsControllerListFlowsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiFlowsControllerListFlowsRequest) UniversalFlowId(universalFlowId string) ApiFlowsControllerListFlowsRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiFlowsControllerListFlowsRequest) IntegrationId(integrationId string) ApiFlowsControllerListFlowsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFlowsControllerListFlowsRequest) IntegrationKey(integrationKey string) ApiFlowsControllerListFlowsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFlowsControllerListFlowsRequest) Execute() (*FlowsControllerListFlows200Response, *http.Response, error) {
	return r.ApiService.FlowsControllerListFlowsExecute(r)
}

/*
FlowsControllerListFlows List flows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlowsControllerListFlowsRequest
*/
func (a *FlowsAPIService) FlowsControllerListFlows(ctx context.Context) ApiFlowsControllerListFlowsRequest {
	return ApiFlowsControllerListFlowsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FlowsControllerListFlows200Response
func (a *FlowsAPIService) FlowsControllerListFlowsExecute(r ApiFlowsControllerListFlowsRequest) (*FlowsControllerListFlows200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowsControllerListFlows200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.FlowsControllerListFlows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowControllerArchiveRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFlowControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationLevelFlowControllerArchiveExecute(r)
}

/*
IntegrationLevelFlowControllerArchive Archive flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowControllerArchiveRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowControllerArchive(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerArchiveRequest {
	return ApiIntegrationLevelFlowControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
func (a *FlowsAPIService) IntegrationLevelFlowControllerArchiveExecute(r ApiIntegrationLevelFlowControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowControllerGetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFlowControllerGetRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowControllerGetExecute(r)
}

/*
IntegrationLevelFlowControllerGet Get flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowControllerGetRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowControllerGet(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerGetRequest {
	return ApiIntegrationLevelFlowControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) IntegrationLevelFlowControllerGetExecute(r ApiIntegrationLevelFlowControllerGetRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowControllerPatchRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	integrationSelector string
	updateFlowDto *UpdateFlowDto
}

func (r ApiIntegrationLevelFlowControllerPatchRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiIntegrationLevelFlowControllerPatchRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiIntegrationLevelFlowControllerPatchRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowControllerPatchExecute(r)
}

/*
IntegrationLevelFlowControllerPatch Patch update flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowControllerPatchRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowControllerPatch(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerPatchRequest {
	return ApiIntegrationLevelFlowControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) IntegrationLevelFlowControllerPatchExecute(r ApiIntegrationLevelFlowControllerPatchRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowControllerPutRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	integrationSelector string
	updateFlowDto *UpdateFlowDto
}

func (r ApiIntegrationLevelFlowControllerPutRequest) UpdateFlowDto(updateFlowDto UpdateFlowDto) ApiIntegrationLevelFlowControllerPutRequest {
	r.updateFlowDto = &updateFlowDto
	return r
}

func (r ApiIntegrationLevelFlowControllerPutRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowControllerPutExecute(r)
}

/*
IntegrationLevelFlowControllerPut Update flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowControllerPutRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowControllerPut(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerPutRequest {
	return ApiIntegrationLevelFlowControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) IntegrationLevelFlowControllerPutExecute(r ApiIntegrationLevelFlowControllerPutRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows/{flowSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFlowDto == nil {
		return localVarReturnValue, nil, reportError("updateFlowDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowControllerResetRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFlowControllerResetRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowControllerResetExecute(r)
}

/*
IntegrationLevelFlowControllerReset Reset flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowControllerResetRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowControllerReset(ctx context.Context, flowSelector string, integrationSelector string) ApiIntegrationLevelFlowControllerResetRequest {
	return ApiIntegrationLevelFlowControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) IntegrationLevelFlowControllerResetExecute(r ApiIntegrationLevelFlowControllerResetRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows/{flowSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowsControllerCreateRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	integrationSelector string
	createIntegrationLevelFlowDto *CreateIntegrationLevelFlowDto
}

func (r ApiIntegrationLevelFlowsControllerCreateRequest) CreateIntegrationLevelFlowDto(createIntegrationLevelFlowDto CreateIntegrationLevelFlowDto) ApiIntegrationLevelFlowsControllerCreateRequest {
	r.createIntegrationLevelFlowDto = &createIntegrationLevelFlowDto
	return r
}

func (r ApiIntegrationLevelFlowsControllerCreateRequest) Execute() (*FlowDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowsControllerCreateExecute(r)
}

/*
IntegrationLevelFlowsControllerCreate Create flow for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowsControllerCreateRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelFlowsControllerCreateRequest {
	return ApiIntegrationLevelFlowsControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowDto
func (a *FlowsAPIService) IntegrationLevelFlowsControllerCreateExecute(r ApiIntegrationLevelFlowsControllerCreateRequest) (*FlowDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowsControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationLevelFlowDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationLevelFlowDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationLevelFlowDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFlowsControllerListRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	integrationSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalFlowId *string
}

func (r ApiIntegrationLevelFlowsControllerListRequest) Limit(limit float32) ApiIntegrationLevelFlowsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) Cursor(cursor string) ApiIntegrationLevelFlowsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) Search(search string) ApiIntegrationLevelFlowsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) ConnectorId(connectorId string) ApiIntegrationLevelFlowsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) IncludeArchived(includeArchived bool) ApiIntegrationLevelFlowsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) UniversalFlowId(universalFlowId string) ApiIntegrationLevelFlowsControllerListRequest {
	r.universalFlowId = &universalFlowId
	return r
}

func (r ApiIntegrationLevelFlowsControllerListRequest) Execute() (*FlowsControllerListFlows200Response, *http.Response, error) {
	return r.ApiService.IntegrationLevelFlowsControllerListExecute(r)
}

/*
IntegrationLevelFlowsControllerList List flows for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFlowsControllerListRequest
*/
func (a *FlowsAPIService) IntegrationLevelFlowsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelFlowsControllerListRequest {
	return ApiIntegrationLevelFlowsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FlowsControllerListFlows200Response
func (a *FlowsAPIService) IntegrationLevelFlowsControllerListExecute(r ApiIntegrationLevelFlowsControllerListRequest) (*FlowsControllerListFlows200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FlowsControllerListFlows200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.IntegrationLevelFlowsControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalFlowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFlowId", r.universalFlowId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunFlowControllerRunFlowRequest struct {
	ctx context.Context
	ApiService FlowsAPI
	flowSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiRunFlowControllerRunFlowRequest) InstanceKey(instanceKey string) ApiRunFlowControllerRunFlowRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiRunFlowControllerRunFlowRequest) AutoCreate(autoCreate bool) ApiRunFlowControllerRunFlowRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiRunFlowControllerRunFlowRequest) Execute() (*http.Response, error) {
	return r.ApiService.RunFlowControllerRunFlowExecute(r)
}

/*
RunFlowControllerRunFlow Run flow instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param flowSelector Flow ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiRunFlowControllerRunFlowRequest
*/
func (a *FlowsAPIService) RunFlowControllerRunFlow(ctx context.Context, flowSelector string, connectionSelector string) ApiRunFlowControllerRunFlowRequest {
	return ApiRunFlowControllerRunFlowRequest{
		ApiService: a,
		ctx: ctx,
		flowSelector: flowSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *FlowsAPIService) RunFlowControllerRunFlowExecute(r ApiRunFlowControllerRunFlowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowsAPIService.RunFlowControllerRunFlow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/flows/{flowSelector}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"flowSelector"+"}", url.PathEscape(parameterValueToString(r.flowSelector, "flowSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
