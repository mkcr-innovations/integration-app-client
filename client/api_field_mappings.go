/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FieldMappingsAPI interface {

	/*
	ConnectionLevelFieldMappingControllerArchive Archive field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerArchiveRequest
	*/
	ConnectionLevelFieldMappingControllerArchive(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerArchiveRequest

	// ConnectionLevelFieldMappingControllerArchiveExecute executes the request
	ConnectionLevelFieldMappingControllerArchiveExecute(r ApiConnectionLevelFieldMappingControllerArchiveRequest) (*http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerCreate Create field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@param fieldMappingSelector Field Mapping ID or Key
	@return ApiConnectionLevelFieldMappingControllerCreateRequest
	*/
	ConnectionLevelFieldMappingControllerCreate(ctx context.Context, connectionSelector string, fieldMappingSelector string) ApiConnectionLevelFieldMappingControllerCreateRequest

	// ConnectionLevelFieldMappingControllerCreateExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerCreateExecute(r ApiConnectionLevelFieldMappingControllerCreateRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerGet Get field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerGetRequest
	*/
	ConnectionLevelFieldMappingControllerGet(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerGetRequest

	// ConnectionLevelFieldMappingControllerGetExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerGetExecute(r ApiConnectionLevelFieldMappingControllerGetRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerPatch Patch update field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerPatchRequest
	*/
	ConnectionLevelFieldMappingControllerPatch(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerPatchRequest

	// ConnectionLevelFieldMappingControllerPatchExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerPatchExecute(r ApiConnectionLevelFieldMappingControllerPatchRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerPut Update field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerPutRequest
	*/
	ConnectionLevelFieldMappingControllerPut(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerPutRequest

	// ConnectionLevelFieldMappingControllerPutExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerPutExecute(r ApiConnectionLevelFieldMappingControllerPutRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerReset Reset field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerResetRequest
	*/
	ConnectionLevelFieldMappingControllerReset(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerResetRequest

	// ConnectionLevelFieldMappingControllerResetExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerResetExecute(r ApiConnectionLevelFieldMappingControllerResetRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingControllerSetup Setup field mapping instance for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingControllerSetupRequest
	*/
	ConnectionLevelFieldMappingControllerSetup(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerSetupRequest

	// ConnectionLevelFieldMappingControllerSetupExecute executes the request
	//  @return FieldMappingInstanceDto
	ConnectionLevelFieldMappingControllerSetupExecute(r ApiConnectionLevelFieldMappingControllerSetupRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ConnectionLevelFieldMappingsControllerList List field mapping instances for connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionSelector Integration Key, Connection ID, or Integration ID
	@return ApiConnectionLevelFieldMappingsControllerListRequest
	*/
	ConnectionLevelFieldMappingsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelFieldMappingsControllerListRequest

	// ConnectionLevelFieldMappingsControllerListExecute executes the request
	ConnectionLevelFieldMappingsControllerListExecute(r ApiConnectionLevelFieldMappingsControllerListRequest) (*http.Response, error)

	/*
	FieldMappingByIdControllerApply Apply field mapping to integrations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerApplyRequest
	*/
	FieldMappingByIdControllerApply(ctx context.Context, id string) ApiFieldMappingByIdControllerApplyRequest

	// FieldMappingByIdControllerApplyExecute executes the request
	//  @return []FieldMappingDto
	FieldMappingByIdControllerApplyExecute(r ApiFieldMappingByIdControllerApplyRequest) ([]FieldMappingDto, *http.Response, error)

	/*
	FieldMappingByIdControllerArchive Archive field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerArchiveRequest
	*/
	FieldMappingByIdControllerArchive(ctx context.Context, id string) ApiFieldMappingByIdControllerArchiveRequest

	// FieldMappingByIdControllerArchiveExecute executes the request
	FieldMappingByIdControllerArchiveExecute(r ApiFieldMappingByIdControllerArchiveRequest) (*http.Response, error)

	/*
	FieldMappingByIdControllerClone Method for FieldMappingByIdControllerClone

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerCloneRequest
	*/
	FieldMappingByIdControllerClone(ctx context.Context, id string) ApiFieldMappingByIdControllerCloneRequest

	// FieldMappingByIdControllerCloneExecute executes the request
	//  @return FieldMappingDto
	FieldMappingByIdControllerCloneExecute(r ApiFieldMappingByIdControllerCloneRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingByIdControllerExport Method for FieldMappingByIdControllerExport

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerExportRequest
	*/
	FieldMappingByIdControllerExport(ctx context.Context, id string) ApiFieldMappingByIdControllerExportRequest

	// FieldMappingByIdControllerExportExecute executes the request
	//  @return FieldMappingExportDto
	FieldMappingByIdControllerExportExecute(r ApiFieldMappingByIdControllerExportRequest) (*FieldMappingExportDto, *http.Response, error)

	/*
	FieldMappingByIdControllerGet Get field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerGetRequest
	*/
	FieldMappingByIdControllerGet(ctx context.Context, id string) ApiFieldMappingByIdControllerGetRequest

	// FieldMappingByIdControllerGetExecute executes the request
	//  @return FieldMappingDto
	FieldMappingByIdControllerGetExecute(r ApiFieldMappingByIdControllerGetRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingByIdControllerGetAppSchema Get field mapping app schema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerGetAppSchemaRequest
	*/
	FieldMappingByIdControllerGetAppSchema(ctx context.Context, id string) ApiFieldMappingByIdControllerGetAppSchemaRequest

	// FieldMappingByIdControllerGetAppSchemaExecute executes the request
	//  @return map[string]interface{}
	FieldMappingByIdControllerGetAppSchemaExecute(r ApiFieldMappingByIdControllerGetAppSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	FieldMappingByIdControllerPatch Patch field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerPatchRequest
	*/
	FieldMappingByIdControllerPatch(ctx context.Context, id string) ApiFieldMappingByIdControllerPatchRequest

	// FieldMappingByIdControllerPatchExecute executes the request
	//  @return FieldMappingDto
	FieldMappingByIdControllerPatchExecute(r ApiFieldMappingByIdControllerPatchRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingByIdControllerPut Update field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerPutRequest
	*/
	FieldMappingByIdControllerPut(ctx context.Context, id string) ApiFieldMappingByIdControllerPutRequest

	// FieldMappingByIdControllerPutExecute executes the request
	//  @return FieldMappingDto
	FieldMappingByIdControllerPutExecute(r ApiFieldMappingByIdControllerPutRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingByIdControllerReset Reset field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingByIdControllerResetRequest
	*/
	FieldMappingByIdControllerReset(ctx context.Context, id string) ApiFieldMappingByIdControllerResetRequest

	// FieldMappingByIdControllerResetExecute executes the request
	//  @return FieldMappingDto
	FieldMappingByIdControllerResetExecute(r ApiFieldMappingByIdControllerResetRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerDeleteFieldMappingInstance Delete field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerDeleteFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerDeleteFieldMappingInstanceExecute executes the request
	FieldMappingInstanceByIdControllerDeleteFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) (*http.Response, error)

	/*
	FieldMappingInstanceByIdControllerGetFieldMappingInstance Get field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerGetFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerGetFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerGetFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerPatchFieldMappingInstance Patch field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerPatchFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerPatchFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerPatchFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerPostFieldMappingInstance Create field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerPostFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerPostFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerPostFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerPutFieldMappingInstance Update field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerPutFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerPutFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerPutFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerResetFieldMappingInstance Reset field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest
	*/
	FieldMappingInstanceByIdControllerResetFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest

	// FieldMappingInstanceByIdControllerResetFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerResetFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstanceByIdControllerSetup Setup field mapping instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID
	@return ApiFieldMappingInstanceByIdControllerSetupRequest
	*/
	FieldMappingInstanceByIdControllerSetup(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerSetupRequest

	// FieldMappingInstanceByIdControllerSetupExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingInstanceByIdControllerSetupExecute(r ApiFieldMappingInstanceByIdControllerSetupRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	FieldMappingInstancesControllerListFieldMappingInstances List field mapping instances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest
	*/
	FieldMappingInstancesControllerListFieldMappingInstances(ctx context.Context) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest

	// FieldMappingInstancesControllerListFieldMappingInstancesExecute executes the request
	//  @return FieldMappingInstancesControllerListFieldMappingInstances200Response
	FieldMappingInstancesControllerListFieldMappingInstancesExecute(r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) (*FieldMappingInstancesControllerListFieldMappingInstances200Response, *http.Response, error)

	/*
	FieldMappingsControllerCreate Create field mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFieldMappingsControllerCreateRequest
	*/
	FieldMappingsControllerCreate(ctx context.Context) ApiFieldMappingsControllerCreateRequest

	// FieldMappingsControllerCreateExecute executes the request
	//  @return FieldMappingDto
	FieldMappingsControllerCreateExecute(r ApiFieldMappingsControllerCreateRequest) (*FieldMappingDto, *http.Response, error)

	/*
	FieldMappingsControllerList List field mappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFieldMappingsControllerListRequest
	*/
	FieldMappingsControllerList(ctx context.Context) ApiFieldMappingsControllerListRequest

	// FieldMappingsControllerListExecute executes the request
	//  @return FieldMappingsControllerList200Response
	FieldMappingsControllerListExecute(r ApiFieldMappingsControllerListRequest) (*FieldMappingsControllerList200Response, *http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerArchive Archive filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerArchiveRequest
	*/
	IntegrationLevelFieldMappingControllerArchive(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerArchiveRequest

	// IntegrationLevelFieldMappingControllerArchiveExecute executes the request
	IntegrationLevelFieldMappingControllerArchiveExecute(r ApiIntegrationLevelFieldMappingControllerArchiveRequest) (*http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerGet Get filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerGetRequest
	*/
	IntegrationLevelFieldMappingControllerGet(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerGetRequest

	// IntegrationLevelFieldMappingControllerGetExecute executes the request
	//  @return FieldMappingDto
	IntegrationLevelFieldMappingControllerGetExecute(r ApiIntegrationLevelFieldMappingControllerGetRequest) (*FieldMappingDto, *http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerGetAppSchema Get field mapping app schema for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest
	*/
	IntegrationLevelFieldMappingControllerGetAppSchema(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest

	// IntegrationLevelFieldMappingControllerGetAppSchemaExecute executes the request
	//  @return map[string]interface{}
	IntegrationLevelFieldMappingControllerGetAppSchemaExecute(r ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerPatch Patch update filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerPatchRequest
	*/
	IntegrationLevelFieldMappingControllerPatch(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerPatchRequest

	// IntegrationLevelFieldMappingControllerPatchExecute executes the request
	//  @return FieldMappingDto
	IntegrationLevelFieldMappingControllerPatchExecute(r ApiIntegrationLevelFieldMappingControllerPatchRequest) (*FieldMappingDto, *http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerPut Update filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerPutRequest
	*/
	IntegrationLevelFieldMappingControllerPut(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerPutRequest

	// IntegrationLevelFieldMappingControllerPutExecute executes the request
	//  @return FieldMappingDto
	IntegrationLevelFieldMappingControllerPutExecute(r ApiIntegrationLevelFieldMappingControllerPutRequest) (*FieldMappingDto, *http.Response, error)

	/*
	IntegrationLevelFieldMappingControllerReset Reset filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldMappingSelector Field Mapping ID or Key
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingControllerResetRequest
	*/
	IntegrationLevelFieldMappingControllerReset(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerResetRequest

	// IntegrationLevelFieldMappingControllerResetExecute executes the request
	//  @return FieldMappingDto
	IntegrationLevelFieldMappingControllerResetExecute(r ApiIntegrationLevelFieldMappingControllerResetRequest) (*FieldMappingDto, *http.Response, error)

	/*
	IntegrationLevelFieldMappingsControllerCreate Create filed mapping for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingsControllerCreateRequest
	*/
	IntegrationLevelFieldMappingsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelFieldMappingsControllerCreateRequest

	// IntegrationLevelFieldMappingsControllerCreateExecute executes the request
	//  @return FieldMappingDto
	IntegrationLevelFieldMappingsControllerCreateExecute(r ApiIntegrationLevelFieldMappingsControllerCreateRequest) (*FieldMappingDto, *http.Response, error)

	/*
	IntegrationLevelFieldMappingsControllerList List filed mappings for integration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param integrationSelector Integration ID or Key
	@return ApiIntegrationLevelFieldMappingsControllerListRequest
	*/
	IntegrationLevelFieldMappingsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelFieldMappingsControllerListRequest

	// IntegrationLevelFieldMappingsControllerListExecute executes the request
	//  @return FieldMappingsControllerList200Response
	IntegrationLevelFieldMappingsControllerListExecute(r ApiIntegrationLevelFieldMappingsControllerListRequest) (*FieldMappingsControllerList200Response, *http.Response, error)
}

// FieldMappingsAPIService FieldMappingsAPI service
type FieldMappingsAPIService service

type ApiConnectionLevelFieldMappingControllerArchiveRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerArchiveRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerArchiveRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerArchiveRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerArchiveRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerArchiveExecute(r)
}

/*
ConnectionLevelFieldMappingControllerArchive Archive field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerArchiveRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerArchive(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerArchiveRequest {
	return ApiConnectionLevelFieldMappingControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerArchiveExecute(r ApiConnectionLevelFieldMappingControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerCreateRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	connectionSelector string
	fieldMappingSelector string
	instanceKey *string
}

func (r ApiConnectionLevelFieldMappingControllerCreateRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerCreateRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerCreateRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerCreateExecute(r)
}

/*
ConnectionLevelFieldMappingControllerCreate Create field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @param fieldMappingSelector Field Mapping ID or Key
 @return ApiConnectionLevelFieldMappingControllerCreateRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerCreate(ctx context.Context, connectionSelector string, fieldMappingSelector string) ApiConnectionLevelFieldMappingControllerCreateRequest {
	return ApiConnectionLevelFieldMappingControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
		fieldMappingSelector: fieldMappingSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerCreateExecute(r ApiConnectionLevelFieldMappingControllerCreateRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerGetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerGetRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerGetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerGetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerGetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerGetRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerGetExecute(r)
}

/*
ConnectionLevelFieldMappingControllerGet Get field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerGetRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerGet(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerGetRequest {
	return ApiConnectionLevelFieldMappingControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerGetExecute(r ApiConnectionLevelFieldMappingControllerGetRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerPatchRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerPatchRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiConnectionLevelFieldMappingControllerPatchRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPatchRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerPatchRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPatchRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerPatchRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPatchRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerPatchExecute(r)
}

/*
ConnectionLevelFieldMappingControllerPatch Patch update field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerPatchRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerPatch(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerPatchRequest {
	return ApiConnectionLevelFieldMappingControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerPatchExecute(r ApiConnectionLevelFieldMappingControllerPatchRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerPutRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerPutRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiConnectionLevelFieldMappingControllerPutRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPutRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerPutRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPutRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerPutRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerPutRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerPutExecute(r)
}

/*
ConnectionLevelFieldMappingControllerPut Update field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerPutRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerPut(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerPutRequest {
	return ApiConnectionLevelFieldMappingControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerPutExecute(r ApiConnectionLevelFieldMappingControllerPutRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerResetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerResetRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerResetRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerResetRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerResetRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerResetRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerResetExecute(r)
}

/*
ConnectionLevelFieldMappingControllerReset Reset field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerResetRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerReset(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerResetRequest {
	return ApiConnectionLevelFieldMappingControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerResetExecute(r ApiConnectionLevelFieldMappingControllerResetRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingControllerSetupRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	connectionSelector string
	instanceKey *string
	autoCreate *bool
}

func (r ApiConnectionLevelFieldMappingControllerSetupRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingControllerSetupRequest) AutoCreate(autoCreate bool) ApiConnectionLevelFieldMappingControllerSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiConnectionLevelFieldMappingControllerSetupRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingControllerSetupExecute(r)
}

/*
ConnectionLevelFieldMappingControllerSetup Setup field mapping instance for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingControllerSetupRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerSetup(ctx context.Context, fieldMappingSelector string, connectionSelector string) ApiConnectionLevelFieldMappingControllerSetupRequest {
	return ApiConnectionLevelFieldMappingControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingControllerSetupExecute(r ApiConnectionLevelFieldMappingControllerSetupRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings/{fieldMappingSelector}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionLevelFieldMappingsControllerListRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	connectionSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	instanceKey *string
	userId *string
	fieldMappingId *string
	universalFieldMappingId *string
	dataSourceInstanceId *string
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) Limit(limit float32) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) Cursor(cursor string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) Search(search string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) ConnectorId(connectorId string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) IncludeArchived(includeArchived bool) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) Id(id string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.id = &id
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) InstanceKey(instanceKey string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) UserId(userId string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.userId = &userId
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) FieldMappingId(fieldMappingId string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) UniversalFieldMappingId(universalFieldMappingId string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.universalFieldMappingId = &universalFieldMappingId
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) DataSourceInstanceId(dataSourceInstanceId string) ApiConnectionLevelFieldMappingsControllerListRequest {
	r.dataSourceInstanceId = &dataSourceInstanceId
	return r
}

func (r ApiConnectionLevelFieldMappingsControllerListRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionLevelFieldMappingsControllerListExecute(r)
}

/*
ConnectionLevelFieldMappingsControllerList List field mapping instances for connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionSelector Integration Key, Connection ID, or Integration ID
 @return ApiConnectionLevelFieldMappingsControllerListRequest
*/
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingsControllerList(ctx context.Context, connectionSelector string) ApiConnectionLevelFieldMappingsControllerListRequest {
	return ApiConnectionLevelFieldMappingsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		connectionSelector: connectionSelector,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) ConnectionLevelFieldMappingsControllerListExecute(r ApiConnectionLevelFieldMappingsControllerListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ConnectionLevelFieldMappingsControllerList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionSelector}/field-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionSelector"+"}", url.PathEscape(parameterValueToString(r.connectionSelector, "connectionSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.universalFieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFieldMappingId", r.universalFieldMappingId, "")
	}
	if r.dataSourceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceInstanceId", r.dataSourceInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerApplyRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerApplyRequest) Key(key string) ApiFieldMappingByIdControllerApplyRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerApplyRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerApplyRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerApplyRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerApplyRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerApplyRequest) Execute() ([]FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerApplyExecute(r)
}

/*
FieldMappingByIdControllerApply Apply field mapping to integrations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerApplyRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerApply(ctx context.Context, id string) ApiFieldMappingByIdControllerApplyRequest {
	return ApiFieldMappingByIdControllerApplyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerApplyExecute(r ApiFieldMappingByIdControllerApplyRequest) ([]FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerApply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerArchiveRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerArchiveRequest) Key(key string) ApiFieldMappingByIdControllerArchiveRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerArchiveRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerArchiveRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerArchiveRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerArchiveRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerArchiveExecute(r)
}

/*
FieldMappingByIdControllerArchive Archive field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerArchiveRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerArchive(ctx context.Context, id string) ApiFieldMappingByIdControllerArchiveRequest {
	return ApiFieldMappingByIdControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) FieldMappingByIdControllerArchiveExecute(r ApiFieldMappingByIdControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerCloneRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerCloneRequest) Key(key string) ApiFieldMappingByIdControllerCloneRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerCloneRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerCloneRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerCloneRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerCloneRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerCloneRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerCloneExecute(r)
}

/*
FieldMappingByIdControllerClone Method for FieldMappingByIdControllerClone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerCloneRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerClone(ctx context.Context, id string) ApiFieldMappingByIdControllerCloneRequest {
	return ApiFieldMappingByIdControllerCloneRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerCloneExecute(r ApiFieldMappingByIdControllerCloneRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerExportRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerExportRequest) Key(key string) ApiFieldMappingByIdControllerExportRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerExportRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerExportRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerExportRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerExportRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerExportRequest) Execute() (*FieldMappingExportDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerExportExecute(r)
}

/*
FieldMappingByIdControllerExport Method for FieldMappingByIdControllerExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerExportRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerExport(ctx context.Context, id string) ApiFieldMappingByIdControllerExportRequest {
	return ApiFieldMappingByIdControllerExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingExportDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerExportExecute(r ApiFieldMappingByIdControllerExportRequest) (*FieldMappingExportDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingExportDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerGetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerGetRequest) Key(key string) ApiFieldMappingByIdControllerGetRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerGetRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerGetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerGetRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerGetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerGetRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerGetExecute(r)
}

/*
FieldMappingByIdControllerGet Get field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerGetRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerGet(ctx context.Context, id string) ApiFieldMappingByIdControllerGetRequest {
	return ApiFieldMappingByIdControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerGetExecute(r ApiFieldMappingByIdControllerGetRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerGetAppSchemaRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerGetAppSchemaRequest) Key(key string) ApiFieldMappingByIdControllerGetAppSchemaRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerGetAppSchemaRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerGetAppSchemaRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerGetAppSchemaRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerGetAppSchemaRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerGetAppSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerGetAppSchemaExecute(r)
}

/*
FieldMappingByIdControllerGetAppSchema Get field mapping app schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerGetAppSchemaRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerGetAppSchema(ctx context.Context, id string) ApiFieldMappingByIdControllerGetAppSchemaRequest {
	return ApiFieldMappingByIdControllerGetAppSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FieldMappingsAPIService) FieldMappingByIdControllerGetAppSchemaExecute(r ApiFieldMappingByIdControllerGetAppSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerGetAppSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/app-schema"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerPatchRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingDto *UpdateFieldMappingDto
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerPatchRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiFieldMappingByIdControllerPatchRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiFieldMappingByIdControllerPatchRequest) Key(key string) ApiFieldMappingByIdControllerPatchRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerPatchRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerPatchRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerPatchRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerPatchRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerPatchRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerPatchExecute(r)
}

/*
FieldMappingByIdControllerPatch Patch field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerPatchRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerPatch(ctx context.Context, id string) ApiFieldMappingByIdControllerPatchRequest {
	return ApiFieldMappingByIdControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerPatchExecute(r ApiFieldMappingByIdControllerPatchRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerPutRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingDto *UpdateFieldMappingDto
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerPutRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiFieldMappingByIdControllerPutRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiFieldMappingByIdControllerPutRequest) Key(key string) ApiFieldMappingByIdControllerPutRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerPutRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerPutRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerPutRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerPutRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerPutRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerPutExecute(r)
}

/*
FieldMappingByIdControllerPut Update field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerPutRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerPut(ctx context.Context, id string) ApiFieldMappingByIdControllerPutRequest {
	return ApiFieldMappingByIdControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerPutExecute(r ApiFieldMappingByIdControllerPutRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingByIdControllerResetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiFieldMappingByIdControllerResetRequest) Key(key string) ApiFieldMappingByIdControllerResetRequest {
	r.key = &key
	return r
}

func (r ApiFieldMappingByIdControllerResetRequest) IntegrationId(integrationId string) ApiFieldMappingByIdControllerResetRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingByIdControllerResetRequest) IntegrationKey(integrationKey string) ApiFieldMappingByIdControllerResetRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingByIdControllerResetRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingByIdControllerResetExecute(r)
}

/*
FieldMappingByIdControllerReset Reset field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingByIdControllerResetRequest
*/
func (a *FieldMappingsAPIService) FieldMappingByIdControllerReset(ctx context.Context, id string) ApiFieldMappingByIdControllerResetRequest {
	return ApiFieldMappingByIdControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingByIdControllerResetExecute(r ApiFieldMappingByIdControllerResetRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingByIdControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerDeleteFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerDeleteFieldMappingInstance Delete field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerDeleteFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerDeleteFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerDeleteFieldMappingInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerDeleteFieldMappingInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerGetFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerGetFieldMappingInstance Get field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerGetFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerGetFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerGetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerGetFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerPatchFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerPatchFieldMappingInstance Patch field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPatchFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPatchFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPatchFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerPatchFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerPostFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerPostFieldMappingInstance Create field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPostFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPostFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPostFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerPostFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerPutFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerPutFieldMappingInstance Update field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPutFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerPutFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerPutFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerPutFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerResetFieldMappingInstanceExecute(r)
}

/*
FieldMappingInstanceByIdControllerResetFieldMappingInstance Reset field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerResetFieldMappingInstance(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest {
	return ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerResetFieldMappingInstanceExecute(r ApiFieldMappingInstanceByIdControllerResetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerResetFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstanceByIdControllerSetupRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) InstanceKey(instanceKey string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) AutoCreate(autoCreate bool) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) FlowKey(flowKey string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) FlowId(flowId string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) NodeKey(nodeKey string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) IntegrationId(integrationId string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) ConnectionId(connectionId string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstanceByIdControllerSetupRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingInstanceByIdControllerSetupExecute(r)
}

/*
FieldMappingInstanceByIdControllerSetup Setup field mapping instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID
 @return ApiFieldMappingInstanceByIdControllerSetupRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerSetup(ctx context.Context, id string) ApiFieldMappingInstanceByIdControllerSetupRequest {
	return ApiFieldMappingInstanceByIdControllerSetupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingInstanceByIdControllerSetupExecute(r ApiFieldMappingInstanceByIdControllerSetupRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstanceByIdControllerSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances/{id}/setup"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	instanceKey *string
	userId *string
	connectionId *string
	integrationId *string
	integrationKey *string
	fieldMappingId *string
	universalFieldMappingId *string
	dataSourceInstanceId *string
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) Limit(limit float32) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.limit = &limit
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) Cursor(cursor string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) Search(search string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.search = &search
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) ConnectorId(connectorId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) IncludeArchived(includeArchived bool) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) Id(id string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.id = &id
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) InstanceKey(instanceKey string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) UserId(userId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) ConnectionId(connectionId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) IntegrationId(integrationId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) IntegrationKey(integrationKey string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) UniversalFieldMappingId(universalFieldMappingId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.universalFieldMappingId = &universalFieldMappingId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) DataSourceInstanceId(dataSourceInstanceId string) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	r.dataSourceInstanceId = &dataSourceInstanceId
	return r
}

func (r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) Execute() (*FieldMappingInstancesControllerListFieldMappingInstances200Response, *http.Response, error) {
	return r.ApiService.FieldMappingInstancesControllerListFieldMappingInstancesExecute(r)
}

/*
FieldMappingInstancesControllerListFieldMappingInstances List field mapping instances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest
*/
func (a *FieldMappingsAPIService) FieldMappingInstancesControllerListFieldMappingInstances(ctx context.Context) ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest {
	return ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstancesControllerListFieldMappingInstances200Response
func (a *FieldMappingsAPIService) FieldMappingInstancesControllerListFieldMappingInstancesExecute(r ApiFieldMappingInstancesControllerListFieldMappingInstancesRequest) (*FieldMappingInstancesControllerListFieldMappingInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstancesControllerListFieldMappingInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingInstancesControllerListFieldMappingInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.universalFieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFieldMappingId", r.universalFieldMappingId, "")
	}
	if r.dataSourceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceInstanceId", r.dataSourceInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingsControllerCreateRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	createFieldMappingDto *CreateFieldMappingDto
}

func (r ApiFieldMappingsControllerCreateRequest) CreateFieldMappingDto(createFieldMappingDto CreateFieldMappingDto) ApiFieldMappingsControllerCreateRequest {
	r.createFieldMappingDto = &createFieldMappingDto
	return r
}

func (r ApiFieldMappingsControllerCreateRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.FieldMappingsControllerCreateExecute(r)
}

/*
FieldMappingsControllerCreate Create field mapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldMappingsControllerCreateRequest
*/
func (a *FieldMappingsAPIService) FieldMappingsControllerCreate(ctx context.Context) ApiFieldMappingsControllerCreateRequest {
	return ApiFieldMappingsControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) FieldMappingsControllerCreateExecute(r ApiFieldMappingsControllerCreateRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingsControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("createFieldMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFieldMappingsControllerListRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalFieldMappingId *string
	integrationId *string
}

func (r ApiFieldMappingsControllerListRequest) Limit(limit float32) ApiFieldMappingsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiFieldMappingsControllerListRequest) Cursor(cursor string) ApiFieldMappingsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFieldMappingsControllerListRequest) Search(search string) ApiFieldMappingsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiFieldMappingsControllerListRequest) ConnectorId(connectorId string) ApiFieldMappingsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiFieldMappingsControllerListRequest) IncludeArchived(includeArchived bool) ApiFieldMappingsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiFieldMappingsControllerListRequest) UniversalFieldMappingId(universalFieldMappingId string) ApiFieldMappingsControllerListRequest {
	r.universalFieldMappingId = &universalFieldMappingId
	return r
}

func (r ApiFieldMappingsControllerListRequest) IntegrationId(integrationId string) ApiFieldMappingsControllerListRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingsControllerListRequest) Execute() (*FieldMappingsControllerList200Response, *http.Response, error) {
	return r.ApiService.FieldMappingsControllerListExecute(r)
}

/*
FieldMappingsControllerList List field mappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldMappingsControllerListRequest
*/
func (a *FieldMappingsAPIService) FieldMappingsControllerList(ctx context.Context) ApiFieldMappingsControllerListRequest {
	return ApiFieldMappingsControllerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingsControllerList200Response
func (a *FieldMappingsAPIService) FieldMappingsControllerListExecute(r ApiFieldMappingsControllerListRequest) (*FieldMappingsControllerList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingsControllerList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingsControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalFieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFieldMappingId", r.universalFieldMappingId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerArchiveRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFieldMappingControllerArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerArchiveExecute(r)
}

/*
IntegrationLevelFieldMappingControllerArchive Archive filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerArchiveRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerArchive(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerArchiveRequest {
	return ApiIntegrationLevelFieldMappingControllerArchiveRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerArchiveExecute(r ApiIntegrationLevelFieldMappingControllerArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerGetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFieldMappingControllerGetRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerGetExecute(r)
}

/*
IntegrationLevelFieldMappingControllerGet Get filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerGetRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerGet(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerGetRequest {
	return ApiIntegrationLevelFieldMappingControllerGetRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerGetExecute(r ApiIntegrationLevelFieldMappingControllerGetRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerGetAppSchemaExecute(r)
}

/*
IntegrationLevelFieldMappingControllerGetAppSchema Get field mapping app schema for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerGetAppSchema(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest {
	return ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerGetAppSchemaExecute(r ApiIntegrationLevelFieldMappingControllerGetAppSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerGetAppSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}/app-schema"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerPatchRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
	updateFieldMappingDto *UpdateFieldMappingDto
}

func (r ApiIntegrationLevelFieldMappingControllerPatchRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiIntegrationLevelFieldMappingControllerPatchRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiIntegrationLevelFieldMappingControllerPatchRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerPatchExecute(r)
}

/*
IntegrationLevelFieldMappingControllerPatch Patch update filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerPatchRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerPatch(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerPatchRequest {
	return ApiIntegrationLevelFieldMappingControllerPatchRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerPatchExecute(r ApiIntegrationLevelFieldMappingControllerPatchRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerPutRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
	updateFieldMappingDto *UpdateFieldMappingDto
}

func (r ApiIntegrationLevelFieldMappingControllerPutRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiIntegrationLevelFieldMappingControllerPutRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiIntegrationLevelFieldMappingControllerPutRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerPutExecute(r)
}

/*
IntegrationLevelFieldMappingControllerPut Update filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerPutRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerPut(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerPutRequest {
	return ApiIntegrationLevelFieldMappingControllerPutRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerPutExecute(r ApiIntegrationLevelFieldMappingControllerPutRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingControllerResetRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	fieldMappingSelector string
	integrationSelector string
}

func (r ApiIntegrationLevelFieldMappingControllerResetRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingControllerResetExecute(r)
}

/*
IntegrationLevelFieldMappingControllerReset Reset filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldMappingSelector Field Mapping ID or Key
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingControllerResetRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerReset(ctx context.Context, fieldMappingSelector string, integrationSelector string) ApiIntegrationLevelFieldMappingControllerResetRequest {
	return ApiIntegrationLevelFieldMappingControllerResetRequest{
		ApiService: a,
		ctx: ctx,
		fieldMappingSelector: fieldMappingSelector,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingControllerResetExecute(r ApiIntegrationLevelFieldMappingControllerResetRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingControllerReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings/{fieldMappingSelector}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldMappingSelector"+"}", url.PathEscape(parameterValueToString(r.fieldMappingSelector, "fieldMappingSelector")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingsControllerCreateRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	integrationSelector string
	createIntegrationLevelFieldMappingDto *CreateIntegrationLevelFieldMappingDto
}

func (r ApiIntegrationLevelFieldMappingsControllerCreateRequest) CreateIntegrationLevelFieldMappingDto(createIntegrationLevelFieldMappingDto CreateIntegrationLevelFieldMappingDto) ApiIntegrationLevelFieldMappingsControllerCreateRequest {
	r.createIntegrationLevelFieldMappingDto = &createIntegrationLevelFieldMappingDto
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerCreateRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingsControllerCreateExecute(r)
}

/*
IntegrationLevelFieldMappingsControllerCreate Create filed mapping for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingsControllerCreateRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingsControllerCreate(ctx context.Context, integrationSelector string) ApiIntegrationLevelFieldMappingsControllerCreateRequest {
	return ApiIntegrationLevelFieldMappingsControllerCreateRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingsControllerCreateExecute(r ApiIntegrationLevelFieldMappingsControllerCreateRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingsControllerCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIntegrationLevelFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("createIntegrationLevelFieldMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIntegrationLevelFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIntegrationLevelFieldMappingsControllerListRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	integrationSelector string
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	universalFieldMappingId *string
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) Limit(limit float32) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.limit = &limit
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) Cursor(cursor string) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) Search(search string) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.search = &search
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) ConnectorId(connectorId string) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) IncludeArchived(includeArchived bool) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) UniversalFieldMappingId(universalFieldMappingId string) ApiIntegrationLevelFieldMappingsControllerListRequest {
	r.universalFieldMappingId = &universalFieldMappingId
	return r
}

func (r ApiIntegrationLevelFieldMappingsControllerListRequest) Execute() (*FieldMappingsControllerList200Response, *http.Response, error) {
	return r.ApiService.IntegrationLevelFieldMappingsControllerListExecute(r)
}

/*
IntegrationLevelFieldMappingsControllerList List filed mappings for integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationSelector Integration ID or Key
 @return ApiIntegrationLevelFieldMappingsControllerListRequest
*/
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingsControllerList(ctx context.Context, integrationSelector string) ApiIntegrationLevelFieldMappingsControllerListRequest {
	return ApiIntegrationLevelFieldMappingsControllerListRequest{
		ApiService: a,
		ctx: ctx,
		integrationSelector: integrationSelector,
	}
}

// Execute executes the request
//  @return FieldMappingsControllerList200Response
func (a *FieldMappingsAPIService) IntegrationLevelFieldMappingsControllerListExecute(r ApiIntegrationLevelFieldMappingsControllerListRequest) (*FieldMappingsControllerList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingsControllerList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.IntegrationLevelFieldMappingsControllerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/integrations/{integrationSelector}/field-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"integrationSelector"+"}", url.PathEscape(parameterValueToString(r.integrationSelector, "integrationSelector")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.universalFieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFieldMappingId", r.universalFieldMappingId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
