/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FieldMappingsAPI interface {

	/*
	ApplyFieldMapping Method for ApplyFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to apply
	@return ApiApplyFieldMappingRequest
	*/
	ApplyFieldMapping(ctx context.Context, id string) ApiApplyFieldMappingRequest

	// ApplyFieldMappingExecute executes the request
	//  @return []FieldMappingDto
	ApplyFieldMappingExecute(r ApiApplyFieldMappingRequest) ([]FieldMappingDto, *http.Response, error)

	/*
	ApplyFieldMappings Method for ApplyFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApplyFieldMappingsRequest
	*/
	ApplyFieldMappings(ctx context.Context) ApiApplyFieldMappingsRequest

	// ApplyFieldMappingsExecute executes the request
	//  @return []FieldMappingDto
	ApplyFieldMappingsExecute(r ApiApplyFieldMappingsRequest) ([]FieldMappingDto, *http.Response, error)

	/*
	ArchiveFieldMapping Method for ArchiveFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to retrive
	@return ApiArchiveFieldMappingRequest
	*/
	ArchiveFieldMapping(ctx context.Context, id string) ApiArchiveFieldMappingRequest

	// ArchiveFieldMappingExecute executes the request
	ArchiveFieldMappingExecute(r ApiArchiveFieldMappingRequest) (*http.Response, error)

	/*
	ArchiveFieldMappings Method for ArchiveFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveFieldMappingsRequest
	*/
	ArchiveFieldMappings(ctx context.Context) ApiArchiveFieldMappingsRequest

	// ArchiveFieldMappingsExecute executes the request
	ArchiveFieldMappingsExecute(r ApiArchiveFieldMappingsRequest) (*http.Response, error)

	/*
	CreateFieldMapping Method for CreateFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFieldMappingRequest
	*/
	CreateFieldMapping(ctx context.Context) ApiCreateFieldMappingRequest

	// CreateFieldMappingExecute executes the request
	//  @return FieldMappingDto
	CreateFieldMappingExecute(r ApiCreateFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	DeleteFieldMappingInstance Method for DeleteFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteFieldMappingInstanceRequest
	*/
	DeleteFieldMappingInstance(ctx context.Context) ApiDeleteFieldMappingInstanceRequest

	// DeleteFieldMappingInstanceExecute executes the request
	DeleteFieldMappingInstanceExecute(r ApiDeleteFieldMappingInstanceRequest) (*http.Response, error)

	/*
	FieldMappingSetup Method for FieldMappingSetup

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFieldMappingSetupRequest
	*/
	FieldMappingSetup(ctx context.Context) ApiFieldMappingSetupRequest

	// FieldMappingSetupExecute executes the request
	//  @return FieldMappingInstanceDto
	FieldMappingSetupExecute(r ApiFieldMappingSetupRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	GetFieldMapping Method for GetFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to retrive
	@return ApiGetFieldMappingRequest
	*/
	GetFieldMapping(ctx context.Context, id string) ApiGetFieldMappingRequest

	// GetFieldMappingExecute executes the request
	//  @return FieldMappingDto
	GetFieldMappingExecute(r ApiGetFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	GetFieldMappingAppSchema Method for GetFieldMappingAppSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mappping
	@return ApiGetFieldMappingAppSchemaRequest
	*/
	GetFieldMappingAppSchema(ctx context.Context, id string) ApiGetFieldMappingAppSchemaRequest

	// GetFieldMappingAppSchemaExecute executes the request
	//  @return map[string]interface{}
	GetFieldMappingAppSchemaExecute(r ApiGetFieldMappingAppSchemaRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetFieldMappingAppSchemas Method for GetFieldMappingAppSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFieldMappingAppSchemasRequest
	*/
	GetFieldMappingAppSchemas(ctx context.Context) ApiGetFieldMappingAppSchemasRequest

	// GetFieldMappingAppSchemasExecute executes the request
	//  @return map[string]interface{}
	GetFieldMappingAppSchemasExecute(r ApiGetFieldMappingAppSchemasRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetFieldMappingInstance Method for GetFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetFieldMappingInstanceRequest
	*/
	GetFieldMappingInstance(ctx context.Context) ApiGetFieldMappingInstanceRequest

	// GetFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	GetFieldMappingInstanceExecute(r ApiGetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ListFieldMapping Method for ListFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFieldMappingRequest
	*/
	ListFieldMapping(ctx context.Context) ApiListFieldMappingRequest

	// ListFieldMappingExecute executes the request
	//  @return FieldMappingDto
	ListFieldMappingExecute(r ApiListFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	ListFieldMappingInstances Method for ListFieldMappingInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFieldMappingInstancesRequest
	*/
	ListFieldMappingInstances(ctx context.Context) ApiListFieldMappingInstancesRequest

	// ListFieldMappingInstancesExecute executes the request
	//  @return ListFieldMappingInstances200Response
	ListFieldMappingInstancesExecute(r ApiListFieldMappingInstancesRequest) (*ListFieldMappingInstances200Response, *http.Response, error)

	/*
	ListFieldMappings Method for ListFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFieldMappingsRequest
	*/
	ListFieldMappings(ctx context.Context) ApiListFieldMappingsRequest

	// ListFieldMappingsExecute executes the request
	//  @return ListFieldMappings200Response
	ListFieldMappingsExecute(r ApiListFieldMappingsRequest) (*ListFieldMappings200Response, *http.Response, error)

	/*
	PatchFieldMapping Method for PatchFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to retrive
	@return ApiPatchFieldMappingRequest
	*/
	PatchFieldMapping(ctx context.Context, id string) ApiPatchFieldMappingRequest

	// PatchFieldMappingExecute executes the request
	//  @return FieldMappingDto
	PatchFieldMappingExecute(r ApiPatchFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	PatchFieldMappingInstance Method for PatchFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchFieldMappingInstanceRequest
	*/
	PatchFieldMappingInstance(ctx context.Context) ApiPatchFieldMappingInstanceRequest

	// PatchFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	PatchFieldMappingInstanceExecute(r ApiPatchFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	PatchFieldMappings Method for PatchFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchFieldMappingsRequest
	*/
	PatchFieldMappings(ctx context.Context) ApiPatchFieldMappingsRequest

	// PatchFieldMappingsExecute executes the request
	//  @return FieldMappingDto
	PatchFieldMappingsExecute(r ApiPatchFieldMappingsRequest) (*FieldMappingDto, *http.Response, error)

	/*
	PostFieldMappingInstance Method for PostFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostFieldMappingInstanceRequest
	*/
	PostFieldMappingInstance(ctx context.Context) ApiPostFieldMappingInstanceRequest

	// PostFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	PostFieldMappingInstanceExecute(r ApiPostFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	PutFieldMapping Method for PutFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to retrive
	@return ApiPutFieldMappingRequest
	*/
	PutFieldMapping(ctx context.Context, id string) ApiPutFieldMappingRequest

	// PutFieldMappingExecute executes the request
	//  @return FieldMappingDto
	PutFieldMappingExecute(r ApiPutFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	PutFieldMappingInstance Method for PutFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutFieldMappingInstanceRequest
	*/
	PutFieldMappingInstance(ctx context.Context) ApiPutFieldMappingInstanceRequest

	// PutFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	PutFieldMappingInstanceExecute(r ApiPutFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	PutFieldMappings Method for PutFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutFieldMappingsRequest
	*/
	PutFieldMappings(ctx context.Context) ApiPutFieldMappingsRequest

	// PutFieldMappingsExecute executes the request
	//  @return FieldMappingDto
	PutFieldMappingsExecute(r ApiPutFieldMappingsRequest) (*FieldMappingDto, *http.Response, error)

	/*
	ResetFieldMapping Method for ResetFieldMapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the field-mapping to reset
	@return ApiResetFieldMappingRequest
	*/
	ResetFieldMapping(ctx context.Context, id string) ApiResetFieldMappingRequest

	// ResetFieldMappingExecute executes the request
	//  @return FieldMappingDto
	ResetFieldMappingExecute(r ApiResetFieldMappingRequest) (*FieldMappingDto, *http.Response, error)

	/*
	ResetFieldMappingInstance Method for ResetFieldMappingInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetFieldMappingInstanceRequest
	*/
	ResetFieldMappingInstance(ctx context.Context) ApiResetFieldMappingInstanceRequest

	// ResetFieldMappingInstanceExecute executes the request
	//  @return FieldMappingInstanceDto
	ResetFieldMappingInstanceExecute(r ApiResetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error)

	/*
	ResetFieldMappings Method for ResetFieldMappings

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResetFieldMappingsRequest
	*/
	ResetFieldMappings(ctx context.Context) ApiResetFieldMappingsRequest

	// ResetFieldMappingsExecute executes the request
	//  @return FieldMappingDto
	ResetFieldMappingsExecute(r ApiResetFieldMappingsRequest) (*FieldMappingDto, *http.Response, error)
}

// FieldMappingsAPIService FieldMappingsAPI service
type FieldMappingsAPIService service

type ApiApplyFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiApplyFieldMappingRequest) Id2(id2 string) ApiApplyFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiApplyFieldMappingRequest) Key(key string) ApiApplyFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiApplyFieldMappingRequest) IntegrationId(integrationId string) ApiApplyFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyFieldMappingRequest) IntegrationKey(integrationKey string) ApiApplyFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyFieldMappingRequest) Execute() ([]FieldMappingDto, *http.Response, error) {
	return r.ApiService.ApplyFieldMappingExecute(r)
}

/*
ApplyFieldMapping Method for ApplyFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to apply
 @return ApiApplyFieldMappingRequest
*/
func (a *FieldMappingsAPIService) ApplyFieldMapping(ctx context.Context, id string) ApiApplyFieldMappingRequest {
	return ApiApplyFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []FieldMappingDto
func (a *FieldMappingsAPIService) ApplyFieldMappingExecute(r ApiApplyFieldMappingRequest) ([]FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ApplyFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/apply"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplyFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiApplyFieldMappingsRequest) Id(id string) ApiApplyFieldMappingsRequest {
	r.id = &id
	return r
}

func (r ApiApplyFieldMappingsRequest) Key(key string) ApiApplyFieldMappingsRequest {
	r.key = &key
	return r
}

func (r ApiApplyFieldMappingsRequest) IntegrationId(integrationId string) ApiApplyFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiApplyFieldMappingsRequest) IntegrationKey(integrationKey string) ApiApplyFieldMappingsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiApplyFieldMappingsRequest) Execute() ([]FieldMappingDto, *http.Response, error) {
	return r.ApiService.ApplyFieldMappingsExecute(r)
}

/*
ApplyFieldMappings Method for ApplyFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) ApplyFieldMappings(ctx context.Context) ApiApplyFieldMappingsRequest {
	return ApiApplyFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FieldMappingDto
func (a *FieldMappingsAPIService) ApplyFieldMappingsExecute(r ApiApplyFieldMappingsRequest) ([]FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ApplyFieldMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArchiveFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiArchiveFieldMappingRequest) Id2(id2 string) ApiArchiveFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiArchiveFieldMappingRequest) Key(key string) ApiArchiveFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiArchiveFieldMappingRequest) IntegrationId(integrationId string) ApiArchiveFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveFieldMappingRequest) IntegrationKey(integrationKey string) ApiArchiveFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveFieldMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveFieldMappingExecute(r)
}

/*
ArchiveFieldMapping Method for ArchiveFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to retrive
 @return ApiArchiveFieldMappingRequest
*/
func (a *FieldMappingsAPIService) ArchiveFieldMapping(ctx context.Context, id string) ApiArchiveFieldMappingRequest {
	return ApiArchiveFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) ArchiveFieldMappingExecute(r ApiArchiveFieldMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ArchiveFieldMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiArchiveFieldMappingsRequest) Id(id string) ApiArchiveFieldMappingsRequest {
	r.id = &id
	return r
}

func (r ApiArchiveFieldMappingsRequest) Key(key string) ApiArchiveFieldMappingsRequest {
	r.key = &key
	return r
}

func (r ApiArchiveFieldMappingsRequest) IntegrationId(integrationId string) ApiArchiveFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiArchiveFieldMappingsRequest) IntegrationKey(integrationKey string) ApiArchiveFieldMappingsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiArchiveFieldMappingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveFieldMappingsExecute(r)
}

/*
ArchiveFieldMappings Method for ArchiveFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) ArchiveFieldMappings(ctx context.Context) ApiArchiveFieldMappingsRequest {
	return ApiArchiveFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) ArchiveFieldMappingsExecute(r ApiArchiveFieldMappingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ArchiveFieldMappings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	createFieldMappingDto *CreateFieldMappingDto
}

func (r ApiCreateFieldMappingRequest) CreateFieldMappingDto(createFieldMappingDto CreateFieldMappingDto) ApiCreateFieldMappingRequest {
	r.createFieldMappingDto = &createFieldMappingDto
	return r
}

func (r ApiCreateFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.CreateFieldMappingExecute(r)
}

/*
CreateFieldMapping Method for CreateFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFieldMappingRequest
*/
func (a *FieldMappingsAPIService) CreateFieldMapping(ctx context.Context) ApiCreateFieldMappingRequest {
	return ApiCreateFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) CreateFieldMappingExecute(r ApiCreateFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.CreateFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("createFieldMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiDeleteFieldMappingInstanceRequest) Id(id string) ApiDeleteFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiDeleteFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiDeleteFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiDeleteFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiDeleteFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) FlowKey(flowKey string) ApiDeleteFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) FlowId(flowId string) ApiDeleteFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiDeleteFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiDeleteFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiDeleteFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiDeleteFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiDeleteFieldMappingInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFieldMappingInstanceExecute(r)
}

/*
DeleteFieldMappingInstance Method for DeleteFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) DeleteFieldMappingInstance(ctx context.Context) ApiDeleteFieldMappingInstanceRequest {
	return ApiDeleteFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FieldMappingsAPIService) DeleteFieldMappingInstanceExecute(r ApiDeleteFieldMappingInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.DeleteFieldMappingInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFieldMappingSetupRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiFieldMappingSetupRequest) Id(id string) ApiFieldMappingSetupRequest {
	r.id = &id
	return r
}

func (r ApiFieldMappingSetupRequest) FieldMappingKey(fieldMappingKey string) ApiFieldMappingSetupRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiFieldMappingSetupRequest) FieldMappingId(fieldMappingId string) ApiFieldMappingSetupRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiFieldMappingSetupRequest) InstanceKey(instanceKey string) ApiFieldMappingSetupRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiFieldMappingSetupRequest) AutoCreate(autoCreate bool) ApiFieldMappingSetupRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiFieldMappingSetupRequest) FlowKey(flowKey string) ApiFieldMappingSetupRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiFieldMappingSetupRequest) FlowId(flowId string) ApiFieldMappingSetupRequest {
	r.flowId = &flowId
	return r
}

func (r ApiFieldMappingSetupRequest) NodeKey(nodeKey string) ApiFieldMappingSetupRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiFieldMappingSetupRequest) IntegrationKey(integrationKey string) ApiFieldMappingSetupRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiFieldMappingSetupRequest) IntegrationId(integrationId string) ApiFieldMappingSetupRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiFieldMappingSetupRequest) ConnectionId(connectionId string) ApiFieldMappingSetupRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiFieldMappingSetupRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.FieldMappingSetupExecute(r)
}

/*
FieldMappingSetup Method for FieldMappingSetup

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFieldMappingSetupRequest
*/
func (a *FieldMappingsAPIService) FieldMappingSetup(ctx context.Context) ApiFieldMappingSetupRequest {
	return ApiFieldMappingSetupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) FieldMappingSetupExecute(r ApiFieldMappingSetupRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.FieldMappingSetup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance/setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiGetFieldMappingRequest) Id2(id2 string) ApiGetFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiGetFieldMappingRequest) Key(key string) ApiGetFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiGetFieldMappingRequest) IntegrationId(integrationId string) ApiGetFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFieldMappingRequest) IntegrationKey(integrationKey string) ApiGetFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.GetFieldMappingExecute(r)
}

/*
GetFieldMapping Method for GetFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to retrive
 @return ApiGetFieldMappingRequest
*/
func (a *FieldMappingsAPIService) GetFieldMapping(ctx context.Context, id string) ApiGetFieldMappingRequest {
	return ApiGetFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) GetFieldMappingExecute(r ApiGetFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.GetFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldMappingAppSchemaRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiGetFieldMappingAppSchemaRequest) Id2(id2 string) ApiGetFieldMappingAppSchemaRequest {
	r.id2 = &id2
	return r
}

func (r ApiGetFieldMappingAppSchemaRequest) Key(key string) ApiGetFieldMappingAppSchemaRequest {
	r.key = &key
	return r
}

func (r ApiGetFieldMappingAppSchemaRequest) IntegrationId(integrationId string) ApiGetFieldMappingAppSchemaRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFieldMappingAppSchemaRequest) IntegrationKey(integrationKey string) ApiGetFieldMappingAppSchemaRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFieldMappingAppSchemaRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFieldMappingAppSchemaExecute(r)
}

/*
GetFieldMappingAppSchema Method for GetFieldMappingAppSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mappping
 @return ApiGetFieldMappingAppSchemaRequest
*/
func (a *FieldMappingsAPIService) GetFieldMappingAppSchema(ctx context.Context, id string) ApiGetFieldMappingAppSchemaRequest {
	return ApiGetFieldMappingAppSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FieldMappingsAPIService) GetFieldMappingAppSchemaExecute(r ApiGetFieldMappingAppSchemaRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.GetFieldMappingAppSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/app-schema"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldMappingAppSchemasRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiGetFieldMappingAppSchemasRequest) Id(id string) ApiGetFieldMappingAppSchemasRequest {
	r.id = &id
	return r
}

func (r ApiGetFieldMappingAppSchemasRequest) Key(key string) ApiGetFieldMappingAppSchemasRequest {
	r.key = &key
	return r
}

func (r ApiGetFieldMappingAppSchemasRequest) IntegrationId(integrationId string) ApiGetFieldMappingAppSchemasRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFieldMappingAppSchemasRequest) IntegrationKey(integrationKey string) ApiGetFieldMappingAppSchemasRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFieldMappingAppSchemasRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetFieldMappingAppSchemasExecute(r)
}

/*
GetFieldMappingAppSchemas Method for GetFieldMappingAppSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFieldMappingAppSchemasRequest
*/
func (a *FieldMappingsAPIService) GetFieldMappingAppSchemas(ctx context.Context) ApiGetFieldMappingAppSchemasRequest {
	return ApiGetFieldMappingAppSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *FieldMappingsAPIService) GetFieldMappingAppSchemasExecute(r ApiGetFieldMappingAppSchemasRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.GetFieldMappingAppSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping/app-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiGetFieldMappingInstanceRequest) Id(id string) ApiGetFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiGetFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiGetFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiGetFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiGetFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiGetFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiGetFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetFieldMappingInstanceRequest) FlowKey(flowKey string) ApiGetFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiGetFieldMappingInstanceRequest) FlowId(flowId string) ApiGetFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiGetFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiGetFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiGetFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiGetFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiGetFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiGetFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiGetFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiGetFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.GetFieldMappingInstanceExecute(r)
}

/*
GetFieldMappingInstance Method for GetFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) GetFieldMappingInstance(ctx context.Context) ApiGetFieldMappingInstanceRequest {
	return ApiGetFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) GetFieldMappingInstanceExecute(r ApiGetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.GetFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiListFieldMappingRequest) Id(id string) ApiListFieldMappingRequest {
	r.id = &id
	return r
}

func (r ApiListFieldMappingRequest) Key(key string) ApiListFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiListFieldMappingRequest) IntegrationId(integrationId string) ApiListFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFieldMappingRequest) IntegrationKey(integrationKey string) ApiListFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.ListFieldMappingExecute(r)
}

/*
ListFieldMapping Method for ListFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFieldMappingRequest
*/
func (a *FieldMappingsAPIService) ListFieldMapping(ctx context.Context) ApiListFieldMappingRequest {
	return ApiListFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) ListFieldMappingExecute(r ApiListFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ListFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFieldMappingInstancesRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	userId *string
	fieldMappingId *string
	connectionId *string
	integrationId *string
	integrationKey *string
	instanceKey *string
	dataSourceInstanceId *string
}

func (r ApiListFieldMappingInstancesRequest) Id(id string) ApiListFieldMappingInstancesRequest {
	r.id = &id
	return r
}

func (r ApiListFieldMappingInstancesRequest) UserId(userId string) ApiListFieldMappingInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiListFieldMappingInstancesRequest) FieldMappingId(fieldMappingId string) ApiListFieldMappingInstancesRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiListFieldMappingInstancesRequest) ConnectionId(connectionId string) ApiListFieldMappingInstancesRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiListFieldMappingInstancesRequest) IntegrationId(integrationId string) ApiListFieldMappingInstancesRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFieldMappingInstancesRequest) IntegrationKey(integrationKey string) ApiListFieldMappingInstancesRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListFieldMappingInstancesRequest) InstanceKey(instanceKey string) ApiListFieldMappingInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListFieldMappingInstancesRequest) DataSourceInstanceId(dataSourceInstanceId string) ApiListFieldMappingInstancesRequest {
	r.dataSourceInstanceId = &dataSourceInstanceId
	return r
}

func (r ApiListFieldMappingInstancesRequest) Execute() (*ListFieldMappingInstances200Response, *http.Response, error) {
	return r.ApiService.ListFieldMappingInstancesExecute(r)
}

/*
ListFieldMappingInstances Method for ListFieldMappingInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFieldMappingInstancesRequest
*/
func (a *FieldMappingsAPIService) ListFieldMappingInstances(ctx context.Context) ApiListFieldMappingInstancesRequest {
	return ApiListFieldMappingInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFieldMappingInstances200Response
func (a *FieldMappingsAPIService) ListFieldMappingInstancesExecute(r ApiListFieldMappingInstancesRequest) (*ListFieldMappingInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFieldMappingInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ListFieldMappingInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.dataSourceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataSourceInstanceId", r.dataSourceInstanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	integrationId *string
	universalFieldMappingId *string
}

func (r ApiListFieldMappingsRequest) IntegrationId(integrationId string) ApiListFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListFieldMappingsRequest) UniversalFieldMappingId(universalFieldMappingId string) ApiListFieldMappingsRequest {
	r.universalFieldMappingId = &universalFieldMappingId
	return r
}

func (r ApiListFieldMappingsRequest) Execute() (*ListFieldMappings200Response, *http.Response, error) {
	return r.ApiService.ListFieldMappingsExecute(r)
}

/*
ListFieldMappings Method for ListFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) ListFieldMappings(ctx context.Context) ApiListFieldMappingsRequest {
	return ApiListFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListFieldMappings200Response
func (a *FieldMappingsAPIService) ListFieldMappingsExecute(r ApiListFieldMappingsRequest) (*ListFieldMappings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListFieldMappings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ListFieldMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.universalFieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "universalFieldMappingId", r.universalFieldMappingId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingDto *UpdateFieldMappingDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPatchFieldMappingRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiPatchFieldMappingRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiPatchFieldMappingRequest) Id2(id2 string) ApiPatchFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiPatchFieldMappingRequest) Key(key string) ApiPatchFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiPatchFieldMappingRequest) IntegrationId(integrationId string) ApiPatchFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFieldMappingRequest) IntegrationKey(integrationKey string) ApiPatchFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.PatchFieldMappingExecute(r)
}

/*
PatchFieldMapping Method for PatchFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to retrive
 @return ApiPatchFieldMappingRequest
*/
func (a *FieldMappingsAPIService) PatchFieldMapping(ctx context.Context, id string) ApiPatchFieldMappingRequest {
	return ApiPatchFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) PatchFieldMappingExecute(r ApiPatchFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PatchFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPatchFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiPatchFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) Id(id string) ApiPatchFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiPatchFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiPatchFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiPatchFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiPatchFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) FlowKey(flowKey string) ApiPatchFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) FlowId(flowId string) ApiPatchFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiPatchFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiPatchFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiPatchFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiPatchFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPatchFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.PatchFieldMappingInstanceExecute(r)
}

/*
PatchFieldMappingInstance Method for PatchFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) PatchFieldMappingInstance(ctx context.Context) ApiPatchFieldMappingInstanceRequest {
	return ApiPatchFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) PatchFieldMappingInstanceExecute(r ApiPatchFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PatchFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	updateFieldMappingDto *UpdateFieldMappingDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPatchFieldMappingsRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiPatchFieldMappingsRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiPatchFieldMappingsRequest) Id(id string) ApiPatchFieldMappingsRequest {
	r.id = &id
	return r
}

func (r ApiPatchFieldMappingsRequest) Key(key string) ApiPatchFieldMappingsRequest {
	r.key = &key
	return r
}

func (r ApiPatchFieldMappingsRequest) IntegrationId(integrationId string) ApiPatchFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPatchFieldMappingsRequest) IntegrationKey(integrationKey string) ApiPatchFieldMappingsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPatchFieldMappingsRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.PatchFieldMappingsExecute(r)
}

/*
PatchFieldMappings Method for PatchFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) PatchFieldMappings(ctx context.Context) ApiPatchFieldMappingsRequest {
	return ApiPatchFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) PatchFieldMappingsExecute(r ApiPatchFieldMappingsRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PatchFieldMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPostFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiPostFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiPostFieldMappingInstanceRequest) Id(id string) ApiPostFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPostFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiPostFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiPostFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiPostFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiPostFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiPostFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPostFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiPostFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPostFieldMappingInstanceRequest) FlowKey(flowKey string) ApiPostFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPostFieldMappingInstanceRequest) FlowId(flowId string) ApiPostFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPostFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiPostFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiPostFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiPostFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPostFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiPostFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPostFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiPostFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPostFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.PostFieldMappingInstanceExecute(r)
}

/*
PostFieldMappingInstance Method for PostFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) PostFieldMappingInstance(ctx context.Context) ApiPostFieldMappingInstanceRequest {
	return ApiPostFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) PostFieldMappingInstanceExecute(r ApiPostFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PostFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	updateFieldMappingDto *UpdateFieldMappingDto
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPutFieldMappingRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiPutFieldMappingRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiPutFieldMappingRequest) Id2(id2 string) ApiPutFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiPutFieldMappingRequest) Key(key string) ApiPutFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiPutFieldMappingRequest) IntegrationId(integrationId string) ApiPutFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutFieldMappingRequest) IntegrationKey(integrationKey string) ApiPutFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.PutFieldMappingExecute(r)
}

/*
PutFieldMapping Method for PutFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to retrive
 @return ApiPutFieldMappingRequest
*/
func (a *FieldMappingsAPIService) PutFieldMapping(ctx context.Context, id string) ApiPutFieldMappingRequest {
	return ApiPutFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) PutFieldMappingExecute(r ApiPutFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PutFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	updateFieldMappingInstanceDto *UpdateFieldMappingInstanceDto
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiPutFieldMappingInstanceRequest) UpdateFieldMappingInstanceDto(updateFieldMappingInstanceDto UpdateFieldMappingInstanceDto) ApiPutFieldMappingInstanceRequest {
	r.updateFieldMappingInstanceDto = &updateFieldMappingInstanceDto
	return r
}

func (r ApiPutFieldMappingInstanceRequest) Id(id string) ApiPutFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPutFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiPutFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiPutFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiPutFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiPutFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiPutFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPutFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiPutFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutFieldMappingInstanceRequest) FlowKey(flowKey string) ApiPutFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiPutFieldMappingInstanceRequest) FlowId(flowId string) ApiPutFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiPutFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiPutFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiPutFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiPutFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiPutFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiPutFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiPutFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.PutFieldMappingInstanceExecute(r)
}

/*
PutFieldMappingInstance Method for PutFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) PutFieldMappingInstance(ctx context.Context) ApiPutFieldMappingInstanceRequest {
	return ApiPutFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) PutFieldMappingInstanceExecute(r ApiPutFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PutFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingInstanceDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingInstanceDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingInstanceDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	updateFieldMappingDto *UpdateFieldMappingDto
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiPutFieldMappingsRequest) UpdateFieldMappingDto(updateFieldMappingDto UpdateFieldMappingDto) ApiPutFieldMappingsRequest {
	r.updateFieldMappingDto = &updateFieldMappingDto
	return r
}

func (r ApiPutFieldMappingsRequest) Id(id string) ApiPutFieldMappingsRequest {
	r.id = &id
	return r
}

func (r ApiPutFieldMappingsRequest) Key(key string) ApiPutFieldMappingsRequest {
	r.key = &key
	return r
}

func (r ApiPutFieldMappingsRequest) IntegrationId(integrationId string) ApiPutFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiPutFieldMappingsRequest) IntegrationKey(integrationKey string) ApiPutFieldMappingsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiPutFieldMappingsRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.PutFieldMappingsExecute(r)
}

/*
PutFieldMappings Method for PutFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) PutFieldMappings(ctx context.Context) ApiPutFieldMappingsRequest {
	return ApiPutFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) PutFieldMappingsExecute(r ApiPutFieldMappingsRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.PutFieldMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFieldMappingDto == nil {
		return localVarReturnValue, nil, reportError("updateFieldMappingDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFieldMappingDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFieldMappingRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id string
	id2 *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiResetFieldMappingRequest) Id2(id2 string) ApiResetFieldMappingRequest {
	r.id2 = &id2
	return r
}

func (r ApiResetFieldMappingRequest) Key(key string) ApiResetFieldMappingRequest {
	r.key = &key
	return r
}

func (r ApiResetFieldMappingRequest) IntegrationId(integrationId string) ApiResetFieldMappingRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFieldMappingRequest) IntegrationKey(integrationKey string) ApiResetFieldMappingRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFieldMappingRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.ResetFieldMappingExecute(r)
}

/*
ResetFieldMapping Method for ResetFieldMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the field-mapping to reset
 @return ApiResetFieldMappingRequest
*/
func (a *FieldMappingsAPIService) ResetFieldMapping(ctx context.Context, id string) ApiResetFieldMappingRequest {
	return ApiResetFieldMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) ResetFieldMappingExecute(r ApiResetFieldMappingRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ResetFieldMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mappings/{id}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id2, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFieldMappingInstanceRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	fieldMappingKey *string
	fieldMappingId *string
	instanceKey *string
	autoCreate *bool
	flowKey *string
	flowId *string
	nodeKey *string
	integrationKey *string
	integrationId *string
	connectionId *string
}

func (r ApiResetFieldMappingInstanceRequest) Id(id string) ApiResetFieldMappingInstanceRequest {
	r.id = &id
	return r
}

func (r ApiResetFieldMappingInstanceRequest) FieldMappingKey(fieldMappingKey string) ApiResetFieldMappingInstanceRequest {
	r.fieldMappingKey = &fieldMappingKey
	return r
}

func (r ApiResetFieldMappingInstanceRequest) FieldMappingId(fieldMappingId string) ApiResetFieldMappingInstanceRequest {
	r.fieldMappingId = &fieldMappingId
	return r
}

func (r ApiResetFieldMappingInstanceRequest) InstanceKey(instanceKey string) ApiResetFieldMappingInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiResetFieldMappingInstanceRequest) AutoCreate(autoCreate bool) ApiResetFieldMappingInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiResetFieldMappingInstanceRequest) FlowKey(flowKey string) ApiResetFieldMappingInstanceRequest {
	r.flowKey = &flowKey
	return r
}

func (r ApiResetFieldMappingInstanceRequest) FlowId(flowId string) ApiResetFieldMappingInstanceRequest {
	r.flowId = &flowId
	return r
}

func (r ApiResetFieldMappingInstanceRequest) NodeKey(nodeKey string) ApiResetFieldMappingInstanceRequest {
	r.nodeKey = &nodeKey
	return r
}

func (r ApiResetFieldMappingInstanceRequest) IntegrationKey(integrationKey string) ApiResetFieldMappingInstanceRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFieldMappingInstanceRequest) IntegrationId(integrationId string) ApiResetFieldMappingInstanceRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFieldMappingInstanceRequest) ConnectionId(connectionId string) ApiResetFieldMappingInstanceRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiResetFieldMappingInstanceRequest) Execute() (*FieldMappingInstanceDto, *http.Response, error) {
	return r.ApiService.ResetFieldMappingInstanceExecute(r)
}

/*
ResetFieldMappingInstance Method for ResetFieldMappingInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetFieldMappingInstanceRequest
*/
func (a *FieldMappingsAPIService) ResetFieldMappingInstance(ctx context.Context) ApiResetFieldMappingInstanceRequest {
	return ApiResetFieldMappingInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingInstanceDto
func (a *FieldMappingsAPIService) ResetFieldMappingInstanceExecute(r ApiResetFieldMappingInstanceRequest) (*FieldMappingInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ResetFieldMappingInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping-instance/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.fieldMappingKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingKey", r.fieldMappingKey, "")
	}
	if r.fieldMappingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldMappingId", r.fieldMappingId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	if r.flowKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowKey", r.flowKey, "")
	}
	if r.flowId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flowId", r.flowId, "")
	}
	if r.nodeKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKey", r.nodeKey, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetFieldMappingsRequest struct {
	ctx context.Context
	ApiService FieldMappingsAPI
	id *string
	key *string
	integrationId *string
	integrationKey *string
}

func (r ApiResetFieldMappingsRequest) Id(id string) ApiResetFieldMappingsRequest {
	r.id = &id
	return r
}

func (r ApiResetFieldMappingsRequest) Key(key string) ApiResetFieldMappingsRequest {
	r.key = &key
	return r
}

func (r ApiResetFieldMappingsRequest) IntegrationId(integrationId string) ApiResetFieldMappingsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiResetFieldMappingsRequest) IntegrationKey(integrationKey string) ApiResetFieldMappingsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiResetFieldMappingsRequest) Execute() (*FieldMappingDto, *http.Response, error) {
	return r.ApiService.ResetFieldMappingsExecute(r)
}

/*
ResetFieldMappings Method for ResetFieldMappings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetFieldMappingsRequest
*/
func (a *FieldMappingsAPIService) ResetFieldMappings(ctx context.Context) ApiResetFieldMappingsRequest {
	return ApiResetFieldMappingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FieldMappingDto
func (a *FieldMappingsAPIService) ResetFieldMappingsExecute(r ApiResetFieldMappingsRequest) (*FieldMappingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldMappingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FieldMappingsAPIService.ResetFieldMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/field-mapping/reset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
