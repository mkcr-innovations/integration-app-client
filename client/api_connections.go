/*
Integration.app API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ConnectionsAPI interface {

	/*
	ConnectionsControllerArchiveConnection Archive connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerArchiveConnectionRequest
	*/
	ConnectionsControllerArchiveConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerArchiveConnectionRequest

	// ConnectionsControllerArchiveConnectionExecute executes the request
	ConnectionsControllerArchiveConnectionExecute(r ApiConnectionsControllerArchiveConnectionRequest) (*http.Response, error)

	/*
	ConnectionsControllerCreateConnection Create connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConnectionsControllerCreateConnectionRequest
	*/
	ConnectionsControllerCreateConnection(ctx context.Context) ApiConnectionsControllerCreateConnectionRequest

	// ConnectionsControllerCreateConnectionExecute executes the request
	//  @return ConnectionDto
	ConnectionsControllerCreateConnectionExecute(r ApiConnectionsControllerCreateConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	ConnectionsControllerDataLocationMethod Get connection data location method

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param dataLocationKey
	@param methodKey
	@return ApiConnectionsControllerDataLocationMethodRequest
	*/
	ConnectionsControllerDataLocationMethod(ctx context.Context, connectionIdOrKey string, dataLocationKey string, methodKey string) ApiConnectionsControllerDataLocationMethodRequest

	// ConnectionsControllerDataLocationMethodExecute executes the request
	//  @return map[string]interface{}
	ConnectionsControllerDataLocationMethodExecute(r ApiConnectionsControllerDataLocationMethodRequest) (map[string]interface{}, *http.Response, error)

	/*
	ConnectionsControllerGetConnection Get connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerGetConnectionRequest
	*/
	ConnectionsControllerGetConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerGetConnectionRequest

	// ConnectionsControllerGetConnectionExecute executes the request
	//  @return ConnectionDto
	ConnectionsControllerGetConnectionExecute(r ApiConnectionsControllerGetConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	ConnectionsControllerGetDataLocationSpec Get connection data location

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param dataLocationKey
	@return ApiConnectionsControllerGetDataLocationSpecRequest
	*/
	ConnectionsControllerGetDataLocationSpec(ctx context.Context, connectionIdOrKey string, dataLocationKey string) ApiConnectionsControllerGetDataLocationSpecRequest

	// ConnectionsControllerGetDataLocationSpecExecute executes the request
	//  @return map[string]interface{}
	ConnectionsControllerGetDataLocationSpecExecute(r ApiConnectionsControllerGetDataLocationSpecRequest) (map[string]interface{}, *http.Response, error)

	/*
	ConnectionsControllerGetOperation Get connection operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param operationKey
	@return ApiConnectionsControllerGetOperationRequest
	*/
	ConnectionsControllerGetOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiConnectionsControllerGetOperationRequest

	// ConnectionsControllerGetOperationExecute executes the request
	//  @return map[string]interface{}
	ConnectionsControllerGetOperationExecute(r ApiConnectionsControllerGetOperationRequest) (map[string]interface{}, *http.Response, error)

	/*
	ConnectionsControllerListConnections List connections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiConnectionsControllerListConnectionsRequest
	*/
	ConnectionsControllerListConnections(ctx context.Context) ApiConnectionsControllerListConnectionsRequest

	// ConnectionsControllerListConnectionsExecute executes the request
	//  @return ConnectionsControllerListConnections200Response
	ConnectionsControllerListConnectionsExecute(r ApiConnectionsControllerListConnectionsRequest) (*ConnectionsControllerListConnections200Response, *http.Response, error)

	/*
	ConnectionsControllerListDataLocations List connection data locations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerListDataLocationsRequest
	*/
	ConnectionsControllerListDataLocations(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerListDataLocationsRequest

	// ConnectionsControllerListDataLocationsExecute executes the request
	//  @return []map[string]interface{}
	ConnectionsControllerListDataLocationsExecute(r ApiConnectionsControllerListDataLocationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	ConnectionsControllerListOperations List connection operations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerListOperationsRequest
	*/
	ConnectionsControllerListOperations(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerListOperationsRequest

	// ConnectionsControllerListOperationsExecute executes the request
	//  @return []map[string]interface{}
	ConnectionsControllerListOperationsExecute(r ApiConnectionsControllerListOperationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	ConnectionsControllerPatchConnection Update connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerPatchConnectionRequest
	*/
	ConnectionsControllerPatchConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerPatchConnectionRequest

	// ConnectionsControllerPatchConnectionExecute executes the request
	//  @return ConnectionDto
	ConnectionsControllerPatchConnectionExecute(r ApiConnectionsControllerPatchConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	ConnectionsControllerProxyRequestDelete Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestDeleteRequest
	*/
	ConnectionsControllerProxyRequestDelete(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestDeleteRequest

	// ConnectionsControllerProxyRequestDeleteExecute executes the request
	ConnectionsControllerProxyRequestDeleteExecute(r ApiConnectionsControllerProxyRequestDeleteRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestGet Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestGetRequest
	*/
	ConnectionsControllerProxyRequestGet(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestGetRequest

	// ConnectionsControllerProxyRequestGetExecute executes the request
	ConnectionsControllerProxyRequestGetExecute(r ApiConnectionsControllerProxyRequestGetRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestHead Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestHeadRequest
	*/
	ConnectionsControllerProxyRequestHead(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestHeadRequest

	// ConnectionsControllerProxyRequestHeadExecute executes the request
	ConnectionsControllerProxyRequestHeadExecute(r ApiConnectionsControllerProxyRequestHeadRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestOptions Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestOptionsRequest
	*/
	ConnectionsControllerProxyRequestOptions(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestOptionsRequest

	// ConnectionsControllerProxyRequestOptionsExecute executes the request
	ConnectionsControllerProxyRequestOptionsExecute(r ApiConnectionsControllerProxyRequestOptionsRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestPatch Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestPatchRequest
	*/
	ConnectionsControllerProxyRequestPatch(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPatchRequest

	// ConnectionsControllerProxyRequestPatchExecute executes the request
	ConnectionsControllerProxyRequestPatchExecute(r ApiConnectionsControllerProxyRequestPatchRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestPost Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestPostRequest
	*/
	ConnectionsControllerProxyRequestPost(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPostRequest

	// ConnectionsControllerProxyRequestPostExecute executes the request
	ConnectionsControllerProxyRequestPostExecute(r ApiConnectionsControllerProxyRequestPostRequest) (*http.Response, error)

	/*
	ConnectionsControllerProxyRequestPut Connection proxy request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiConnectionsControllerProxyRequestPutRequest
	*/
	ConnectionsControllerProxyRequestPut(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPutRequest

	// ConnectionsControllerProxyRequestPutExecute executes the request
	ConnectionsControllerProxyRequestPutExecute(r ApiConnectionsControllerProxyRequestPutRequest) (*http.Response, error)

	/*
	ConnectionsControllerRefreshConnectionCredentials Refresh connection credentials

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerRefreshConnectionCredentialsRequest
	*/
	ConnectionsControllerRefreshConnectionCredentials(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerRefreshConnectionCredentialsRequest

	// ConnectionsControllerRefreshConnectionCredentialsExecute executes the request
	ConnectionsControllerRefreshConnectionCredentialsExecute(r ApiConnectionsControllerRefreshConnectionCredentialsRequest) (*http.Response, error)

	/*
	ConnectionsControllerRunOperation Run connection operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param operationKey
	@return ApiConnectionsControllerRunOperationRequest
	*/
	ConnectionsControllerRunOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiConnectionsControllerRunOperationRequest

	// ConnectionsControllerRunOperationExecute executes the request
	//  @return OperationRunResponseDto
	ConnectionsControllerRunOperationExecute(r ApiConnectionsControllerRunOperationRequest) (*OperationRunResponseDto, *http.Response, error)

	/*
	ConnectionsControllerTestConnection Test connection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiConnectionsControllerTestConnectionRequest
	*/
	ConnectionsControllerTestConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerTestConnectionRequest

	// ConnectionsControllerTestConnectionExecute executes the request
	ConnectionsControllerTestConnectionExecute(r ApiConnectionsControllerTestConnectionRequest) (*http.Response, error)
}

// ConnectionsAPIService ConnectionsAPI service
type ConnectionsAPIService service

type ApiConnectionsControllerArchiveConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerArchiveConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerArchiveConnectionExecute(r)
}

/*
ConnectionsControllerArchiveConnection Archive connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerArchiveConnectionRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerArchiveConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerArchiveConnectionRequest {
	return ApiConnectionsControllerArchiveConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerArchiveConnectionExecute(r ApiConnectionsControllerArchiveConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerArchiveConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerCreateConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	createConnectionDto *CreateConnectionDto
}

func (r ApiConnectionsControllerCreateConnectionRequest) CreateConnectionDto(createConnectionDto CreateConnectionDto) ApiConnectionsControllerCreateConnectionRequest {
	r.createConnectionDto = &createConnectionDto
	return r
}

func (r ApiConnectionsControllerCreateConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.ConnectionsControllerCreateConnectionExecute(r)
}

/*
ConnectionsControllerCreateConnection Create connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionsControllerCreateConnectionRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerCreateConnection(ctx context.Context) ApiConnectionsControllerCreateConnectionRequest {
	return ApiConnectionsControllerCreateConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) ConnectionsControllerCreateConnectionExecute(r ApiConnectionsControllerCreateConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerCreateConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createConnectionDto == nil {
		return localVarReturnValue, nil, reportError("createConnectionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createConnectionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerDataLocationMethodRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	dataLocationKey string
	methodKey string
}

func (r ApiConnectionsControllerDataLocationMethodRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionsControllerDataLocationMethodExecute(r)
}

/*
ConnectionsControllerDataLocationMethod Get connection data location method

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param dataLocationKey
 @param methodKey
 @return ApiConnectionsControllerDataLocationMethodRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerDataLocationMethod(ctx context.Context, connectionIdOrKey string, dataLocationKey string, methodKey string) ApiConnectionsControllerDataLocationMethodRequest {
	return ApiConnectionsControllerDataLocationMethodRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		dataLocationKey: dataLocationKey,
		methodKey: methodKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) ConnectionsControllerDataLocationMethodExecute(r ApiConnectionsControllerDataLocationMethodRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerDataLocationMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data/{dataLocationKey}/{methodKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"methodKey"+"}", url.PathEscape(parameterValueToString(r.methodKey, "methodKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerGetConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerGetConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.ConnectionsControllerGetConnectionExecute(r)
}

/*
ConnectionsControllerGetConnection Get connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerGetConnectionRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerGetConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerGetConnectionRequest {
	return ApiConnectionsControllerGetConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) ConnectionsControllerGetConnectionExecute(r ApiConnectionsControllerGetConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerGetConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerGetDataLocationSpecRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	dataLocationKey string
}

func (r ApiConnectionsControllerGetDataLocationSpecRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionsControllerGetDataLocationSpecExecute(r)
}

/*
ConnectionsControllerGetDataLocationSpec Get connection data location

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param dataLocationKey
 @return ApiConnectionsControllerGetDataLocationSpecRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerGetDataLocationSpec(ctx context.Context, connectionIdOrKey string, dataLocationKey string) ApiConnectionsControllerGetDataLocationSpecRequest {
	return ApiConnectionsControllerGetDataLocationSpecRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		dataLocationKey: dataLocationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) ConnectionsControllerGetDataLocationSpecExecute(r ApiConnectionsControllerGetDataLocationSpecRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerGetDataLocationSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data/{dataLocationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerGetOperationRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	operationKey string
}

func (r ApiConnectionsControllerGetOperationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionsControllerGetOperationExecute(r)
}

/*
ConnectionsControllerGetOperation Get connection operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param operationKey
 @return ApiConnectionsControllerGetOperationRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerGetOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiConnectionsControllerGetOperationRequest {
	return ApiConnectionsControllerGetOperationRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) ConnectionsControllerGetOperationExecute(r ApiConnectionsControllerGetOperationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerGetOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations/{operationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerListConnectionsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	limit *float32
	cursor *string
	search *string
	connectorId *string
	includeArchived *bool
	id *string
	userId *string
	name *string
	isTest *bool
	disconnected *bool
	integrationId *string
	integrationKey *string
}

func (r ApiConnectionsControllerListConnectionsRequest) Limit(limit float32) ApiConnectionsControllerListConnectionsRequest {
	r.limit = &limit
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Cursor(cursor string) ApiConnectionsControllerListConnectionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Search(search string) ApiConnectionsControllerListConnectionsRequest {
	r.search = &search
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) ConnectorId(connectorId string) ApiConnectionsControllerListConnectionsRequest {
	r.connectorId = &connectorId
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) IncludeArchived(includeArchived bool) ApiConnectionsControllerListConnectionsRequest {
	r.includeArchived = &includeArchived
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Id(id string) ApiConnectionsControllerListConnectionsRequest {
	r.id = &id
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) UserId(userId string) ApiConnectionsControllerListConnectionsRequest {
	r.userId = &userId
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Name(name string) ApiConnectionsControllerListConnectionsRequest {
	r.name = &name
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) IsTest(isTest bool) ApiConnectionsControllerListConnectionsRequest {
	r.isTest = &isTest
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Disconnected(disconnected bool) ApiConnectionsControllerListConnectionsRequest {
	r.disconnected = &disconnected
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) IntegrationId(integrationId string) ApiConnectionsControllerListConnectionsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) IntegrationKey(integrationKey string) ApiConnectionsControllerListConnectionsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiConnectionsControllerListConnectionsRequest) Execute() (*ConnectionsControllerListConnections200Response, *http.Response, error) {
	return r.ApiService.ConnectionsControllerListConnectionsExecute(r)
}

/*
ConnectionsControllerListConnections List connections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectionsControllerListConnectionsRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerListConnections(ctx context.Context) ApiConnectionsControllerListConnectionsRequest {
	return ApiConnectionsControllerListConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionsControllerListConnections200Response
func (a *ConnectionsAPIService) ConnectionsControllerListConnectionsExecute(r ApiConnectionsControllerListConnectionsRequest) (*ConnectionsControllerListConnections200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionsControllerListConnections200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerListConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.connectorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorId", r.connectorId, "")
	}
	if r.includeArchived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeArchived", r.includeArchived, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.isTest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isTest", r.isTest, "")
	}
	if r.disconnected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disconnected", r.disconnected, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerListDataLocationsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerListDataLocationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionsControllerListDataLocationsExecute(r)
}

/*
ConnectionsControllerListDataLocations List connection data locations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerListDataLocationsRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerListDataLocations(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerListDataLocationsRequest {
	return ApiConnectionsControllerListDataLocationsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConnectionsAPIService) ConnectionsControllerListDataLocationsExecute(r ApiConnectionsControllerListDataLocationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerListDataLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerListOperationsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerListOperationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectionsControllerListOperationsExecute(r)
}

/*
ConnectionsControllerListOperations List connection operations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerListOperationsRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerListOperations(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerListOperationsRequest {
	return ApiConnectionsControllerListOperationsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConnectionsAPIService) ConnectionsControllerListOperationsExecute(r ApiConnectionsControllerListOperationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerListOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerPatchConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	updateConnectionDto *UpdateConnectionDto
}

func (r ApiConnectionsControllerPatchConnectionRequest) UpdateConnectionDto(updateConnectionDto UpdateConnectionDto) ApiConnectionsControllerPatchConnectionRequest {
	r.updateConnectionDto = &updateConnectionDto
	return r
}

func (r ApiConnectionsControllerPatchConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.ConnectionsControllerPatchConnectionExecute(r)
}

/*
ConnectionsControllerPatchConnection Update connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerPatchConnectionRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerPatchConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerPatchConnectionRequest {
	return ApiConnectionsControllerPatchConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) ConnectionsControllerPatchConnectionExecute(r ApiConnectionsControllerPatchConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerPatchConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateConnectionDto == nil {
		return localVarReturnValue, nil, reportError("updateConnectionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConnectionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestDeleteRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestDeleteExecute(r)
}

/*
ConnectionsControllerProxyRequestDelete Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestDeleteRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestDelete(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestDeleteRequest {
	return ApiConnectionsControllerProxyRequestDeleteRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestDeleteExecute(r ApiConnectionsControllerProxyRequestDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestGetRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestGetExecute(r)
}

/*
ConnectionsControllerProxyRequestGet Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestGetRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestGet(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestGetRequest {
	return ApiConnectionsControllerProxyRequestGetRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestGetExecute(r ApiConnectionsControllerProxyRequestGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestHeadRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestHeadRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestHeadExecute(r)
}

/*
ConnectionsControllerProxyRequestHead Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestHeadRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestHead(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestHeadRequest {
	return ApiConnectionsControllerProxyRequestHeadRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestHeadExecute(r ApiConnectionsControllerProxyRequestHeadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestHead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestOptionsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestOptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestOptionsExecute(r)
}

/*
ConnectionsControllerProxyRequestOptions Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestOptionsRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestOptions(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestOptionsRequest {
	return ApiConnectionsControllerProxyRequestOptionsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestOptionsExecute(r ApiConnectionsControllerProxyRequestOptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestOptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestPatchRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestPatchExecute(r)
}

/*
ConnectionsControllerProxyRequestPatch Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestPatchRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPatch(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPatchRequest {
	return ApiConnectionsControllerProxyRequestPatchRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPatchExecute(r ApiConnectionsControllerProxyRequestPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestPostRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestPostExecute(r)
}

/*
ConnectionsControllerProxyRequestPost Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestPostRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPost(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPostRequest {
	return ApiConnectionsControllerProxyRequestPostRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPostExecute(r ApiConnectionsControllerProxyRequestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerProxyRequestPutRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiConnectionsControllerProxyRequestPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerProxyRequestPutExecute(r)
}

/*
ConnectionsControllerProxyRequestPut Connection proxy request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiConnectionsControllerProxyRequestPutRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPut(ctx context.Context, connectionIdOrKey string, path string) ApiConnectionsControllerProxyRequestPutRequest {
	return ApiConnectionsControllerProxyRequestPutRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerProxyRequestPutExecute(r ApiConnectionsControllerProxyRequestPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerProxyRequestPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerRefreshConnectionCredentialsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerRefreshConnectionCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerRefreshConnectionCredentialsExecute(r)
}

/*
ConnectionsControllerRefreshConnectionCredentials Refresh connection credentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerRefreshConnectionCredentialsRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerRefreshConnectionCredentials(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerRefreshConnectionCredentialsRequest {
	return ApiConnectionsControllerRefreshConnectionCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerRefreshConnectionCredentialsExecute(r ApiConnectionsControllerRefreshConnectionCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerRefreshConnectionCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/refresh-credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectionsControllerRunOperationRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	operationKey string
}

func (r ApiConnectionsControllerRunOperationRequest) Execute() (*OperationRunResponseDto, *http.Response, error) {
	return r.ApiService.ConnectionsControllerRunOperationExecute(r)
}

/*
ConnectionsControllerRunOperation Run connection operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param operationKey
 @return ApiConnectionsControllerRunOperationRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerRunOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiConnectionsControllerRunOperationRequest {
	return ApiConnectionsControllerRunOperationRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return OperationRunResponseDto
func (a *ConnectionsAPIService) ConnectionsControllerRunOperationExecute(r ApiConnectionsControllerRunOperationRequest) (*OperationRunResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperationRunResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerRunOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations/{operationKey}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectionsControllerTestConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiConnectionsControllerTestConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConnectionsControllerTestConnectionExecute(r)
}

/*
ConnectionsControllerTestConnection Test connection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiConnectionsControllerTestConnectionRequest
*/
func (a *ConnectionsAPIService) ConnectionsControllerTestConnection(ctx context.Context, connectionIdOrKey string) ApiConnectionsControllerTestConnectionRequest {
	return ApiConnectionsControllerTestConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ConnectionsControllerTestConnectionExecute(r ApiConnectionsControllerTestConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ConnectionsControllerTestConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
