/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ConnectionsAPI interface {

	/*
	ArchiveConnection Method for ArchiveConnection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiArchiveConnectionRequest
	*/
	ArchiveConnection(ctx context.Context, connectionIdOrKey string) ApiArchiveConnectionRequest

	// ArchiveConnectionExecute executes the request
	ArchiveConnectionExecute(r ApiArchiveConnectionRequest) (*http.Response, error)

	/*
	CreateConnection Method for CreateConnection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateConnectionRequest
	*/
	CreateConnection(ctx context.Context) ApiCreateConnectionRequest

	// CreateConnectionExecute executes the request
	//  @return ConnectionDto
	CreateConnectionExecute(r ApiCreateConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	DataLocationMethod Method for DataLocationMethod

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param dataLocationKey
	@param methodKey
	@return ApiDataLocationMethodRequest
	*/
	DataLocationMethod(ctx context.Context, connectionIdOrKey string, dataLocationKey string, methodKey string) ApiDataLocationMethodRequest

	// DataLocationMethodExecute executes the request
	//  @return map[string]interface{}
	DataLocationMethodExecute(r ApiDataLocationMethodRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetConnection 

	Get connection by id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiGetConnectionRequest
	*/
	GetConnection(ctx context.Context, connectionIdOrKey string) ApiGetConnectionRequest

	// GetConnectionExecute executes the request
	//  @return ConnectionDto
	GetConnectionExecute(r ApiGetConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	GetDataLocationSpec Method for GetDataLocationSpec

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param dataLocationKey
	@return ApiGetDataLocationSpecRequest
	*/
	GetDataLocationSpec(ctx context.Context, connectionIdOrKey string, dataLocationKey string) ApiGetDataLocationSpecRequest

	// GetDataLocationSpecExecute executes the request
	//  @return map[string]interface{}
	GetDataLocationSpecExecute(r ApiGetDataLocationSpecRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetOperation Method for GetOperation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param operationKey
	@return ApiGetOperationRequest
	*/
	GetOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiGetOperationRequest

	// GetOperationExecute executes the request
	//  @return map[string]interface{}
	GetOperationExecute(r ApiGetOperationRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListConnections Method for ListConnections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListConnectionsRequest
	*/
	ListConnections(ctx context.Context) ApiListConnectionsRequest

	// ListConnectionsExecute executes the request
	//  @return ListConnections200Response
	ListConnectionsExecute(r ApiListConnectionsRequest) (*ListConnections200Response, *http.Response, error)

	/*
	ListDataLocations Method for ListDataLocations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiListDataLocationsRequest
	*/
	ListDataLocations(ctx context.Context, connectionIdOrKey string) ApiListDataLocationsRequest

	// ListDataLocationsExecute executes the request
	//  @return []map[string]interface{}
	ListDataLocationsExecute(r ApiListDataLocationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	ListOperations Method for ListOperations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiListOperationsRequest
	*/
	ListOperations(ctx context.Context, connectionIdOrKey string) ApiListOperationsRequest

	// ListOperationsExecute executes the request
	//  @return []map[string]interface{}
	ListOperationsExecute(r ApiListOperationsRequest) ([]map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestDelete Method for MakeConnectionRequestDelete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestDeleteRequest
	*/
	MakeConnectionRequestDelete(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestDeleteRequest

	// MakeConnectionRequestDeleteExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestDeleteExecute(r ApiMakeConnectionRequestDeleteRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestGet Method for MakeConnectionRequestGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestGetRequest
	*/
	MakeConnectionRequestGet(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestGetRequest

	// MakeConnectionRequestGetExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestGetExecute(r ApiMakeConnectionRequestGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestHead Method for MakeConnectionRequestHead

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestHeadRequest
	*/
	MakeConnectionRequestHead(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestHeadRequest

	// MakeConnectionRequestHeadExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestHeadExecute(r ApiMakeConnectionRequestHeadRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestOptions Method for MakeConnectionRequestOptions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestOptionsRequest
	*/
	MakeConnectionRequestOptions(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestOptionsRequest

	// MakeConnectionRequestOptionsExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestOptionsExecute(r ApiMakeConnectionRequestOptionsRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestPatch Method for MakeConnectionRequestPatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestPatchRequest
	*/
	MakeConnectionRequestPatch(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPatchRequest

	// MakeConnectionRequestPatchExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestPatchExecute(r ApiMakeConnectionRequestPatchRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestPost Method for MakeConnectionRequestPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestPostRequest
	*/
	MakeConnectionRequestPost(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPostRequest

	// MakeConnectionRequestPostExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestPostExecute(r ApiMakeConnectionRequestPostRequest) (map[string]interface{}, *http.Response, error)

	/*
	MakeConnectionRequestPut Method for MakeConnectionRequestPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiMakeConnectionRequestPutRequest
	*/
	MakeConnectionRequestPut(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPutRequest

	// MakeConnectionRequestPutExecute executes the request
	//  @return map[string]interface{}
	MakeConnectionRequestPutExecute(r ApiMakeConnectionRequestPutRequest) (map[string]interface{}, *http.Response, error)

	/*
	PatchConnection Method for PatchConnection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiPatchConnectionRequest
	*/
	PatchConnection(ctx context.Context, connectionIdOrKey string) ApiPatchConnectionRequest

	// PatchConnectionExecute executes the request
	//  @return ConnectionDto
	PatchConnectionExecute(r ApiPatchConnectionRequest) (*ConnectionDto, *http.Response, error)

	/*
	ProxyRequestDelete Method for ProxyRequestDelete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestDeleteRequest
	*/
	ProxyRequestDelete(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestDeleteRequest

	// ProxyRequestDeleteExecute executes the request
	ProxyRequestDeleteExecute(r ApiProxyRequestDeleteRequest) (*http.Response, error)

	/*
	ProxyRequestGet Method for ProxyRequestGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestGetRequest
	*/
	ProxyRequestGet(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestGetRequest

	// ProxyRequestGetExecute executes the request
	ProxyRequestGetExecute(r ApiProxyRequestGetRequest) (*http.Response, error)

	/*
	ProxyRequestHead Method for ProxyRequestHead

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestHeadRequest
	*/
	ProxyRequestHead(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestHeadRequest

	// ProxyRequestHeadExecute executes the request
	ProxyRequestHeadExecute(r ApiProxyRequestHeadRequest) (*http.Response, error)

	/*
	ProxyRequestOptions Method for ProxyRequestOptions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestOptionsRequest
	*/
	ProxyRequestOptions(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestOptionsRequest

	// ProxyRequestOptionsExecute executes the request
	ProxyRequestOptionsExecute(r ApiProxyRequestOptionsRequest) (*http.Response, error)

	/*
	ProxyRequestPatch Method for ProxyRequestPatch

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestPatchRequest
	*/
	ProxyRequestPatch(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPatchRequest

	// ProxyRequestPatchExecute executes the request
	ProxyRequestPatchExecute(r ApiProxyRequestPatchRequest) (*http.Response, error)

	/*
	ProxyRequestPost Method for ProxyRequestPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestPostRequest
	*/
	ProxyRequestPost(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPostRequest

	// ProxyRequestPostExecute executes the request
	ProxyRequestPostExecute(r ApiProxyRequestPostRequest) (*http.Response, error)

	/*
	ProxyRequestPut Method for ProxyRequestPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param path
	@return ApiProxyRequestPutRequest
	*/
	ProxyRequestPut(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPutRequest

	// ProxyRequestPutExecute executes the request
	ProxyRequestPutExecute(r ApiProxyRequestPutRequest) (*http.Response, error)

	/*
	RefreshConnectionCredentials Method for RefreshConnectionCredentials

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiRefreshConnectionCredentialsRequest
	*/
	RefreshConnectionCredentials(ctx context.Context, connectionIdOrKey string) ApiRefreshConnectionCredentialsRequest

	// RefreshConnectionCredentialsExecute executes the request
	RefreshConnectionCredentialsExecute(r ApiRefreshConnectionCredentialsRequest) (*http.Response, error)

	/*
	RunOperation Method for RunOperation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@param operationKey
	@return ApiRunOperationRequest
	*/
	RunOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiRunOperationRequest

	// RunOperationExecute executes the request
	//  @return OperationRunResponseDto
	RunOperationExecute(r ApiRunOperationRequest) (*OperationRunResponseDto, *http.Response, error)

	/*
	TestConnection Method for TestConnection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectionIdOrKey
	@return ApiTestConnectionRequest
	*/
	TestConnection(ctx context.Context, connectionIdOrKey string) ApiTestConnectionRequest

	// TestConnectionExecute executes the request
	TestConnectionExecute(r ApiTestConnectionRequest) (*http.Response, error)
}

// ConnectionsAPIService ConnectionsAPI service
type ConnectionsAPIService service

type ApiArchiveConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiArchiveConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveConnectionExecute(r)
}

/*
ArchiveConnection Method for ArchiveConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiArchiveConnectionRequest
*/
func (a *ConnectionsAPIService) ArchiveConnection(ctx context.Context, connectionIdOrKey string) ApiArchiveConnectionRequest {
	return ApiArchiveConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ArchiveConnectionExecute(r ApiArchiveConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ArchiveConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	createConnectionDto *CreateConnectionDto
}

func (r ApiCreateConnectionRequest) CreateConnectionDto(createConnectionDto CreateConnectionDto) ApiCreateConnectionRequest {
	r.createConnectionDto = &createConnectionDto
	return r
}

func (r ApiCreateConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.CreateConnectionExecute(r)
}

/*
CreateConnection Method for CreateConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConnectionRequest
*/
func (a *ConnectionsAPIService) CreateConnection(ctx context.Context) ApiCreateConnectionRequest {
	return ApiCreateConnectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) CreateConnectionExecute(r ApiCreateConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.CreateConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createConnectionDto == nil {
		return localVarReturnValue, nil, reportError("createConnectionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createConnectionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDataLocationMethodRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	dataLocationKey string
	methodKey string
}

func (r ApiDataLocationMethodRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DataLocationMethodExecute(r)
}

/*
DataLocationMethod Method for DataLocationMethod

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param dataLocationKey
 @param methodKey
 @return ApiDataLocationMethodRequest
*/
func (a *ConnectionsAPIService) DataLocationMethod(ctx context.Context, connectionIdOrKey string, dataLocationKey string, methodKey string) ApiDataLocationMethodRequest {
	return ApiDataLocationMethodRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		dataLocationKey: dataLocationKey,
		methodKey: methodKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) DataLocationMethodExecute(r ApiDataLocationMethodRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.DataLocationMethod")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data/{dataLocationKey}/{methodKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"methodKey"+"}", url.PathEscape(parameterValueToString(r.methodKey, "methodKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiGetConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.GetConnectionExecute(r)
}

/*
GetConnection 

Get connection by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiGetConnectionRequest
*/
func (a *ConnectionsAPIService) GetConnection(ctx context.Context, connectionIdOrKey string) ApiGetConnectionRequest {
	return ApiGetConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) GetConnectionExecute(r ApiGetConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.GetConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataLocationSpecRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	dataLocationKey string
}

func (r ApiGetDataLocationSpecRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDataLocationSpecExecute(r)
}

/*
GetDataLocationSpec Method for GetDataLocationSpec

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param dataLocationKey
 @return ApiGetDataLocationSpecRequest
*/
func (a *ConnectionsAPIService) GetDataLocationSpec(ctx context.Context, connectionIdOrKey string, dataLocationKey string) ApiGetDataLocationSpecRequest {
	return ApiGetDataLocationSpecRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		dataLocationKey: dataLocationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) GetDataLocationSpecExecute(r ApiGetDataLocationSpecRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.GetDataLocationSpec")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data/{dataLocationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dataLocationKey"+"}", url.PathEscape(parameterValueToString(r.dataLocationKey, "dataLocationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOperationRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	operationKey string
}

func (r ApiGetOperationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetOperationExecute(r)
}

/*
GetOperation Method for GetOperation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param operationKey
 @return ApiGetOperationRequest
*/
func (a *ConnectionsAPIService) GetOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiGetOperationRequest {
	return ApiGetOperationRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) GetOperationExecute(r ApiGetOperationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.GetOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations/{operationKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConnectionsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	id *string
	userId *string
	name *string
	isTest *bool
	disconnected *bool
	integrationId *string
	integrationKey *string
}

func (r ApiListConnectionsRequest) Id(id string) ApiListConnectionsRequest {
	r.id = &id
	return r
}

func (r ApiListConnectionsRequest) UserId(userId string) ApiListConnectionsRequest {
	r.userId = &userId
	return r
}

func (r ApiListConnectionsRequest) Name(name string) ApiListConnectionsRequest {
	r.name = &name
	return r
}

func (r ApiListConnectionsRequest) IsTest(isTest bool) ApiListConnectionsRequest {
	r.isTest = &isTest
	return r
}

func (r ApiListConnectionsRequest) Disconnected(disconnected bool) ApiListConnectionsRequest {
	r.disconnected = &disconnected
	return r
}

func (r ApiListConnectionsRequest) IntegrationId(integrationId string) ApiListConnectionsRequest {
	r.integrationId = &integrationId
	return r
}

func (r ApiListConnectionsRequest) IntegrationKey(integrationKey string) ApiListConnectionsRequest {
	r.integrationKey = &integrationKey
	return r
}

func (r ApiListConnectionsRequest) Execute() (*ListConnections200Response, *http.Response, error) {
	return r.ApiService.ListConnectionsExecute(r)
}

/*
ListConnections Method for ListConnections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListConnectionsRequest
*/
func (a *ConnectionsAPIService) ListConnections(ctx context.Context) ApiListConnectionsRequest {
	return ApiListConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListConnections200Response
func (a *ConnectionsAPIService) ListConnectionsExecute(r ApiListConnectionsRequest) (*ListConnections200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListConnections200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ListConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.isTest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isTest", r.isTest, "")
	}
	if r.disconnected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disconnected", r.disconnected, "")
	}
	if r.integrationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationId", r.integrationId, "")
	}
	if r.integrationKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integrationKey", r.integrationKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataLocationsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiListDataLocationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListDataLocationsExecute(r)
}

/*
ListDataLocations Method for ListDataLocations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiListDataLocationsRequest
*/
func (a *ConnectionsAPIService) ListDataLocations(ctx context.Context, connectionIdOrKey string) ApiListDataLocationsRequest {
	return ApiListDataLocationsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConnectionsAPIService) ListDataLocationsExecute(r ApiListDataLocationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ListDataLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOperationsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiListOperationsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListOperationsExecute(r)
}

/*
ListOperations Method for ListOperations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiListOperationsRequest
*/
func (a *ConnectionsAPIService) ListOperations(ctx context.Context, connectionIdOrKey string) ApiListOperationsRequest {
	return ApiListOperationsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ConnectionsAPIService) ListOperationsExecute(r ApiListOperationsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ListOperations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestDeleteRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestDeleteRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestDeleteRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestDeleteExecute(r)
}

/*
MakeConnectionRequestDelete Method for MakeConnectionRequestDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestDeleteRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestDelete(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestDeleteRequest {
	return ApiMakeConnectionRequestDeleteRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestDeleteExecute(r ApiMakeConnectionRequestDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestGetRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestGetRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestGetRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestGetExecute(r)
}

/*
MakeConnectionRequestGet Method for MakeConnectionRequestGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestGetRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestGet(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestGetRequest {
	return ApiMakeConnectionRequestGetRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestGetExecute(r ApiMakeConnectionRequestGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestHeadRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestHeadRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestHeadRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestHeadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestHeadExecute(r)
}

/*
MakeConnectionRequestHead Method for MakeConnectionRequestHead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestHeadRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestHead(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestHeadRequest {
	return ApiMakeConnectionRequestHeadRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestHeadExecute(r ApiMakeConnectionRequestHeadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestHead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestOptionsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestOptionsRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestOptionsRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestOptionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestOptionsExecute(r)
}

/*
MakeConnectionRequestOptions Method for MakeConnectionRequestOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestOptionsRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestOptions(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestOptionsRequest {
	return ApiMakeConnectionRequestOptionsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestOptionsExecute(r ApiMakeConnectionRequestOptionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestPatchRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestPatchRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestPatchRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestPatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestPatchExecute(r)
}

/*
MakeConnectionRequestPatch Method for MakeConnectionRequestPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestPatchRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestPatch(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPatchRequest {
	return ApiMakeConnectionRequestPatchRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestPatchExecute(r ApiMakeConnectionRequestPatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestPostRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestPostRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestPostRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestPostExecute(r)
}

/*
MakeConnectionRequestPost Method for MakeConnectionRequestPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestPostRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestPost(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPostRequest {
	return ApiMakeConnectionRequestPostRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestPostExecute(r ApiMakeConnectionRequestPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMakeConnectionRequestPutRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	connectionRequestDto *ConnectionRequestDto
}

func (r ApiMakeConnectionRequestPutRequest) ConnectionRequestDto(connectionRequestDto ConnectionRequestDto) ApiMakeConnectionRequestPutRequest {
	r.connectionRequestDto = &connectionRequestDto
	return r
}

func (r ApiMakeConnectionRequestPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.MakeConnectionRequestPutExecute(r)
}

/*
MakeConnectionRequestPut Method for MakeConnectionRequestPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiMakeConnectionRequestPutRequest
*/
func (a *ConnectionsAPIService) MakeConnectionRequestPut(ctx context.Context, connectionIdOrKey string) ApiMakeConnectionRequestPutRequest {
	return ApiMakeConnectionRequestPutRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ConnectionsAPIService) MakeConnectionRequestPutExecute(r ApiMakeConnectionRequestPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.MakeConnectionRequestPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/request"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.connectionRequestDto == nil {
		return localVarReturnValue, nil, reportError("connectionRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.connectionRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	updateConnectionDto *UpdateConnectionDto
}

func (r ApiPatchConnectionRequest) UpdateConnectionDto(updateConnectionDto UpdateConnectionDto) ApiPatchConnectionRequest {
	r.updateConnectionDto = &updateConnectionDto
	return r
}

func (r ApiPatchConnectionRequest) Execute() (*ConnectionDto, *http.Response, error) {
	return r.ApiService.PatchConnectionExecute(r)
}

/*
PatchConnection Method for PatchConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiPatchConnectionRequest
*/
func (a *ConnectionsAPIService) PatchConnection(ctx context.Context, connectionIdOrKey string) ApiPatchConnectionRequest {
	return ApiPatchConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
//  @return ConnectionDto
func (a *ConnectionsAPIService) PatchConnectionExecute(r ApiPatchConnectionRequest) (*ConnectionDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.PatchConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateConnectionDto == nil {
		return localVarReturnValue, nil, reportError("updateConnectionDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConnectionDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProxyRequestDeleteRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestDeleteExecute(r)
}

/*
ProxyRequestDelete Method for ProxyRequestDelete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestDeleteRequest
*/
func (a *ConnectionsAPIService) ProxyRequestDelete(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestDeleteRequest {
	return ApiProxyRequestDeleteRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestDeleteExecute(r ApiProxyRequestDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestGetRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestGetExecute(r)
}

/*
ProxyRequestGet Method for ProxyRequestGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestGetRequest
*/
func (a *ConnectionsAPIService) ProxyRequestGet(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestGetRequest {
	return ApiProxyRequestGetRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestGetExecute(r ApiProxyRequestGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestHeadRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestHeadRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestHeadExecute(r)
}

/*
ProxyRequestHead Method for ProxyRequestHead

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestHeadRequest
*/
func (a *ConnectionsAPIService) ProxyRequestHead(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestHeadRequest {
	return ApiProxyRequestHeadRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestHeadExecute(r ApiProxyRequestHeadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestHead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestOptionsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestOptionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestOptionsExecute(r)
}

/*
ProxyRequestOptions Method for ProxyRequestOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestOptionsRequest
*/
func (a *ConnectionsAPIService) ProxyRequestOptions(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestOptionsRequest {
	return ApiProxyRequestOptionsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestOptionsExecute(r ApiProxyRequestOptionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodOptions
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestOptions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestPatchRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestPatchExecute(r)
}

/*
ProxyRequestPatch Method for ProxyRequestPatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestPatchRequest
*/
func (a *ConnectionsAPIService) ProxyRequestPatch(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPatchRequest {
	return ApiProxyRequestPatchRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestPatchExecute(r ApiProxyRequestPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestPostRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestPostExecute(r)
}

/*
ProxyRequestPost Method for ProxyRequestPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestPostRequest
*/
func (a *ConnectionsAPIService) ProxyRequestPost(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPostRequest {
	return ApiProxyRequestPostRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestPostExecute(r ApiProxyRequestPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProxyRequestPutRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	path string
}

func (r ApiProxyRequestPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProxyRequestPutExecute(r)
}

/*
ProxyRequestPut Method for ProxyRequestPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param path
 @return ApiProxyRequestPutRequest
*/
func (a *ConnectionsAPIService) ProxyRequestPut(ctx context.Context, connectionIdOrKey string, path string) ApiProxyRequestPutRequest {
	return ApiProxyRequestPutRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		path: path,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) ProxyRequestPutExecute(r ApiProxyRequestPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.ProxyRequestPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/proxy/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRefreshConnectionCredentialsRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiRefreshConnectionCredentialsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshConnectionCredentialsExecute(r)
}

/*
RefreshConnectionCredentials Method for RefreshConnectionCredentials

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiRefreshConnectionCredentialsRequest
*/
func (a *ConnectionsAPIService) RefreshConnectionCredentials(ctx context.Context, connectionIdOrKey string) ApiRefreshConnectionCredentialsRequest {
	return ApiRefreshConnectionCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) RefreshConnectionCredentialsExecute(r ApiRefreshConnectionCredentialsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.RefreshConnectionCredentials")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/refresh-credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRunOperationRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
	operationKey string
}

func (r ApiRunOperationRequest) Execute() (*OperationRunResponseDto, *http.Response, error) {
	return r.ApiService.RunOperationExecute(r)
}

/*
RunOperation Method for RunOperation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @param operationKey
 @return ApiRunOperationRequest
*/
func (a *ConnectionsAPIService) RunOperation(ctx context.Context, connectionIdOrKey string, operationKey string) ApiRunOperationRequest {
	return ApiRunOperationRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
		operationKey: operationKey,
	}
}

// Execute executes the request
//  @return OperationRunResponseDto
func (a *ConnectionsAPIService) RunOperationExecute(r ApiRunOperationRequest) (*OperationRunResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperationRunResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.RunOperation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/operations/{operationKey}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operationKey"+"}", url.PathEscape(parameterValueToString(r.operationKey, "operationKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestConnectionRequest struct {
	ctx context.Context
	ApiService ConnectionsAPI
	connectionIdOrKey string
}

func (r ApiTestConnectionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestConnectionExecute(r)
}

/*
TestConnection Method for TestConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connectionIdOrKey
 @return ApiTestConnectionRequest
*/
func (a *ConnectionsAPIService) TestConnection(ctx context.Context, connectionIdOrKey string) ApiTestConnectionRequest {
	return ApiTestConnectionRequest{
		ApiService: a,
		ctx: ctx,
		connectionIdOrKey: connectionIdOrKey,
	}
}

// Execute executes the request
func (a *ConnectionsAPIService) TestConnectionExecute(r ApiTestConnectionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectionsAPIService.TestConnection")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/connections/{connectionIdOrKey}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"connectionIdOrKey"+"}", url.PathEscape(parameterValueToString(r.connectionIdOrKey, "connectionIdOrKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
