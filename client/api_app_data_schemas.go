/*
Integration Engine API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AppDataSchemasAPI interface {

	/*
	ArchiveAppDataSchema Method for ArchiveAppDataSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the app-data-schema to retrive
	@return ApiArchiveAppDataSchemaRequest
	*/
	ArchiveAppDataSchema(ctx context.Context, id string) ApiArchiveAppDataSchemaRequest

	// ArchiveAppDataSchemaExecute executes the request
	ArchiveAppDataSchemaExecute(r ApiArchiveAppDataSchemaRequest) (*http.Response, error)

	/*
	ArchiveAppDataSchemaInstance Method for ArchiveAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveAppDataSchemaInstanceRequest
	*/
	ArchiveAppDataSchemaInstance(ctx context.Context) ApiArchiveAppDataSchemaInstanceRequest

	// ArchiveAppDataSchemaInstanceExecute executes the request
	ArchiveAppDataSchemaInstanceExecute(r ApiArchiveAppDataSchemaInstanceRequest) (*http.Response, error)

	/*
	ArchiveAppDataSchemas Method for ArchiveAppDataSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiArchiveAppDataSchemasRequest
	*/
	ArchiveAppDataSchemas(ctx context.Context) ApiArchiveAppDataSchemasRequest

	// ArchiveAppDataSchemasExecute executes the request
	ArchiveAppDataSchemasExecute(r ApiArchiveAppDataSchemasRequest) (*http.Response, error)

	/*
	CreateAppDataSchema Method for CreateAppDataSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateAppDataSchemaRequest
	*/
	CreateAppDataSchema(ctx context.Context) ApiCreateAppDataSchemaRequest

	// CreateAppDataSchemaExecute executes the request
	//  @return AppDataSchemaDto
	CreateAppDataSchemaExecute(r ApiCreateAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	CreateAppDataSchemaInstance Method for CreateAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateAppDataSchemaInstanceRequest
	*/
	CreateAppDataSchemaInstance(ctx context.Context) ApiCreateAppDataSchemaInstanceRequest

	// CreateAppDataSchemaInstanceExecute executes the request
	//  @return AppDataSchemaInstanceDto
	CreateAppDataSchemaInstanceExecute(r ApiCreateAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error)

	/*
	GetAppDataSchema Method for GetAppDataSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the app-data-schema to retrive
	@return ApiGetAppDataSchemaRequest
	*/
	GetAppDataSchema(ctx context.Context, id string) ApiGetAppDataSchemaRequest

	// GetAppDataSchemaExecute executes the request
	//  @return AppDataSchemaDto
	GetAppDataSchemaExecute(r ApiGetAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	GetAppDataSchemaInstance Method for GetAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAppDataSchemaInstanceRequest
	*/
	GetAppDataSchemaInstance(ctx context.Context) ApiGetAppDataSchemaInstanceRequest

	// GetAppDataSchemaInstanceExecute executes the request
	//  @return AppDataSchemaInstanceDto
	GetAppDataSchemaInstanceExecute(r ApiGetAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error)

	/*
	GetAppDataSchemas Method for GetAppDataSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAppDataSchemasRequest
	*/
	GetAppDataSchemas(ctx context.Context) ApiGetAppDataSchemasRequest

	// GetAppDataSchemasExecute executes the request
	//  @return AppDataSchemaDto
	GetAppDataSchemasExecute(r ApiGetAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	ListAppDataSchemaInstances Method for ListAppDataSchemaInstances

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAppDataSchemaInstancesRequest
	*/
	ListAppDataSchemaInstances(ctx context.Context) ApiListAppDataSchemaInstancesRequest

	// ListAppDataSchemaInstancesExecute executes the request
	//  @return ListAppDataSchemaInstances200Response
	ListAppDataSchemaInstancesExecute(r ApiListAppDataSchemaInstancesRequest) (*ListAppDataSchemaInstances200Response, *http.Response, error)

	/*
	ListAppDataSchemas Method for ListAppDataSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListAppDataSchemasRequest
	*/
	ListAppDataSchemas(ctx context.Context) ApiListAppDataSchemasRequest

	// ListAppDataSchemasExecute executes the request
	//  @return ListAppDataSchemas200Response
	ListAppDataSchemasExecute(r ApiListAppDataSchemasRequest) (*ListAppDataSchemas200Response, *http.Response, error)

	/*
	PatchAppDataSchema Method for PatchAppDataSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the app-data-schema to retrive
	@return ApiPatchAppDataSchemaRequest
	*/
	PatchAppDataSchema(ctx context.Context, id string) ApiPatchAppDataSchemaRequest

	// PatchAppDataSchemaExecute executes the request
	//  @return AppDataSchemaDto
	PatchAppDataSchemaExecute(r ApiPatchAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	PatchAppDataSchemaInstance Method for PatchAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchAppDataSchemaInstanceRequest
	*/
	PatchAppDataSchemaInstance(ctx context.Context) ApiPatchAppDataSchemaInstanceRequest

	// PatchAppDataSchemaInstanceExecute executes the request
	//  @return AppDataSchemaInstanceDto
	PatchAppDataSchemaInstanceExecute(r ApiPatchAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error)

	/*
	PatchAppDataSchemas Method for PatchAppDataSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPatchAppDataSchemasRequest
	*/
	PatchAppDataSchemas(ctx context.Context) ApiPatchAppDataSchemasRequest

	// PatchAppDataSchemasExecute executes the request
	//  @return AppDataSchemaDto
	PatchAppDataSchemasExecute(r ApiPatchAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	PutAppDataSchema Method for PutAppDataSchema

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the app-data-schema to retrive
	@return ApiPutAppDataSchemaRequest
	*/
	PutAppDataSchema(ctx context.Context, id string) ApiPutAppDataSchemaRequest

	// PutAppDataSchemaExecute executes the request
	//  @return AppDataSchemaDto
	PutAppDataSchemaExecute(r ApiPutAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	PutAppDataSchemaInstance Method for PutAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutAppDataSchemaInstanceRequest
	*/
	PutAppDataSchemaInstance(ctx context.Context) ApiPutAppDataSchemaInstanceRequest

	// PutAppDataSchemaInstanceExecute executes the request
	//  @return AppDataSchemaInstanceDto
	PutAppDataSchemaInstanceExecute(r ApiPutAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error)

	/*
	PutAppDataSchemas Method for PutAppDataSchemas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPutAppDataSchemasRequest
	*/
	PutAppDataSchemas(ctx context.Context) ApiPutAppDataSchemasRequest

	// PutAppDataSchemasExecute executes the request
	//  @return AppDataSchemaDto
	PutAppDataSchemasExecute(r ApiPutAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error)

	/*
	SetupAppDataSchemaInstance Method for SetupAppDataSchemaInstance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetupAppDataSchemaInstanceRequest
	*/
	SetupAppDataSchemaInstance(ctx context.Context) ApiSetupAppDataSchemaInstanceRequest

	// SetupAppDataSchemaInstanceExecute executes the request
	//  @return AppDataSchemaInstanceDto
	SetupAppDataSchemaInstanceExecute(r ApiSetupAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error)
}

// AppDataSchemasAPIService AppDataSchemasAPI service
type AppDataSchemasAPIService service

type ApiArchiveAppDataSchemaRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id string
	autoCreate *bool
}

func (r ApiArchiveAppDataSchemaRequest) AutoCreate(autoCreate bool) ApiArchiveAppDataSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveAppDataSchemaRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAppDataSchemaExecute(r)
}

/*
ArchiveAppDataSchema Method for ArchiveAppDataSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the app-data-schema to retrive
 @return ApiArchiveAppDataSchemaRequest
*/
func (a *AppDataSchemasAPIService) ArchiveAppDataSchema(ctx context.Context, id string) ApiArchiveAppDataSchemaRequest {
	return ApiArchiveAppDataSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppDataSchemasAPIService) ArchiveAppDataSchemaExecute(r ApiArchiveAppDataSchemaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.ArchiveAppDataSchema")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiArchiveAppDataSchemaInstanceRequest) Id(id string) ApiArchiveAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiArchiveAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiArchiveAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiArchiveAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiArchiveAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiArchiveAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiArchiveAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiArchiveAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiArchiveAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveAppDataSchemaInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAppDataSchemaInstanceExecute(r)
}

/*
ArchiveAppDataSchemaInstance Method for ArchiveAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) ArchiveAppDataSchemaInstance(ctx context.Context) ApiArchiveAppDataSchemaInstanceRequest {
	return ApiArchiveAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppDataSchemasAPIService) ArchiveAppDataSchemaInstanceExecute(r ApiArchiveAppDataSchemaInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.ArchiveAppDataSchemaInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiArchiveAppDataSchemasRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	autoCreate *bool
}

func (r ApiArchiveAppDataSchemasRequest) AutoCreate(autoCreate bool) ApiArchiveAppDataSchemasRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiArchiveAppDataSchemasRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAppDataSchemasExecute(r)
}

/*
ArchiveAppDataSchemas Method for ArchiveAppDataSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArchiveAppDataSchemasRequest
*/
func (a *AppDataSchemasAPIService) ArchiveAppDataSchemas(ctx context.Context) ApiArchiveAppDataSchemasRequest {
	return ApiArchiveAppDataSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AppDataSchemasAPIService) ArchiveAppDataSchemasExecute(r ApiArchiveAppDataSchemasRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.ArchiveAppDataSchemas")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAppDataSchemaRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	appDataSchemaCreateDto *AppDataSchemaCreateDto
}

func (r ApiCreateAppDataSchemaRequest) AppDataSchemaCreateDto(appDataSchemaCreateDto AppDataSchemaCreateDto) ApiCreateAppDataSchemaRequest {
	r.appDataSchemaCreateDto = &appDataSchemaCreateDto
	return r
}

func (r ApiCreateAppDataSchemaRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.CreateAppDataSchemaExecute(r)
}

/*
CreateAppDataSchema Method for CreateAppDataSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAppDataSchemaRequest
*/
func (a *AppDataSchemasAPIService) CreateAppDataSchema(ctx context.Context) ApiCreateAppDataSchemaRequest {
	return ApiCreateAppDataSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) CreateAppDataSchemaExecute(r ApiCreateAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.CreateAppDataSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appDataSchemaCreateDto == nil {
		return localVarReturnValue, nil, reportError("appDataSchemaCreateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appDataSchemaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiCreateAppDataSchemaInstanceRequest) Body(body map[string]interface{}) ApiCreateAppDataSchemaInstanceRequest {
	r.body = &body
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) Id(id string) ApiCreateAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiCreateAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiCreateAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiCreateAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiCreateAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiCreateAppDataSchemaInstanceRequest) Execute() (*AppDataSchemaInstanceDto, *http.Response, error) {
	return r.ApiService.CreateAppDataSchemaInstanceExecute(r)
}

/*
CreateAppDataSchemaInstance Method for CreateAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) CreateAppDataSchemaInstance(ctx context.Context) ApiCreateAppDataSchemaInstanceRequest {
	return ApiCreateAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaInstanceDto
func (a *AppDataSchemasAPIService) CreateAppDataSchemaInstanceExecute(r ApiCreateAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.CreateAppDataSchemaInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppDataSchemaRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id string
	autoCreate *bool
}

func (r ApiGetAppDataSchemaRequest) AutoCreate(autoCreate bool) ApiGetAppDataSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetAppDataSchemaRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.GetAppDataSchemaExecute(r)
}

/*
GetAppDataSchema Method for GetAppDataSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the app-data-schema to retrive
 @return ApiGetAppDataSchemaRequest
*/
func (a *AppDataSchemasAPIService) GetAppDataSchema(ctx context.Context, id string) ApiGetAppDataSchemaRequest {
	return ApiGetAppDataSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) GetAppDataSchemaExecute(r ApiGetAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.GetAppDataSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiGetAppDataSchemaInstanceRequest) Id(id string) ApiGetAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiGetAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiGetAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiGetAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiGetAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiGetAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiGetAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiGetAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiGetAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetAppDataSchemaInstanceRequest) Execute() (*AppDataSchemaInstanceDto, *http.Response, error) {
	return r.ApiService.GetAppDataSchemaInstanceExecute(r)
}

/*
GetAppDataSchemaInstance Method for GetAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) GetAppDataSchemaInstance(ctx context.Context) ApiGetAppDataSchemaInstanceRequest {
	return ApiGetAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaInstanceDto
func (a *AppDataSchemasAPIService) GetAppDataSchemaInstanceExecute(r ApiGetAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.GetAppDataSchemaInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAppDataSchemasRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	autoCreate *bool
}

func (r ApiGetAppDataSchemasRequest) AutoCreate(autoCreate bool) ApiGetAppDataSchemasRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiGetAppDataSchemasRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.GetAppDataSchemasExecute(r)
}

/*
GetAppDataSchemas Method for GetAppDataSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAppDataSchemasRequest
*/
func (a *AppDataSchemasAPIService) GetAppDataSchemas(ctx context.Context) ApiGetAppDataSchemasRequest {
	return ApiGetAppDataSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) GetAppDataSchemasExecute(r ApiGetAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.GetAppDataSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppDataSchemaInstancesRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id *string
	userId *string
	appDataSchemaId *string
	instanceKey *string
}

func (r ApiListAppDataSchemaInstancesRequest) Id(id string) ApiListAppDataSchemaInstancesRequest {
	r.id = &id
	return r
}

func (r ApiListAppDataSchemaInstancesRequest) UserId(userId string) ApiListAppDataSchemaInstancesRequest {
	r.userId = &userId
	return r
}

func (r ApiListAppDataSchemaInstancesRequest) AppDataSchemaId(appDataSchemaId string) ApiListAppDataSchemaInstancesRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiListAppDataSchemaInstancesRequest) InstanceKey(instanceKey string) ApiListAppDataSchemaInstancesRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiListAppDataSchemaInstancesRequest) Execute() (*ListAppDataSchemaInstances200Response, *http.Response, error) {
	return r.ApiService.ListAppDataSchemaInstancesExecute(r)
}

/*
ListAppDataSchemaInstances Method for ListAppDataSchemaInstances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAppDataSchemaInstancesRequest
*/
func (a *AppDataSchemasAPIService) ListAppDataSchemaInstances(ctx context.Context) ApiListAppDataSchemaInstancesRequest {
	return ApiListAppDataSchemaInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAppDataSchemaInstances200Response
func (a *AppDataSchemasAPIService) ListAppDataSchemaInstancesExecute(r ApiListAppDataSchemaInstancesRequest) (*ListAppDataSchemaInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAppDataSchemaInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.ListAppDataSchemaInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAppDataSchemasRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
}

func (r ApiListAppDataSchemasRequest) Execute() (*ListAppDataSchemas200Response, *http.Response, error) {
	return r.ApiService.ListAppDataSchemasExecute(r)
}

/*
ListAppDataSchemas Method for ListAppDataSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAppDataSchemasRequest
*/
func (a *AppDataSchemasAPIService) ListAppDataSchemas(ctx context.Context) ApiListAppDataSchemasRequest {
	return ApiListAppDataSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAppDataSchemas200Response
func (a *AppDataSchemasAPIService) ListAppDataSchemasExecute(r ApiListAppDataSchemasRequest) (*ListAppDataSchemas200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAppDataSchemas200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.ListAppDataSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAppDataSchemaRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id string
	appDataSchemaCreateDto *AppDataSchemaCreateDto
	autoCreate *bool
}

func (r ApiPatchAppDataSchemaRequest) AppDataSchemaCreateDto(appDataSchemaCreateDto AppDataSchemaCreateDto) ApiPatchAppDataSchemaRequest {
	r.appDataSchemaCreateDto = &appDataSchemaCreateDto
	return r
}

func (r ApiPatchAppDataSchemaRequest) AutoCreate(autoCreate bool) ApiPatchAppDataSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchAppDataSchemaRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.PatchAppDataSchemaExecute(r)
}

/*
PatchAppDataSchema Method for PatchAppDataSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the app-data-schema to retrive
 @return ApiPatchAppDataSchemaRequest
*/
func (a *AppDataSchemasAPIService) PatchAppDataSchema(ctx context.Context, id string) ApiPatchAppDataSchemaRequest {
	return ApiPatchAppDataSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) PatchAppDataSchemaExecute(r ApiPatchAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PatchAppDataSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appDataSchemaCreateDto == nil {
		return localVarReturnValue, nil, reportError("appDataSchemaCreateDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appDataSchemaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiPatchAppDataSchemaInstanceRequest) Body(body map[string]interface{}) ApiPatchAppDataSchemaInstanceRequest {
	r.body = &body
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) Id(id string) ApiPatchAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiPatchAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiPatchAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiPatchAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiPatchAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchAppDataSchemaInstanceRequest) Execute() (*AppDataSchemaInstanceDto, *http.Response, error) {
	return r.ApiService.PatchAppDataSchemaInstanceExecute(r)
}

/*
PatchAppDataSchemaInstance Method for PatchAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) PatchAppDataSchemaInstance(ctx context.Context) ApiPatchAppDataSchemaInstanceRequest {
	return ApiPatchAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaInstanceDto
func (a *AppDataSchemasAPIService) PatchAppDataSchemaInstanceExecute(r ApiPatchAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PatchAppDataSchemaInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAppDataSchemasRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	appDataSchemaCreateDto *AppDataSchemaCreateDto
	autoCreate *bool
}

func (r ApiPatchAppDataSchemasRequest) AppDataSchemaCreateDto(appDataSchemaCreateDto AppDataSchemaCreateDto) ApiPatchAppDataSchemasRequest {
	r.appDataSchemaCreateDto = &appDataSchemaCreateDto
	return r
}

func (r ApiPatchAppDataSchemasRequest) AutoCreate(autoCreate bool) ApiPatchAppDataSchemasRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPatchAppDataSchemasRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.PatchAppDataSchemasExecute(r)
}

/*
PatchAppDataSchemas Method for PatchAppDataSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPatchAppDataSchemasRequest
*/
func (a *AppDataSchemasAPIService) PatchAppDataSchemas(ctx context.Context) ApiPatchAppDataSchemasRequest {
	return ApiPatchAppDataSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) PatchAppDataSchemasExecute(r ApiPatchAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PatchAppDataSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appDataSchemaCreateDto == nil {
		return localVarReturnValue, nil, reportError("appDataSchemaCreateDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appDataSchemaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAppDataSchemaRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id string
	appDataSchemaCreateDto *AppDataSchemaCreateDto
	autoCreate *bool
}

func (r ApiPutAppDataSchemaRequest) AppDataSchemaCreateDto(appDataSchemaCreateDto AppDataSchemaCreateDto) ApiPutAppDataSchemaRequest {
	r.appDataSchemaCreateDto = &appDataSchemaCreateDto
	return r
}

func (r ApiPutAppDataSchemaRequest) AutoCreate(autoCreate bool) ApiPutAppDataSchemaRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutAppDataSchemaRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.PutAppDataSchemaExecute(r)
}

/*
PutAppDataSchema Method for PutAppDataSchema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the app-data-schema to retrive
 @return ApiPutAppDataSchemaRequest
*/
func (a *AppDataSchemasAPIService) PutAppDataSchema(ctx context.Context, id string) ApiPutAppDataSchemaRequest {
	return ApiPutAppDataSchemaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) PutAppDataSchemaExecute(r ApiPutAppDataSchemaRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PutAppDataSchema")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schemas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appDataSchemaCreateDto == nil {
		return localVarReturnValue, nil, reportError("appDataSchemaCreateDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appDataSchemaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	body *map[string]interface{}
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiPutAppDataSchemaInstanceRequest) Body(body map[string]interface{}) ApiPutAppDataSchemaInstanceRequest {
	r.body = &body
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) Id(id string) ApiPutAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiPutAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiPutAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiPutAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiPutAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutAppDataSchemaInstanceRequest) Execute() (*AppDataSchemaInstanceDto, *http.Response, error) {
	return r.ApiService.PutAppDataSchemaInstanceExecute(r)
}

/*
PutAppDataSchemaInstance Method for PutAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) PutAppDataSchemaInstance(ctx context.Context) ApiPutAppDataSchemaInstanceRequest {
	return ApiPutAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaInstanceDto
func (a *AppDataSchemasAPIService) PutAppDataSchemaInstanceExecute(r ApiPutAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PutAppDataSchemaInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAppDataSchemasRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	appDataSchemaCreateDto *AppDataSchemaCreateDto
	autoCreate *bool
}

func (r ApiPutAppDataSchemasRequest) AppDataSchemaCreateDto(appDataSchemaCreateDto AppDataSchemaCreateDto) ApiPutAppDataSchemasRequest {
	r.appDataSchemaCreateDto = &appDataSchemaCreateDto
	return r
}

func (r ApiPutAppDataSchemasRequest) AutoCreate(autoCreate bool) ApiPutAppDataSchemasRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiPutAppDataSchemasRequest) Execute() (*AppDataSchemaDto, *http.Response, error) {
	return r.ApiService.PutAppDataSchemasExecute(r)
}

/*
PutAppDataSchemas Method for PutAppDataSchemas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutAppDataSchemasRequest
*/
func (a *AppDataSchemasAPIService) PutAppDataSchemas(ctx context.Context) ApiPutAppDataSchemasRequest {
	return ApiPutAppDataSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaDto
func (a *AppDataSchemasAPIService) PutAppDataSchemasExecute(r ApiPutAppDataSchemasRequest) (*AppDataSchemaDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.PutAppDataSchemas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appDataSchemaCreateDto == nil {
		return localVarReturnValue, nil, reportError("appDataSchemaCreateDto is required and must be specified")
	}

	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appDataSchemaCreateDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetupAppDataSchemaInstanceRequest struct {
	ctx context.Context
	ApiService AppDataSchemasAPI
	id *string
	instanceKey *string
	appDataSchemaId *string
	appDataSchemaKey *string
	autoCreate *bool
}

func (r ApiSetupAppDataSchemaInstanceRequest) Id(id string) ApiSetupAppDataSchemaInstanceRequest {
	r.id = &id
	return r
}

func (r ApiSetupAppDataSchemaInstanceRequest) InstanceKey(instanceKey string) ApiSetupAppDataSchemaInstanceRequest {
	r.instanceKey = &instanceKey
	return r
}

func (r ApiSetupAppDataSchemaInstanceRequest) AppDataSchemaId(appDataSchemaId string) ApiSetupAppDataSchemaInstanceRequest {
	r.appDataSchemaId = &appDataSchemaId
	return r
}

func (r ApiSetupAppDataSchemaInstanceRequest) AppDataSchemaKey(appDataSchemaKey string) ApiSetupAppDataSchemaInstanceRequest {
	r.appDataSchemaKey = &appDataSchemaKey
	return r
}

func (r ApiSetupAppDataSchemaInstanceRequest) AutoCreate(autoCreate bool) ApiSetupAppDataSchemaInstanceRequest {
	r.autoCreate = &autoCreate
	return r
}

func (r ApiSetupAppDataSchemaInstanceRequest) Execute() (*AppDataSchemaInstanceDto, *http.Response, error) {
	return r.ApiService.SetupAppDataSchemaInstanceExecute(r)
}

/*
SetupAppDataSchemaInstance Method for SetupAppDataSchemaInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetupAppDataSchemaInstanceRequest
*/
func (a *AppDataSchemasAPIService) SetupAppDataSchemaInstance(ctx context.Context) ApiSetupAppDataSchemaInstanceRequest {
	return ApiSetupAppDataSchemaInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppDataSchemaInstanceDto
func (a *AppDataSchemasAPIService) SetupAppDataSchemaInstanceExecute(r ApiSetupAppDataSchemaInstanceRequest) (*AppDataSchemaInstanceDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppDataSchemaInstanceDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppDataSchemasAPIService.SetupAppDataSchemaInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app-data-schema-instance/setup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.instanceKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceKey", r.instanceKey, "")
	}
	if r.appDataSchemaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaId", r.appDataSchemaId, "")
	}
	if r.appDataSchemaKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "appDataSchemaKey", r.appDataSchemaKey, "")
	}
	if r.autoCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoCreate", r.autoCreate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
